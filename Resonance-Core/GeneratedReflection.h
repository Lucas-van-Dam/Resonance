struct fpos_Reflection {
    static constexpr auto __st_ = "_StateT";
    static constexpr auto __off_ = "streamoff";
};
struct enable_if_Reflection {
};
struct enable_if_Reflection {
};
struct integral_constant_Reflection {
};
struct remove_cv_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct __equal_tag_Reflection {
};
struct __plus_tag_Reflection {
};
struct __totally_ordered_less_tag_Reflection {
};
struct __equal_to_Reflection {
};
struct __less_Reflection {
};
struct __less_Reflection {
};
struct __debug_less_Reflection {
    static constexpr auto __comp_ = "_Compare &";
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct is_floating_point_Reflection {
};
struct is_arithmetic_Reflection {
};
struct is_signed_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct is_convertible_Reflection {
};
struct is_function_Reflection {
};
struct is_reference_Reflection {
};
struct is_lvalue_reference_Reflection {
};
struct is_rvalue_reference_Reflection {
};
struct remove_all_extents_Reflection {
};
struct is_destructible_Reflection {
};
struct is_nothrow_destructible_Reflection {
};
struct is_same_Reflection {
};
struct __libcpp_is_referenceable_Reflection {
};
struct add_lvalue_reference_Reflection {
};
struct add_rvalue_reference_Reflection {
};
struct is_constructible_Reflection {
};
struct is_copy_constructible_Reflection {
};
struct is_move_constructible_Reflection {
};
struct is_default_constructible_Reflection {
};
struct _IfImpl_Reflection {
};
struct _IfImpl_Reflection {
};
struct conditional_Reflection {
};
struct conditional_Reflection {
};
struct is_void_Reflection {
};
struct remove_reference_Reflection {
};
struct add_pointer_Reflection {
};
struct is_array_Reflection {
};
struct remove_extent_Reflection {
};
struct decay_Reflection {
};
struct __type_identity_Reflection {
};
struct __empty_Reflection {
};
struct common_type_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct is_class_Reflection {
};
struct is_enum_Reflection {
};
struct is_union_Reflection {
};
struct extent_Reflection {
};
struct is_nothrow_assignable_Reflection {
};
struct is_nothrow_copy_assignable_Reflection {
};
struct is_nothrow_move_assignable_Reflection {
};
struct is_nothrow_constructible_Reflection {
};
struct is_nothrow_copy_constructible_Reflection {
};
struct is_nothrow_move_constructible_Reflection {
};
struct is_nothrow_default_constructible_Reflection {
};
struct is_assignable_Reflection {
};
struct is_copy_assignable_Reflection {
};
struct is_move_assignable_Reflection {
};
struct is_swappable_with_Reflection {
};
struct is_swappable_Reflection {
};
struct is_nothrow_swappable_with_Reflection {
};
struct is_nothrow_swappable_Reflection {
};
struct is_object_Reflection {
};
struct __nat_Reflection {
};
struct __type_list_Reflection {
};
struct __find_first_Reflection {
};
struct __find_first_Reflection {
};
struct make_signed_Reflection {
};
struct _OrImpl_Reflection {
};
struct _OrImpl_Reflection {
};
struct disjunction_Reflection {
};
struct remove_const_Reflection {
};
struct input_iterator_tag_Reflection {
};
struct output_iterator_tag_Reflection {
};
struct forward_iterator_tag_Reflection {
};
struct bidirectional_iterator_tag_Reflection {
};
struct random_access_iterator_tag_Reflection {
};
struct __iter_traits_cache_Reflection {
};
struct __iter_concept_concept_test_Reflection {
};
struct __iter_concept_category_test_Reflection {
};
struct __iter_concept_random_fallback_Reflection {
};
struct __test_iter_concept_Reflection {
};
struct __iter_concept_cache_Reflection {
};
struct __has_iterator_typedefs_Reflection {
};
struct __has_iterator_category_Reflection {
};
struct __has_iterator_concept_Reflection {
};
struct __iterator_traits_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __is_callable_Reflection {
};
struct initializer_list_Reflection {
    static constexpr auto __begin_ = "const _Ep *";
    static constexpr auto __size_ = "size_t";
};
struct __is_identity_Reflection {
};
struct __identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct is_base_of_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct is_member_pointer_Reflection {
};
struct is_member_object_pointer_Reflection {
};
struct is_member_function_pointer_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __invokable_r_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __invoke_of_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct is_invocable_Reflection {
};
struct is_invocable_r_Reflection {
};
struct is_nothrow_invocable_Reflection {
};
struct is_nothrow_invocable_r_Reflection {
};
struct invoke_result_Reflection {
};
struct __has_specialization_Reflection {
};
struct __has_specialization_Reflection {
};
struct __all_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct __has_pointer_Reflection {
};
struct __has_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __has_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __has_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_impl_Reflection {
};
struct pointer_traits_Reflection {
};
struct pointer_traits_Reflection {
};
struct __nat_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasArrow_Reflection {
};
struct _HasArrow_Reflection {
};
struct _IsFancyPointer_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct add_const_Reflection {
};
struct add_cv_Reflection {
};
struct add_volatile_Reflection {
};
struct __align_type_Reflection {
};
struct __struct_double_Reflection {
    static constexpr auto __lx = "long double";
};
struct __struct_double4_Reflection {
    static constexpr auto __lx = "double[4]";
};
struct __fallback_overaligned_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_max_align_Reflection {
};
struct __select_align_Reflection {
};
struct __find_max_align_Reflection {
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __align = "_Aligner";
    static constexpr auto __data = "unsigned char[(_Len + _Align - 1) / _Align * _Align]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1 - 1) / 1 * 1]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2 - 1) / 2 * 2]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4 - 1) / 4 * 4]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8 - 1) / 8 * 8]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 16 - 1) / 16 * 16]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 32 - 1) / 32 * 32]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 64 - 1) / 64 * 64]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 128 - 1) / 128 * 128]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 256 - 1) / 256 * 256]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 512 - 1) / 512 * 512]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1024 - 1) / 1024 * 1024]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2048 - 1) / 2048 * 2048]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4096 - 1) / 4096 * 4096]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8192 - 1) / 8192 * 8192]";
};
struct __static_max_Reflection {
};
struct __static_max_Reflection {
};
struct aligned_union_Reflection {
};
struct alignment_of_Reflection {
};
struct has_virtual_destructor_Reflection {
};
struct is_abstract_Reflection {
};
struct is_null_pointer_Reflection {
};
struct is_fundamental_Reflection {
};
struct is_compound_Reflection {
};
struct is_const_Reflection {
};
struct is_empty_Reflection {
};
struct is_literal_type_Reflection {
};
struct is_pod_Reflection {
};
struct is_pointer_Reflection {
};
struct is_polymorphic_Reflection {
};
struct is_scalar_Reflection {
};
struct is_standard_layout_Reflection {
};
struct is_trivial_Reflection {
};
struct is_trivially_assignable_Reflection {
};
struct is_trivially_copy_assignable_Reflection {
};
struct is_trivially_move_assignable_Reflection {
};
struct is_trivially_constructible_Reflection {
};
struct is_trivially_copy_constructible_Reflection {
};
struct is_trivially_move_constructible_Reflection {
};
struct is_trivially_default_constructible_Reflection {
};
struct is_trivially_copyable_Reflection {
};
struct is_trivially_destructible_Reflection {
};
struct is_unsigned_Reflection {
};
struct is_volatile_Reflection {
};
struct make_unsigned_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct remove_pointer_Reflection {
};
struct remove_volatile_Reflection {
};
struct result_of_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct underlying_type_Reflection {
};
struct __libcpp_is_final_Reflection {
};
struct is_final_Reflection {
};
struct has_unique_object_representations_Reflection {
};
struct is_aggregate_Reflection {
};
struct _Not_Reflection {
};
struct negation_Reflection {
};
struct _FirstPaddingByte_Reflection {
    static constexpr auto __v_ = "_Tp";
    static constexpr auto __first_padding_byte_ = "char";
};
struct __is_always_bitcastable_Reflection {
};
struct __is_equality_comparable_Reflection {
};
struct __libcpp_is_trivially_equality_comparable_impl_Reflection {
};
struct __is_less_than_comparable_Reflection {
};
struct __find_segment_Reflection {
    static constexpr auto __value_ = "const _Tp &";
};
struct __unary_function_keep_layout_base_Reflection {
};
struct __integer_sequence_Reflection {
};
struct integer_sequence_Reflection {
};
struct __tuple_indices_Reflection {
};
struct __make_tuple_indices_Reflection {
};
struct __tuple_types_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_size_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_sfinae_base_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct tuple_element_Reflection {
};
struct __check_tuple_constructor_fail_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __libcpp_is_trivially_relocatable_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_ref_decay_Reflection {
};
struct piecewise_construct_t_Reflection {
};
struct __non_trivially_copyable_base_Reflection {
};
struct pair_Reflection {
    static constexpr auto first = "_T1";
    static constexpr auto second = "_T2";
};
struct _CheckArgs_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct __get_pair_Reflection {
};
struct __get_pair_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct _PairT_Reflection {
    static constexpr auto first = "size_t";
    static constexpr auto second = "size_t";
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct _Reflection {
    static constexpr auto __t = "long double";
    static constexpr auto __s = "struct (unnamed struct at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__functional\hash.h:476:7)";
};
struct _Reflection {
    static constexpr auto __a = "size_t";
    static constexpr auto __b = "size_t";
};
struct __enum_hash_Reflection {
};
struct __enum_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __bounded_iter_Reflection {
    static constexpr auto __current_ = "_Iterator";
    static constexpr auto __begin_ = "_Iterator";
    static constexpr auto __end_ = "_Iterator";
};
struct __sfinae_underlying_type_Reflection {
};
struct __sfinae_underlying_type_Reflection {
};
struct iterator_Reflection {
};
struct reverse_iterator_Reflection {
    static constexpr auto __t_ = "_Iter";
    static constexpr auto current = "_Iter";
};
struct __unwrap_iter_impl_Reflection {
};
struct __wrap_iter_Reflection {
    static constexpr auto __i_ = "iterator_type";
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct pointer_traits_Reflection {
};
struct __pointer_Reflection {
};
struct __pointer_Reflection {
};
struct __has_const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __has_void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __has_const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __has_size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __has_alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __has_propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __has_propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __has_propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __has_is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __has_rebind_other_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct allocator_traits_Reflection {
};
struct __check_valid_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_cpp17_move_insertable_Reflection {
};
struct __is_cpp17_copy_insertable_Reflection {
};
struct __allocation_result_Reflection {
    static constexpr auto ptr = "_Pointer";
    static constexpr auto count = "size_t";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __noexcept_move_assign_container_Reflection {
};
struct memory_resource_Reflection {
};
struct __exception_guard_exceptions_Reflection {
    static constexpr auto __rollback_ = "_Rollback";
    static constexpr auto __completed_ = "_Bool";
};
struct __exception_guard_noexceptions_Reflection {
    static constexpr auto __completed_ = "_Bool";
};
struct __has_allocator_type_Reflection {
};
struct __uses_allocator_Reflection {
};
struct __uses_allocator_Reflection {
};
struct uses_allocator_Reflection {
};
struct allocator_arg_t_Reflection {
};
struct __uses_alloc_ctor_imp_Reflection {
};
struct __uses_alloc_ctor_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_t_Reflection {
};
struct __ignore_type_Reflection {
};
struct _Lazy_Reflection {
};
struct __promote_Reflection {
};
struct __tuple_leaf_Reflection {
    static constexpr auto __value_ = "_Hp";
};
struct __tuple_leaf_Reflection {
};
struct __all_default_constructible_Reflection {
};
struct __tuple_impl_Reflection {
};
struct tuple_Reflection {
    static constexpr auto __base_ = "_BaseT";
};
struct _IsThisTuple_Reflection {
};
struct _EnableUTypesCtor_Reflection {
};
struct _EnableCtorFromUTypesTuple_Reflection {
};
struct _CtorPredicateFromPair_Reflection {
};
struct _EnableCtorFromPair_Reflection {
};
struct _NothrowConstructibleFromPair_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _AssignPredicateFromPair_Reflection {
};
struct _EnableAssignFromPair_Reflection {
};
struct _NothrowAssignFromPair_Reflection {
};
struct tuple_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_cat_type_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_Reflection {
};
struct __tuple_cat_Reflection {
};
struct uses_allocator_Reflection {
};
struct bad_cast_Reflection {
};
struct bad_typeid_Reflection {
};
struct exception_ptr_Reflection {
    static constexpr auto __ptr1_ = "void *";
    static constexpr auto __ptr2_ = "void *";
};
struct nested_exception_Reflection {
    static constexpr auto __ptr_ = "exception_ptr";
};
struct __nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __can_dynamic_cast_Reflection {
};
struct __save_flags_Reflection {
    static constexpr auto __stream_ = "__stream_type &";
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __fill_ = "_CharT";
};
struct in_place_t_Reflection {
};
struct in_place_type_t_Reflection {
};
struct in_place_index_t_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct polymorphic_allocator_Reflection {
    static constexpr auto __res_ = "memory_resource *";
};
struct _ClassicAlgPolicy_Reflection {
};
struct _IterOps_Reflection {
};
struct char_traits_Reflection {
};
struct __char_traits_base_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct __is_allocator_Reflection {
};
struct logic_error_Reflection {
};
struct runtime_error_Reflection {
};
struct domain_error_Reflection {
};
struct invalid_argument_Reflection {
};
struct length_error_Reflection {
};
struct out_of_range_Reflection {
};
struct range_error_Reflection {
};
struct overflow_error_Reflection {
};
struct underflow_error_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto __data_ = "const value_type *";
    static constexpr auto __size_ = "size_type";
};
struct __assume_valid_Reflection {
};
struct __string_view_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __can_lower_copy_assignment_to_memmove_Reflection {
};
struct __can_lower_move_assignment_to_memmove_Reflection {
};
struct __can_rewrap_Reflection {
};
struct __copy_impl_Reflection {
};
struct _CopySegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __copy_backward_impl_Reflection {
};
struct nullopt_t_Reflection {
};
struct __secret_tag_Reflection {
};
struct __optional_construct_from_invoke_tag_Reflection {
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_storage_base_Reflection {
};
struct __optional_storage_base_Reflection {
    static constexpr auto __value_ = "int *";
};
struct __optional_copy_base_Reflection {
};
struct __optional_copy_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __is_std_optional_Reflection {
};
struct __is_std_optional_Reflection {
};
struct optional_Reflection {
};
struct _CheckOptionalArgsConstructor_Reflection {
};
struct _CheckOptionalLikeConstructor_Reflection {
};
struct __cxx_atomic_base_impl_Reflection {
    static constexpr auto __a_value = "_Atomic(_Tp)";
};
struct __cxx_atomic_impl_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_lcm_Reflection {
};
struct __static_abs_Reflection {
};
struct __static_sign_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_div_Reflection {
};
struct ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __ratio_multiply_Reflection {
};
struct __ratio_divide_Reflection {
};
struct __ratio_add_Reflection {
};
struct __ratio_subtract_Reflection {
};
struct ratio_equal_Reflection {
};
struct ratio_not_equal_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct ratio_less_Reflection {
};
struct ratio_less_equal_Reflection {
};
struct ratio_greater_Reflection {
};
struct ratio_greater_equal_Reflection {
};
struct __ratio_gcd_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct common_type_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct treat_as_floating_point_Reflection {
};
struct duration_values_Reflection {
};
struct duration_Reflection {
    static constexpr auto __rep_ = "rep";
};
struct __no_overflow_Reflection {
};
struct __mul_Reflection {
};
struct __mul_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_lt_Reflection {
};
struct __duration_lt_Reflection {
};
struct time_point_Reflection {
    static constexpr auto __d_ = "duration";
};
struct common_type_Reflection {
};
struct steady_clock_Reflection {
};
struct system_clock_Reflection {
};
struct __spinning_backoff_policy_Reflection {
};
struct __atomic_waitable_traits_Reflection {
};
struct __atomic_waitable_Reflection {
};
struct __atomic_wait_poll_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_wait_backoff_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_compare_unequal_to_Reflection {
    static constexpr auto __val_ = "_Tp";
};
struct __libcpp_is_always_lock_free_Reflection {
};
struct __atomic_base_Reflection {
    static constexpr auto __a_ = "int";
};
struct __atomic_base_Reflection {
};
struct __binary_function_keep_layout_base_Reflection {
};
struct plus_Reflection {
};
struct plus_Reflection {
};
struct minus_Reflection {
};
struct minus_Reflection {
};
struct multiplies_Reflection {
};
struct multiplies_Reflection {
};
struct divides_Reflection {
};
struct divides_Reflection {
};
struct modulus_Reflection {
};
struct modulus_Reflection {
};
struct negate_Reflection {
};
struct negate_Reflection {
};
struct bit_and_Reflection {
};
struct bit_and_Reflection {
};
struct bit_not_Reflection {
};
struct bit_not_Reflection {
};
struct bit_or_Reflection {
};
struct bit_or_Reflection {
};
struct bit_xor_Reflection {
};
struct bit_xor_Reflection {
};
struct equal_to_Reflection {
};
struct equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct less_Reflection {
};
struct less_Reflection {
};
struct less_equal_Reflection {
};
struct less_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_Reflection {
};
struct greater_Reflection {
};
struct logical_and_Reflection {
};
struct logical_and_Reflection {
};
struct logical_not_Reflection {
};
struct logical_not_Reflection {
};
struct logical_or_Reflection {
};
struct logical_or_Reflection {
};
struct atomic_Reflection {
};
struct atomic_Reflection {
};
struct atomic_flag_Reflection {
    static constexpr auto __a_ = "int";
};
struct back_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct front_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
    static constexpr auto iter = "int";
};
struct istream_iterator_Reflection {
    static constexpr auto __in_stream_ = "istream_type *";
    static constexpr auto __value_ = "_Tp";
};
struct istreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __proxy_Reflection {
    static constexpr auto __keep_ = "char_type";
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct move_iterator_Reflection {
    static constexpr auto __current_ = "_Iter";
};
struct ostream_iterator_Reflection {
    static constexpr auto __out_stream_ = "ostream_type *";
    static constexpr auto __delim_ = "const char_type *";
};
struct ostreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __dependent_type_Reflection {
};
struct monostate_Reflection {
};
struct hash_Reflection {
};
struct __farray_Reflection {
    static constexpr auto __buf_ = "_Tp[_Size]";
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_Reflection {
};
struct __valueless_t_Reflection {
};
struct __traits_Reflection {
};
struct __union_Reflection {
};
struct __base_Reflection {
};
struct __variant_Reflection {
};
struct __base_Reflection {
};
struct __dispatcher_Reflection {
};
struct __variant_Reflection {
};
struct __value_visitor_Reflection {
    static constexpr auto __visitor = "_Visitor &&";
};
struct __alt_Reflection {
    static constexpr auto __value = "__value_type";
};
struct __union_Reflection {
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_TriviallyAvailable, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Available, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Unavailable, _Index + 1, _Types...>";
};
struct __base_Reflection {
    static constexpr auto __data = "__union<_DestructibleTrait, 0, _Types...>";
    static constexpr auto __index = "int";
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __ctor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __impl_Reflection {
};
struct __no_narrowing_check_Reflection {
};
struct __narrowing_check_Reflection {
};
struct __overload_Reflection {
};
struct __all_overloads_Reflection {
};
struct __make_overloads_imp_Reflection {
};
struct variant_Reflection {
    static constexpr auto __impl_ = "__variant_detail::__impl<_Types...>";
};
struct __convert_to_bool_Reflection {
};
struct __has_result_type_Reflection {
};
struct __derives_from_unary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __derives_from_binary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct reference_wrapper_Reflection {
    static constexpr auto __f_ = "type *";
};
struct __allocation_guard_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __n_ = "_Size";
    static constexpr auto __ptr_ = "_Pointer";
};
struct __allocator_destructor_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __s_ = "size_type";
};
struct __move_impl_Reflection {
};
struct _MoveSegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __always_false_Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _AllocatorDestroyRangeReverse_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __first_ = "_Iter &";
    static constexpr auto __last_ = "_Iter &";
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __has_array_cookie_Reflection {
};
struct __private_constructor_tag_Reflection {
};
struct default_delete_Reflection {
};
struct default_delete_Reflection {
};
struct _EnableIfConvertible_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
};
struct __unique_ptr_array_bounds_stateless_Reflection {
};
struct __unique_ptr_array_bounds_stored_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
    static constexpr auto __checker_ = "_BoundsChecker";
};
struct _CheckArrayPointerConversion_Reflection {
};
struct _CheckArrayPointerConversion_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct bad_weak_ptr_Reflection {
};
struct __shared_count_Reflection {
    static constexpr auto __shared_owners_ = "long";
};
struct __shared_weak_count_Reflection {
    static constexpr auto __shared_weak_owners_ = "long";
};
struct __shared_ptr_pointer_Reflection {
    static constexpr auto __ptr_ = "_Tp";
    static constexpr auto __deleter_ = "_Dp";
    static constexpr auto __alloc_ = "_Alloc";
};
struct __for_overwrite_tag_Reflection {
};
struct __shared_ptr_emplace_Reflection {
    static constexpr auto __storage_ = "_Storage";
};
struct _Storage_Reflection {
    static constexpr auto __buffer_ = "char[sizeof(_Data)]";
};
struct _Data_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __elem_ = "int";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __compatible_with_Reflection {
};
struct __raw_pointer_compatible_with_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __well_formed_deleter_Reflection {
};
struct __shared_ptr_deleter_ctor_reqs_Reflection {
};
struct shared_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct __nullptr_sfinae_tag_Reflection {
};
struct __shared_ptr_default_allocator_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __sp_aligned_storage_Reflection {
    static constexpr auto __storage = "char[_Alignment]";
};
struct __unbounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __count_ = "size_t";
    static constexpr auto  = "union std::__unbounded_array_control_block<type-parameter-0-0[], type-parameter-0-1>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:952:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct __bounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto  = "union std::__bounded_array_control_block<type-parameter-0-0[_Np], type-parameter-0-2>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:1030:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[_Count]";
};
struct weak_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct enable_shared_from_this_Reflection {
    static constexpr auto __weak_this_ = "weak_ptr<_Tp>";
};
struct hash_Reflection {
};
struct __sp_mut_Reflection {
    static constexpr auto __lx_ = "void *";
};
struct raw_storage_iterator_Reflection {
    static constexpr auto __x_ = "_OutputIterator";
};
struct __temporary_buffer_deleter_Reflection {
    static constexpr auto __count_ = "ptrdiff_t";
};
struct __move_backward_impl_Reflection {
};
struct __destruct_n_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct __invert_Reflection {
    static constexpr auto __p_ = "_Predicate";
};
struct _ConstTimeDistance_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct _Reflection {
};
struct __aliasing_iterator_wrapper_Reflection {
};
struct __iterator_Reflection {
    static constexpr auto __base_ = "_BaseIter";
};
struct _MinmaxElementLessFunc_Reflection {
    static constexpr auto __comp_ = "_Comp &";
    static constexpr auto __proj_ = "_Proj &";
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct _ProjectedPred_Reflection {
    static constexpr auto __pred = "_Pred &";
    static constexpr auto __proj = "_Proj &";
};
struct __set_intersection_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_symmetric_difference_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_union_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_urng_Reflection {
};
struct __log2_Reflection {
};
struct __independent_bits_engine_Reflection {
    static constexpr auto __e_ = "_Engine &";
    static constexpr auto __w_ = "size_t";
    static constexpr auto __w0_ = "size_t";
    static constexpr auto __n_ = "size_t";
    static constexpr auto __n0_ = "size_t";
    static constexpr auto __y0_ = "_Working_result_type";
    static constexpr auto __y1_ = "_Working_result_type";
    static constexpr auto __mask0_ = "_Engine_result_type";
    static constexpr auto __mask1_ = "_Engine_result_type";
};
struct uniform_int_distribution_Reflection {
    static constexpr auto __p_ = "param_type";
};
struct param_type_Reflection {
    static constexpr auto __a_ = "result_type";
    static constexpr auto __b_ = "result_type";
};
struct __libcpp_debug_randomizer_Reflection {
    static constexpr auto __state_ = "int";
    static constexpr auto __inc_ = "int";
};
struct __stable_sort_switch_Reflection {
};
struct __reread_from_input_tag_Reflection {
};
struct __reread_from_output_tag_Reflection {
};
struct __read_from_tmp_value_tag_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __can_be_converted_to_string_view_Reflection {
};
struct __uninitialized_size_tag_Reflection {
};
struct __init_with_sentinel_tag_Reflection {
};
struct __padding_Reflection {
    static constexpr auto __padding_ = "char[_PaddingSize]";
};
struct __padding_Reflection {
};
struct basic_string_Reflection {
    static constexpr auto __rep_ = "__rep";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __long_Reflection {
    static constexpr auto  = "struct std::basic_string::__long::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:902:5)";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __data_ = "pointer";
};
struct _Reflection {
    static constexpr auto __is_long_ = "size_type";
    static constexpr auto __cap_ = "size_type";
};
struct __short_Reflection {
    static constexpr auto  = "struct std::basic_string::__short::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:913:5)";
    static constexpr auto __padding_ = "__padding<sizeof(value_type) - 1>";
    static constexpr auto __data_ = "value_type[__min_cap]";
};
struct _Reflection {
    static constexpr auto __is_long_ = "unsigned char";
    static constexpr auto __size_ = "unsigned char";
};
struct __rep_Reflection {
    static constexpr auto __s = "__short";
    static constexpr auto __l = "__long";
};
struct __string_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __lconv_storage_Reflection {
    static constexpr auto __lc_ = "int";
    static constexpr auto __decimal_point_ = "int";
    static constexpr auto __thousands_sep_ = "int";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __int_curr_symbol_ = "int";
    static constexpr auto __currency_symbol_ = "int";
    static constexpr auto __mon_decimal_point_ = "int";
    static constexpr auto __mon_thousands_sep_ = "int";
    static constexpr auto __mon_grouping_ = "int";
    static constexpr auto __positive_sign_ = "int";
    static constexpr auto __negative_sign_ = "int";
};
struct locale_t_Reflection {
    static constexpr auto __locale_str_ = "const char *";
    static constexpr auto __lc_ = "__lconv_storage *";
};
struct once_flag_Reflection {
    static constexpr auto __state_ = "_State_type";
};
struct __call_once_param_Reflection {
    static constexpr auto __f_ = "_Fp &";
};
struct __uninitialized_tag_Reflection {
};
struct __no_destroy_Reflection {
    static constexpr auto __obj_ = "char[sizeof(_Tp)]";
};
struct locale_Reflection {
    static constexpr auto __locale_ = "__imp *";
};
struct facet_Reflection {
};
struct id_Reflection {
    static constexpr auto __flag_ = "once_flag";
    static constexpr auto __id_ = "int";
};
struct collate_Reflection {
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_base_Reflection {
};
struct ctype_Reflection {
};
struct ctype_Reflection {
    static constexpr auto __tab_ = "const mask *";
    static constexpr auto __del_ = "_Bool";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_base_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_byname_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_byname_Reflection {
};
struct numpunct_byname_Reflection {
};
struct error_category_Reflection {
};
struct __do_message_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct error_condition_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct is_error_code_enum_Reflection {
};
struct error_code_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct system_error_Reflection {
    static constexpr auto __ec_ = "error_code";
};
struct ios_base_Reflection {
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __precision_ = "streamsize";
    static constexpr auto __width_ = "streamsize";
    static constexpr auto __rdstate_ = "iostate";
    static constexpr auto __exceptions_ = "iostate";
    static constexpr auto __rdbuf_ = "void *";
    static constexpr auto __loc_ = "void *";
    static constexpr auto __fn_ = "event_callback *";
    static constexpr auto __index_ = "int *";
    static constexpr auto __event_size_ = "size_t";
    static constexpr auto __event_cap_ = "size_t";
    static constexpr auto __iarray_ = "long *";
    static constexpr auto __iarray_size_ = "size_t";
    static constexpr auto __iarray_cap_ = "size_t";
    static constexpr auto __parray_ = "void **";
    static constexpr auto __parray_size_ = "size_t";
    static constexpr auto __parray_cap_ = "size_t";
};
struct is_error_code_enum_Reflection {
};
struct failure_Reflection {
};
struct Init_Reflection {
};
struct _FillHelper_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
    static constexpr auto __set_ = "_Bool";
};
struct _SentinelValueFill_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
};
struct basic_ios_Reflection {
    static constexpr auto __tie_ = "basic_ostream<char_type, traits_type> *";
    static constexpr auto __fill_ = "_FillType";
};
struct mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_mutex_t";
};
struct defer_lock_t_Reflection {
};
struct try_to_lock_t_Reflection {
};
struct adopt_lock_t_Reflection {
};
struct unique_lock_Reflection {
    static constexpr auto __m_ = "mutex_type *";
    static constexpr auto __owns_ = "_Bool";
};
struct condition_variable_Reflection {
    static constexpr auto __cv_ = "__libcpp_condvar_t";
};
struct lock_guard_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct __thread_id_Reflection {
    static constexpr auto __id_ = "__libcpp_thread_id";
};
struct recursive_mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_recursive_mutex_t";
};
struct timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __locked_ = "_Bool";
};
struct recursive_timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __count_ = "size_t";
    static constexpr auto __id_ = "__thread_id";
};
struct scoped_lock_Reflection {
};
struct scoped_lock_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct scoped_lock_Reflection {
    static constexpr auto __t_ = "_MutexTuple";
};
struct __has_storage_type_Reflection {
};
struct __bit_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_reference_Reflection {
};
struct __bit_const_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_array_Reflection {
    static constexpr auto __size_ = "difference_type";
    static constexpr auto __word_ = "__storage_type[4]";
};
struct __bit_iterator_Reflection {
    static constexpr auto __seg_ = "int";
    static constexpr auto __ctz_ = "unsigned int";
};
struct __has_storage_type_Reflection {
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type[_N_words]";
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type";
};
struct __bitset_Reflection {
};
struct bitset_Reflection {
};
struct hash_Reflection {
};
struct basic_streambuf_Reflection {
    static constexpr auto __loc_ = "locale";
    static constexpr auto __binp_ = "char_type *";
    static constexpr auto __ninp_ = "char_type *";
    static constexpr auto __einp_ = "char_type *";
    static constexpr auto __bout_ = "char_type *";
    static constexpr auto __nout_ = "char_type *";
    static constexpr auto __eout_ = "char_type *";
};
struct __num_get_base_Reflection {
};
struct __num_get_Reflection {
};
struct num_get_Reflection {
};
struct __num_put_base_Reflection {
};
struct __num_put_Reflection {
};
struct num_put_Reflection {
};
struct time_base_Reflection {
};
struct __time_get_c_storage_Reflection {
};
struct time_get_Reflection {
};
struct __time_get_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct __time_get_storage_Reflection {
    static constexpr auto __weeks_ = "string_type[14]";
    static constexpr auto __months_ = "string_type[24]";
    static constexpr auto __am_pm_ = "string_type[2]";
    static constexpr auto __c_ = "string_type";
    static constexpr auto __r_ = "string_type";
    static constexpr auto __x_ = "string_type";
    static constexpr auto __X_ = "string_type";
};
struct time_get_byname_Reflection {
};
struct __time_put_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct time_put_Reflection {
};
struct time_put_byname_Reflection {
};
struct money_base_Reflection {
};
struct pattern_Reflection {
    static constexpr auto field = "char[4]";
};
struct moneypunct_Reflection {
};
struct moneypunct_byname_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __curr_symbol_ = "string_type";
    static constexpr auto __positive_sign_ = "string_type";
    static constexpr auto __negative_sign_ = "string_type";
    static constexpr auto __frac_digits_ = "int";
    static constexpr auto __pos_format_ = "pattern";
    static constexpr auto __neg_format_ = "pattern";
};
struct __money_get_Reflection {
};
struct money_get_Reflection {
};
struct __money_put_Reflection {
};
struct money_put_Reflection {
};
struct messages_base_Reflection {
};
struct messages_Reflection {
};
struct messages_byname_Reflection {
};
struct wstring_convert_Reflection {
    static constexpr auto __byte_err_string_ = "byte_string";
    static constexpr auto __wide_err_string_ = "wide_string";
    static constexpr auto __cvtptr_ = "_Codecvt *";
    static constexpr auto __cvtstate_ = "state_type";
    static constexpr auto __cvtcount_ = "size_t";
};
struct wbuffer_convert_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __bufptr_ = "int *";
    static constexpr auto __cv_ = "_Codecvt *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ostream_Reflection {
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
    static constexpr auto __os_ = "basic_ostream<_CharT, _Traits> &";
};
struct __is_ostreamable_Reflection {
};
struct __is_ostreamable_Reflection {
};
struct basic_istream_Reflection {
    static constexpr auto __gc_ = "streamsize";
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
};
struct __is_istreamable_Reflection {
};
struct __is_istreamable_Reflection {
};
struct basic_iostream_Reflection {
};
struct array_Reflection {
    static constexpr auto __elems_ = "_Tp[_Size]";
};
struct array_Reflection {
    static constexpr auto __elems_ = "int[sizeof(_ArrayInStructT)]";
};
struct _ArrayInStructT_Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct __temp_value_Reflection {
    static constexpr auto  = "union std::__temp_value::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\temp_value.h:31:3)";
    static constexpr auto __a = "_Alloc &";
};
struct _Reflection {
    static constexpr auto __v = "_Tp";
};
struct __split_buffer_Reflection {
    static constexpr auto __first_ = "int";
    static constexpr auto __begin_ = "int";
    static constexpr auto __end_ = "int";
    static constexpr auto __end_cap_ = "int";
    static constexpr auto __alloc_ = "allocator_type";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "const int";
    static constexpr auto __dest_ = "int *";
};
struct __container_traits_Reflection {
};
struct __deque_block_size_Reflection {
};
struct __deque_iterator_Reflection {
    static constexpr auto __m_iter_ = "__map_iterator";
    static constexpr auto __ptr_ = "pointer";
};
struct deque_Reflection {
    static constexpr auto __map_ = "int";
    static constexpr auto __start_ = "size_type";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __deque_block_range_Reflection {
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __end_ = "const pointer";
};
struct __deque_range_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "int";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __end_ = "const pointer";
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __base_ = "deque<_Tp, _Allocator> *const";
};
struct __container_traits_Reflection {
};
struct binary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct is_bind_expression_Reflection {
};
struct is_placeholder_Reflection {
};
struct __ph_Reflection {
};
struct is_placeholder_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_Reflection {
    static constexpr auto __f_ = "int";
    static constexpr auto __bound_args_ = "_Td";
};
struct is_bind_expression_Reflection {
};
struct __bind_r_Reflection {
};
struct is_bind_expression_Reflection {
};
struct __mem_fn_Reflection {
    static constexpr auto __f_ = "type";
};
struct unary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct __builtin_new_allocator_Reflection {
};
struct __builtin_new_deleter_Reflection {
    static constexpr auto __size_ = "size_t";
    static constexpr auto __align_ = "size_t";
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct bad_function_call_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __alloc_func_Reflection {
    static constexpr auto __func_ = "_Fp";
    static constexpr auto __alloc_ = "_Ap";
};
struct __default_alloc_func_Reflection {
    static constexpr auto __f_ = "_Fp";
};
struct __base_Reflection {
};
struct __func_Reflection {
    static constexpr auto __f_ = "__alloc_func<_Fp, _Alloc, _Rp (_ArgTypes...)>";
};
struct __value_func_Reflection {
    static constexpr auto __buf_ = "int";
    static constexpr auto __f_ = "__func *";
};
struct __policy_storage_Reflection {
    static constexpr auto __small = "char[16]";
    static constexpr auto __large = "void *";
};
struct __use_small_storage_Reflection {
};
struct __policy_Reflection {
    static constexpr auto __clone = "void *(*const)(const void *)";
    static constexpr auto __destroy = "void (*const)(void *)";
    static constexpr auto __is_null = "const _Bool";
    static constexpr auto __type_info = "const int *const";
};
struct __policy_invoker_Reflection {
    static constexpr auto __call_ = "__Call";
};
struct __policy_func_Reflection {
    static constexpr auto __buf_ = "__policy_storage";
    static constexpr auto __invoker_ = "__invoker";
    static constexpr auto __policy_ = "const __policy *";
};
struct function_Reflection {
    static constexpr auto __f_ = "__func";
};
struct __callable_Reflection {
};
struct __extract_key_fail_tag_Reflection {
};
struct __extract_key_self_tag_Reflection {
};
struct __extract_key_first_tag_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __hash_node_base_Reflection {
    static constexpr auto __next_ = "__next_pointer";
};
struct __hash_node_Reflection {
    static constexpr auto __hash_ = "size_t";
    static constexpr auto  = "union std::__hash_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__hash_table:124:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __hash_key_value_types_Reflection {
};
struct __hash_key_value_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_node_types_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __make_hash_node_types_Reflection {
};
struct __hash_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_const_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __hash_const_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __bucket_list_deallocator_Reflection {
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __hash_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __enforce_unordered_container_requirements_Reflection {
};
struct __hash_table_Reflection {
    static constexpr auto __bucket_list_ = "__bucket_list";
    static constexpr auto __first_node_ = "__first_node";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __hasher_ = "hasher";
    static constexpr auto __max_load_factor_ = "float";
    static constexpr auto __key_eq_ = "key_equal";
};
struct __basic_node_handle_Reflection {
    static constexpr auto __ptr_ = "__node_pointer_type";
    static constexpr auto __alloc_ = "optional<allocator_type>";
};
struct __set_node_handle_specifics_Reflection {
};
struct __map_node_handle_specifics_Reflection {
};
struct __insert_return_type_Reflection {
    static constexpr auto position = "_Iterator";
    static constexpr auto inserted = "_Bool";
    static constexpr auto node = "_NodeType";
};
struct __unordered_map_hasher_Reflection {
};
struct __unordered_map_hasher_Reflection {
    static constexpr auto __hash_ = "_Hash";
};
struct __unordered_map_equal_Reflection {
};
struct __unordered_map_equal_Reflection {
    static constexpr auto __pred_ = "_Pred";
};
struct __hash_map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __hash_value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __hash_map_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct __hash_map_const_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct unordered_map_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multimap_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct to_chars_result_Reflection {
    static constexpr auto ptr = "char *";
    static constexpr auto ec = "errc";
};
struct __traits_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "pointer";
    static constexpr auto __end_ = "pointer";
    static constexpr auto __cap_ = "pointer";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Tp, _Alloc> &";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __v_ = "vector<_Tp, _Alloc> &";
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __new_end_ = "const const_pointer";
};
struct __has_storage_type_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "__storage_pointer";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __cap_ = "size_type";
    static constexpr auto __alloc_ = "__storage_allocator";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Bool, type-parameter-0-0> &";
};
struct hash_Reflection {
};
struct __container_traits_Reflection {
};
struct _BMSkipTable_Reflection {
    static constexpr auto __default_value_ = "const value_type";
    static constexpr auto __table_ = "int";
};
struct _BMSkipTable_Reflection {
    static constexpr auto __table_ = "std::array<value_type, 256>";
};
struct boyer_moore_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
    static constexpr auto __suffix_ = "shared_ptr<difference_type[]>";
};
struct boyer_moore_horspool_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
};
struct default_searcher_Reflection {
    static constexpr auto __first_ = "_ForwardIterator";
    static constexpr auto __last_ = "_ForwardIterator";
    static constexpr auto __pred_ = "_BinaryPredicate";
};
struct __not_fn_op_Reflection {
};
struct __not_fn_t_Reflection {
};
struct queue_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct priority_queue_Reflection {
    static constexpr auto c = "container_type";
    static constexpr auto comp = "value_compare";
};
struct uses_allocator_Reflection {
};
struct stack_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct _FilesystemClock_Reflection {
};
struct __forward_list_node_value_type_Reflection {
};
struct __forward_node_traits_Reflection {
};
struct __forward_begin_node_Reflection {
    static constexpr auto __next_ = "pointer";
};
struct __forward_list_node_Reflection {
    static constexpr auto  = "union std::__forward_list_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\forward_list:328:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __forward_list_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_base_Reflection {
    static constexpr auto __before_begin_ = "__begin_node";
    static constexpr auto __alloc_ = "__node_allocator";
};
struct forward_list_Reflection {
};
struct __container_traits_Reflection {
};
struct basic_stringbuf_Reflection {
    static constexpr auto __str_ = "string_type";
    static constexpr auto __hm_ = "char_type *";
    static constexpr auto __mode_ = "class ios_base::openmode";
};
struct basic_istringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_ostringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_stringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct unordered_set_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multiset_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct null_mutex_Reflection {
};
struct null_atomic_int_Reflection {
    static constexpr auto value = "int";
};
struct type_identity_Reflection {
};
struct is_contiguous_Reflection {
};
struct monostate_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto data_ = "const Char *";
    static constexpr auto size_ = "size_t";
};
struct is_char_Reflection {
};
struct is_char_Reflection {
};
struct compile_string_Reflection {
};
struct is_compile_string_Reflection {
};
struct is_string_Reflection {
};
struct char_t_impl_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct error_handler_Reflection {
};
struct basic_format_parse_context_Reflection {
    static constexpr auto format_str_ = "basic_string_view<Char>";
    static constexpr auto next_arg_id_ = "int";
};
struct compile_parse_context_Reflection {
    static constexpr auto num_args_ = "int";
    static constexpr auto types_ = "const type *";
};
struct buffer_Reflection {
    static constexpr auto ptr_ = "T *";
    static constexpr auto size_ = "size_t";
    static constexpr auto capacity_ = "size_t";
};
struct buffer_traits_Reflection {
};
struct fixed_buffer_traits_Reflection {
    static constexpr auto count_ = "size_t";
    static constexpr auto limit_ = "size_t";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto data_ = "T[buffer_size]";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "T *";
    static constexpr auto data_ = "T[buffer_size]";
};
struct counting_buffer_Reflection {
    static constexpr auto data_ = "T[buffer_size]";
    static constexpr auto count_ = "size_t";
};
struct formatter_Reflection {
};
struct appender_Reflection {
};
struct view_Reflection {
};
struct named_arg_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto value = "const T &";
};
struct named_arg_info_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto id = "int";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)]";
    static constexpr auto named_args_ = "named_arg_info<Char>[NUM_NAMED_ARGS]";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[NUM_ARGS != 0 ? NUM_ARGS : +1]";
};
struct is_named_arg_Reflection {
};
struct is_statically_named_arg_Reflection {
};
struct is_named_arg_Reflection {
};
struct unformattable_Reflection {
};
struct unformattable_char_Reflection {
};
struct unformattable_pointer_Reflection {
};
struct string_value_Reflection {
    static constexpr auto data = "const Char *";
    static constexpr auto size = "size_t";
};
struct named_arg_value_Reflection {
    static constexpr auto data = "const named_arg_info<Char> *";
    static constexpr auto size = "size_t";
};
struct custom_value_Reflection {
    static constexpr auto value = "void *";
    static constexpr auto format = "void (*)(void *, parse_context &, Context &)";
};
struct value_Reflection {
    static constexpr auto  = "union fmt::detail::value::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1261:3)";
};
struct _Reflection {
    static constexpr auto no_value = "monostate";
    static constexpr auto int_value = "int";
    static constexpr auto uint_value = "unsigned int";
    static constexpr auto long_long_value = "long long";
    static constexpr auto ulong_long_value = "unsigned long long";
    static constexpr auto int128_value = "int128_opt";
    static constexpr auto uint128_value = "uint128_opt";
    static constexpr auto bool_value = "_Bool";
    static constexpr auto char_value = "char_type";
    static constexpr auto float_value = "float";
    static constexpr auto double_value = "double";
    static constexpr auto long_double_value = "long double";
    static constexpr auto pointer = "const void *";
    static constexpr auto string = "string_value<char_type>";
    static constexpr auto custom = "custom_value<Context>";
    static constexpr auto named_args = "named_arg_value<char_type>";
};
struct format_as_result_Reflection {
};
struct has_format_as_Reflection {
};
struct arg_mapper_Reflection {
};
struct formattable_Reflection {
};
struct is_output_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct locale_ref_Reflection {
    static constexpr auto locale_ = "const void *";
};
struct basic_format_arg_Reflection {
    static constexpr auto value_ = "detail::value<Context>";
    static constexpr auto type_ = "detail::type";
};
struct handle_Reflection {
    static constexpr auto custom_ = "detail::custom_value<Context>";
};
struct basic_format_context_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto args_ = "basic_format_args<basic_format_context<OutputIt, Char> >";
    static constexpr auto loc_ = "detail::locale_ref";
};
struct format_arg_store_Reflection {
    static constexpr auto data_ = "int";
};
struct basic_format_args_Reflection {
    static constexpr auto desc_ = "unsigned long long";
    static constexpr auto  = "union fmt::basic_format_args::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1902:3)";
};
struct _Reflection {
    static constexpr auto values_ = "const detail::value<Context> *";
    static constexpr auto args_ = "const format_arg *";
};
struct fill_t_Reflection {
    static constexpr auto data_ = "Char[max_size]";
    static constexpr auto size_ = "unsigned char";
};
struct format_specs_Reflection {
    static constexpr auto width = "int";
    static constexpr auto precision = "int";
    static constexpr auto type = "presentation_type";
    static constexpr auto align = "align_t";
    static constexpr auto sign = "sign_t";
    static constexpr auto alt = "_Bool";
    static constexpr auto localized = "_Bool";
    static constexpr auto fill = "detail::fill_t<Char>";
};
struct arg_ref_Reflection {
    static constexpr auto kind = "arg_id_kind";
    static constexpr auto val = "union value";
};
struct value_Reflection {
    static constexpr auto index = "int";
    static constexpr auto name = "basic_string_view<Char>";
};
struct dynamic_format_specs_Reflection {
    static constexpr auto width_ref = "arg_ref<Char>";
    static constexpr auto precision_ref = "arg_ref<Char>";
};
struct dynamic_spec_id_handler_Reflection {
    static constexpr auto ctx = "basic_format_parse_context<Char> &";
    static constexpr auto ref = "arg_ref<Char> &";
};
struct _Reflection {
    static constexpr auto current_state = "state";
};
struct _Reflection {
    static constexpr auto begin = "const Char *&";
    static constexpr auto specs = "dynamic_format_specs<Char> &";
    static constexpr auto arg_type = "type";
};
struct id_adapter_Reflection {
    static constexpr auto handler = "Handler &";
    static constexpr auto arg_id = "int";
};
struct writer_Reflection {
    static constexpr auto handler_ = "Handler &";
};
struct strip_named_arg_Reflection {
};
struct strip_named_arg_Reflection {
};
struct format_string_checker_Reflection {
    static constexpr auto types_ = "type[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
    static constexpr auto context_ = "parse_context_type";
    static constexpr auto parse_funcs_ = "parse_func[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
};
struct vformat_args_Reflection {
};
struct vformat_args_Reflection {
};
struct runtime_format_string_Reflection {
    static constexpr auto str = "basic_string_view<Char>";
};
struct basic_format_string_Reflection {
    static constexpr auto str_ = "basic_string_view<Char>";
};
struct format_to_n_result_Reflection {
    static constexpr auto out = "OutputIt";
    static constexpr auto size = "size_t";
};
struct __uintr_frame_Reflection {
    static constexpr auto rip = "unsigned long long";
    static constexpr auto rflags = "unsigned long long";
    static constexpr auto rsp = "unsigned long long";
};
struct __mm_loadh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadh_pi_v2f32";
};
struct __mm_loadl_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadl_pi_v2f32";
};
struct __mm_load_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __mm_load1_ps_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_store_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_load1_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __loadu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __loadu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __loadu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_load_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadl_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_store_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __mm_loadl_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __storeu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __storeu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __storeu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_storel_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __mm_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __mm256_broadcast_sd_struct_Reflection {
    static constexpr auto __d = "double";
};
struct __mm256_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __loadu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __storeu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __mm_load_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __mm_store_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __loadu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __storeu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __loadu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __storeu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __loadu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __storeu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __tile1024i_str_Reflection {
    static constexpr auto row = "const unsigned short";
    static constexpr auto col = "const unsigned short";
    static constexpr auto tile = "_tile1024i";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __mm_store_sbh_struct_Reflection {
    static constexpr auto __u = "__bf16";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct string_literal_Reflection {
};
struct uint128_fallback_Reflection {
    static constexpr auto lo_ = "int";
    static constexpr auto hi_ = "int";
};
struct _Reflection {
    static constexpr auto  = "F";
};
struct count_code_points_Reflection {
    static constexpr auto count = "size_t *";
};
struct _Reflection {
    static constexpr auto  = "const char *";
    static constexpr auto  = "size_t &";
    static constexpr auto  = "size_t &";
};
struct is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_locale_Reflection {
};
struct basic_memory_buffer_Reflection {
    static constexpr auto store_ = "T[SIZE]";
    static constexpr auto alloc_ = "Allocator";
};
struct is_contiguous_Reflection {
};
struct format_error_Reflection {
};
struct loc_value_Reflection {
    static constexpr auto value_ = "int";
};
struct format_facet_Reflection {
    static constexpr auto separator_ = "int";
    static constexpr auto grouping_ = "int";
    static constexpr auto decimal_point_ = "int";
};
struct _Reflection {
};
struct thousands_sep_result_Reflection {
    static constexpr auto grouping = "int";
    static constexpr auto thousands_sep = "Char";
};
struct format_decimal_result_Reflection {
    static constexpr auto begin = "Iterator";
    static constexpr auto end = "Iterator";
};
struct utf8_to_utf16_Reflection {
    static constexpr auto buffer_ = "int";
};
struct to_utf8_Reflection {
    static constexpr auto buffer_ = "Buffer";
};
struct decimal_fp_Reflection {
    static constexpr auto significand = "int";
    static constexpr auto exponent = "int";
};
struct basic_fp_Reflection {
    static constexpr auto f = "F";
    static constexpr auto e = "int";
};
struct _Reflection {
};
struct find_escape_result_Reflection {
    static constexpr auto begin = "const Char *";
    static constexpr auto end = "const Char *";
    static constexpr auto cp = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct write_int_data_Reflection {
    static constexpr auto size = "size_t";
    static constexpr auto padding = "size_t";
};
struct _Reflection {
};
struct digit_grouping_Reflection {
    static constexpr auto grouping_ = "int";
    static constexpr auto thousands_sep_ = "int";
};
struct next_state_Reflection {
    static constexpr auto group = "int";
    static constexpr auto pos = "int";
};
struct write_int_arg_Reflection {
    static constexpr auto abs_value = "UInt";
    static constexpr auto prefix = "unsigned int";
};
struct loc_writer_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto sep = "int";
    static constexpr auto grouping = "int";
    static constexpr auto decimal_point = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct counting_iterator_Reflection {
    static constexpr auto count_ = "size_t";
};
struct value_type_Reflection {
};
struct _Reflection {
};
struct float_specs_Reflection {
    static constexpr auto precision = "int";
    static constexpr auto format = "float_format";
    static constexpr auto sign = "sign_t";
    static constexpr auto upper = "_Bool";
    static constexpr auto locale = "_Bool";
    static constexpr auto binary32 = "_Bool";
    static constexpr auto showpoint = "_Bool";
};
struct big_decimal_fp_Reflection {
    static constexpr auto significand = "const char *";
    static constexpr auto significand_size = "int";
    static constexpr auto exponent = "int";
};
struct fallback_digit_grouping_Reflection {
};
struct has_isfinite_Reflection {
};
struct bigint_Reflection {
    static constexpr auto bigits_ = "int";
    static constexpr auto exp_ = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct default_arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto args = "int";
    static constexpr auto loc = "locale_ref";
};
struct arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto locale = "locale_ref";
};
struct width_checker_Reflection {
};
struct precision_checker_Reflection {
};
struct udl_arg_Reflection {
    static constexpr auto str = "const Char *";
};
struct format_int_Reflection {
    static constexpr auto buffer_ = "char[0]";
    static constexpr auto str_ = "char *";
};
struct bytes_Reflection {
    static constexpr auto data_ = "string_view";
};
struct group_digits_view_Reflection {
    static constexpr auto value = "T";
};
struct nested_view_Reflection {
    static constexpr auto fmt = "const int *";
    static constexpr auto value = "const T *";
};
struct nested_formatter_Reflection {
    static constexpr auto width_ = "int";
    static constexpr auto fill_ = "detail::fill_t<char>";
    static constexpr auto align_ = "align_t";
    static constexpr auto formatter_ = "int";
};
struct join_view_Reflection {
    static constexpr auto begin = "It";
    static constexpr auto end = "Sentinel";
    static constexpr auto sep = "basic_string_view<Char>";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
    static constexpr auto divisor = "int";
    static constexpr auto shift_amount = "int";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct _Reflection {
    static constexpr auto  = "class fmt::detail::utf8_to_utf16 *";
};
struct singleton_Reflection {
    static constexpr auto upper = "unsigned char";
    static constexpr auto lower_count = "unsigned char";
};
struct is_convertible_to_basic_format_string_Reflection {
};
struct is_convertible_to_any_format_string_Reflection {
};
struct spdlog_ex_Reflection {
    static constexpr auto msg_ = "int";
};
struct source_loc_Reflection {
    static constexpr auto filename = "const char *";
    static constexpr auto line = "int";
    static constexpr auto funcname = "const char *";
};
struct file_event_handlers_Reflection {
    static constexpr auto before_open = "std::function<void (const int &)>";
    static constexpr auto after_open = "std::function<void (const int &, int *)>";
    static constexpr auto before_close = "std::function<void (const int &, int *)>";
    static constexpr auto after_close = "std::function<void (const int &)>";
};
struct condition_variable_any_Reflection {
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __mut_ = "shared_ptr<mutex>";
};
struct __unlock_guard_Reflection {
    static constexpr auto __lock_ = "_Lock &";
};
struct __thread_struct_Reflection {
    static constexpr auto __p_ = "__thread_struct_imp *";
};
struct __thread_specific_ptr_Reflection {
    static constexpr auto __key_ = "__libcpp_tls_key";
};
struct hash_Reflection {
};
struct thread_Reflection {
    static constexpr auto __t_ = "__libcpp_thread_t";
};
struct periodic_worker_Reflection {
    static constexpr auto active_ = "_Bool";
    static constexpr auto worker_thread_ = "std::thread";
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto cv_ = "std::condition_variable";
};
struct registry_Reflection {
    static constexpr auto logger_map_mutex_ = "std::mutex";
    static constexpr auto flusher_mutex_ = "std::mutex";
    static constexpr auto tp_mutex_ = "std::recursive_mutex";
    static constexpr auto log_levels_ = "int";
    static constexpr auto formatter_ = "int";
    static constexpr auto global_log_level_ = "spdlog::level::level_enum";
    static constexpr auto flush_level_ = "level::level_enum";
    static constexpr auto err_handler_ = "err_handler";
    static constexpr auto tp_ = "std::shared_ptr<thread_pool>";
    static constexpr auto periodic_flusher_ = "int";
    static constexpr auto default_logger_ = "std::shared_ptr<logger>";
    static constexpr auto automatic_registration_ = "_Bool";
    static constexpr auto backtrace_n_messages_ = "size_t";
};
struct circular_q_Reflection {
    static constexpr auto max_items_ = "size_t";
    static constexpr auto head_ = "int";
    static constexpr auto tail_ = "int";
    static constexpr auto overrun_counter_ = "size_t";
    static constexpr auto v_ = "int";
};
struct log_msg_Reflection {
    static constexpr auto logger_name = "string_view_t";
    static constexpr auto level = "level::level_enum";
    static constexpr auto time = "log_clock::time_point";
    static constexpr auto thread_id = "size_t";
    static constexpr auto color_range_start = "size_t";
    static constexpr auto color_range_end = "size_t";
    static constexpr auto source = "source_loc";
    static constexpr auto payload = "string_view_t";
};
struct log_msg_buffer_Reflection {
    static constexpr auto buffer = "int";
};
struct backtracer_Reflection {
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto enabled_ = "std::atomic<_Bool>";
    static constexpr auto messages_ = "circular_q<log_msg_buffer>";
};
struct logger_Reflection {
    static constexpr auto name_ = "int";
    static constexpr auto sinks_ = "int";
    static constexpr auto level_ = "spdlog::level_t";
    static constexpr auto flush_level_ = "spdlog::level_t";
    static constexpr auto custom_err_handler_ = "err_handler";
    static constexpr auto tracer_ = "details::backtracer";
};
struct formatter_Reflection {
};
struct padding_info_Reflection {
    static constexpr auto width_ = "size_t";
    static constexpr auto side_ = "pad_side";
    static constexpr auto truncate_ = "_Bool";
    static constexpr auto enabled_ = "_Bool";
};
struct flag_formatter_Reflection {
    static constexpr auto padinfo_ = "padding_info";
};
struct custom_flag_formatter_Reflection {
};
struct pattern_formatter_Reflection {
    static constexpr auto pattern_ = "int";
    static constexpr auto eol_ = "int";
    static constexpr auto pattern_time_type_ = "pattern_time_type";
    static constexpr auto need_localtime_ = "_Bool";
    static constexpr auto cached_tm_ = "int";
    static constexpr auto last_log_secs_ = "std::chrono::seconds";
    static constexpr auto formatters_ = "int";
    static constexpr auto custom_handlers_ = "int";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_node_base_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_node_types_Reflection {
};
struct __make_tree_node_types_Reflection {
};
struct __tree_end_node_Reflection {
    static constexpr auto __left_ = "pointer";
};
struct __tree_node_base_Reflection {
    static constexpr auto __right_ = "pointer";
    static constexpr auto __parent_ = "__parent_pointer";
    static constexpr auto __is_black_ = "_Bool";
};
struct __tree_node_Reflection {
    static constexpr auto __value_ = "__node_value_type";
};
struct __tree_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __tree_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_Reflection {
    static constexpr auto __begin_node_ = "__iter_pointer";
    static constexpr auto __end_node_ = "__end_node_t";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __value_comp_ = "value_compare";
};
struct _DetachedTreeCache_Reflection {
    static constexpr auto __t_ = "__tree<_Tp, _Compare, _Allocator> *";
    static constexpr auto __cache_root_ = "__node_pointer";
    static constexpr auto __cache_elem_ = "__node_pointer";
};
struct __map_value_compare_Reflection {
};
struct __map_value_compare_Reflection {
    static constexpr auto __comp_ = "_Compare";
};
struct __map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __extract_key_value_types_Reflection {
};
struct __map_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct __map_const_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct map_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct multimap_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct mdc_Reflection {
};
struct scoped_padder_Reflection {
    static constexpr auto padinfo_ = "const padding_info &";
    static constexpr auto dest_ = "int &";
    static constexpr auto remaining_pad_ = "long";
    static constexpr auto spaces_ = "string_view_t";
};
struct null_scoped_padder_Reflection {
};
struct name_formatter_Reflection {
};
struct level_formatter_Reflection {
};
struct short_level_formatter_Reflection {
};
struct a_formatter_Reflection {
};
struct A_formatter_Reflection {
};
struct b_formatter_Reflection {
};
struct B_formatter_Reflection {
};
struct c_formatter_Reflection {
};
struct C_formatter_Reflection {
};
struct D_formatter_Reflection {
};
struct Y_formatter_Reflection {
};
struct m_formatter_Reflection {
};
struct d_formatter_Reflection {
};
struct H_formatter_Reflection {
};
struct I_formatter_Reflection {
};
struct M_formatter_Reflection {
};
struct S_formatter_Reflection {
};
struct e_formatter_Reflection {
};
struct f_formatter_Reflection {
};
struct F_formatter_Reflection {
};
struct E_formatter_Reflection {
};
struct p_formatter_Reflection {
};
struct r_formatter_Reflection {
};
struct R_formatter_Reflection {
};
struct T_formatter_Reflection {
};
struct z_formatter_Reflection {
    static constexpr auto last_update_ = "log_clock::time_point";
    static constexpr auto offset_minutes_ = "int";
};
struct t_formatter_Reflection {
};
struct pid_formatter_Reflection {
};
struct v_formatter_Reflection {
};
struct ch_formatter_Reflection {
    static constexpr auto ch_ = "char";
};
struct aggregate_formatter_Reflection {
    static constexpr auto str_ = "int";
};
struct color_start_formatter_Reflection {
};
struct color_stop_formatter_Reflection {
};
struct source_location_formatter_Reflection {
};
struct source_filename_formatter_Reflection {
};
struct short_filename_formatter_Reflection {
};
struct source_linenum_formatter_Reflection {
};
struct source_funcname_formatter_Reflection {
};
struct elapsed_formatter_Reflection {
    static constexpr auto last_message_time_ = "log_clock::time_point";
};
struct mdc_formatter_Reflection {
};
struct full_formatter_Reflection {
    static constexpr auto cache_timestamp_ = "std::chrono::seconds";
    static constexpr auto cached_datetime_ = "int";
    static constexpr auto mdc_formatter_ = "mdc_formatter<null_scoped_padder>";
};
struct sink_Reflection {
    static constexpr auto level_ = "level_t";
};
struct console_mutex_Reflection {
};
struct console_nullmutex_Reflection {
};
struct wincolor_sink_Reflection {
    static constexpr auto out_handle_ = "void *";
    static constexpr auto mutex_ = "mutex_t &";
    static constexpr auto should_do_colors_ = "_Bool";
    static constexpr auto formatter_ = "int";
    static constexpr auto colors_ = "std::array<int, level::n_levels>";
};
struct wincolor_stdout_sink_Reflection {
};
struct wincolor_stderr_sink_Reflection {
};
struct synchronous_factory_Reflection {
};
struct file_helper_Reflection {
    static constexpr auto open_tries_ = "const int";
    static constexpr auto open_interval_ = "const unsigned int";
    static constexpr auto fd_ = "int *";
    static constexpr auto filename_ = "int";
    static constexpr auto event_handlers_ = "file_event_handlers";
};
struct base_sink_Reflection {
    static constexpr auto formatter_ = "int";
    static constexpr auto mutex_ = "Mutex";
};
struct basic_file_sink_Reflection {
    static constexpr auto file_helper_ = "details::file_helper";
};
struct __iom_t1_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t2_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t3_Reflection {
    static constexpr auto __base_ = "int";
};
struct __iom_t4_Reflection {
    static constexpr auto __fill_ = "_CharT";
};
struct __iom_t5_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t6_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t7_Reflection {
    static constexpr auto __mon_ = "_MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t8_Reflection {
    static constexpr auto __mon_ = "const _MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t9_Reflection {
    static constexpr auto __tm_ = "int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __iom_t10_Reflection {
    static constexpr auto __tm_ = "const int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __quoted_output_proxy_Reflection {
    static constexpr auto __first_ = "const _CharT *";
    static constexpr auto __last_ = "const _CharT *";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __quoted_proxy_Reflection {
    static constexpr auto __string_ = "basic_string<_CharT, _Traits, _Allocator> &";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct _NullSentinel_Reflection {
};
struct __is_pathable_string_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_iter_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct path_Reflection {
    static constexpr auto __pn_ = "string_type";
};
struct basic_filebuf_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __file_ = "int *";
    static constexpr auto __cv_ = "const codecvt<char_type, char, state_type> *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __st_last_ = "state_type";
    static constexpr auto __om_ = "class ios_base::openmode";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ifstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_ofstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_fstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct file_status_Reflection {
    static constexpr auto __ft_ = "file_type";
    static constexpr auto __prms_ = "perms";
};
struct space_info_Reflection {
    static constexpr auto capacity = "int";
    static constexpr auto free = "int";
    static constexpr auto available = "int";
};
struct directory_entry_Reflection {
    static constexpr auto __p_ = "_Path";
    static constexpr auto __data_ = "__cached_data";
};
struct __cached_data_Reflection {
    static constexpr auto __size_ = "int";
    static constexpr auto __nlink_ = "int";
    static constexpr auto __write_time_ = "file_time_type";
    static constexpr auto __sym_perms_ = "perms";
    static constexpr auto __non_sym_perms_ = "perms";
    static constexpr auto __type_ = "file_type";
    static constexpr auto __cache_type_ = "_CacheType";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct __dir_element_proxy_Reflection {
    static constexpr auto __elem_ = "directory_entry";
};
struct directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__dir_stream>";
};
struct iterator_Reflection {
    static constexpr auto __stashed_elem_ = "path";
    static constexpr auto __path_ptr_ = "const path *";
    static constexpr auto __entry_ = "class path::__string_view";
    static constexpr auto __state_ = "_ParserState";
};
struct recursive_directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__shared_imp>";
    static constexpr auto __rec_ = "_Bool";
};
struct formatbuf_Reflection {
    static constexpr auto buffer_ = "buffer<char_type> &";
};
struct file_access_tag_Reflection {
};
struct file_access_Reflection {
};
struct streamed_view_Reflection {
    static constexpr auto value = "const T &";
};
struct basic_ostream_formatter_Reflection {
};
struct Logger_Reflection {
};
struct Event_Reflection {
    static constexpr auto Handled = "_Bool";
};
struct EventDispatcher_Reflection {
    static constexpr auto m_Event = "Event &";
};
struct WindowProperties_Reflection {
    static constexpr auto Title = "int";
    static constexpr auto Width = "unsigned int";
    static constexpr auto Height = "unsigned int";
};
struct Window_Reflection {
};
struct WindowResizeEvent_Reflection {
    static constexpr auto m_Width = "unsigned int";
    static constexpr auto m_Height = "unsigned int";
};
struct WindowCloseEvent_Reflection {
};
struct AppTickEvent_Reflection {
};
struct AppUpdateEvent_Reflection {
};
struct AppRenderEvent_Reflection {
};
struct Layer_Reflection {
    static constexpr auto m_DebugName = "int";
};
struct LayerStack_Reflection {
    static constexpr auto m_Layers = "int";
    static constexpr auto m_LayerInsertIndex = "unsigned int";
};
struct MouseMovedEvent_Reflection {
    static constexpr auto m_MouseX = "float";
    static constexpr auto m_MouseY = "float";
};
struct MouseScrolledEvent_Reflection {
    static constexpr auto m_XOffset = "float";
    static constexpr auto m_YOffset = "float";
};
struct MouseButtonEvent_Reflection {
    static constexpr auto m_Button = "int";
};
struct MouseButtonPressedEvent_Reflection {
};
struct MouseButtonReleasedEvent_Reflection {
};
struct KeyEvent_Reflection {
    static constexpr auto m_KeyCode = "int";
};
struct KeyPressedEvent_Reflection {
    static constexpr auto m_RepeatCount = "int";
};
struct KeyReleasedEvent_Reflection {
};
struct KeyTypedEvent_Reflection {
};
struct ImGuiLayer_Reflection {
};
struct RenderLayer_Reflection {
    static constexpr auto m_SceneHovered = "_Bool";
    static constexpr auto m_SavedX = "double";
    static constexpr auto m_SavedY = "double";
    static constexpr auto m_CursorLocked = "_Bool";
};
struct Component_Reflection {
    static constexpr auto gameObject = "std::weak_ptr<GameObject>";
};
struct GameObject_Reflection {
    static constexpr auto enabled = "_Bool";
    static constexpr auto components = "int";
    static constexpr auto children = "int";
    static constexpr auto parent = "std::weak_ptr<GameObject>";
    static constexpr auto name = "int";
    static constexpr auto transform = "std::shared_ptr<Transform>";
    static constexpr auto scene = "std::weak_ptr<Scene>";
};
struct GameLogicLayer_Reflection {
    static constexpr auto deltaTime = "float";
    static constexpr auto lastTime = "std::chrono::high_resolution_clock::time_point";
};
struct Application_Reflection {
    static constexpr auto m_Running = "_Bool";
    static constexpr auto m_Window = "int";
    static constexpr auto m_ImGuiLayer = "ImGuiLayer *";
    static constexpr auto m_RenderLayer = "RenderLayer *";
    static constexpr auto m_GameLogicLayer = "GameLogicLayer *";
    static constexpr auto m_LayerStack = "LayerStack";
};
struct is_int_Reflection {
};
struct is_int_Reflection {
};
struct is_int_Reflection {
};
struct is_aligned_Reflection {
};
struct storage_Reflection {
};
struct type_Reflection {
    static constexpr auto data = "T[L]";
};
struct storage_Reflection {
};
struct type_Reflection {
    static constexpr auto data = "T[L]";
};
struct storage_Reflection {
};
struct type_Reflection {
    static constexpr auto data = "T[4]";
};
struct genTypeTrait_Reflection {
};
struct init_gentype_Reflection {
};
struct init_gentype_Reflection {
};
struct init_gentype_Reflection {
};
struct vec_Reflection {
    static constexpr auto  = "union glm::vec<2, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec2.hpp:72:4)";
    static constexpr auto  = "union glm::vec<2, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec2.hpp:73:4)";
};
struct _Reflection {
    static constexpr auto x = "T";
    static constexpr auto r = "T";
    static constexpr auto s = "T";
};
struct _Reflection {
    static constexpr auto y = "T";
    static constexpr auto g = "T";
    static constexpr auto t = "T";
};
struct compute_equal_Reflection {
};
struct vec_Reflection {
    static constexpr auto  = "union glm::vec<3, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec3.hpp:77:4)";
    static constexpr auto  = "union glm::vec<3, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec3.hpp:78:4)";
    static constexpr auto  = "union glm::vec<3, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec3.hpp:79:4)";
};
struct _Reflection {
    static constexpr auto x = "T";
    static constexpr auto r = "T";
    static constexpr auto s = "T";
};
struct _Reflection {
    static constexpr auto y = "T";
    static constexpr auto g = "T";
    static constexpr auto t = "T";
};
struct _Reflection {
    static constexpr auto z = "T";
    static constexpr auto b = "T";
    static constexpr auto p = "T";
};
struct functor1_Reflection {
};
struct functor2_Reflection {
};
struct functor2_vec_sca_Reflection {
};
struct functor2_vec_int_Reflection {
};
struct functor2_vec_int_Reflection {
};
struct functor2_vec_int_Reflection {
};
struct functor2_vec_int_Reflection {
};
struct functor2_vec_int_Reflection {
};
struct compute_vec_add_Reflection {
};
struct compute_vec_sub_Reflection {
};
struct compute_vec_mul_Reflection {
};
struct compute_vec_div_Reflection {
};
struct compute_vec_mod_Reflection {
};
struct compute_splat_Reflection {
};
struct compute_vec_and_Reflection {
};
struct compute_vec_or_Reflection {
};
struct compute_vec_xor_Reflection {
};
struct compute_vec_shift_left_Reflection {
};
struct compute_vec_shift_right_Reflection {
};
struct compute_vec_equal_Reflection {
};
struct compute_vec_nequal_Reflection {
};
struct compute_vec_bitwise_not_Reflection {
};
struct compute_vec_add_Reflection {
};
struct compute_vec_sub_Reflection {
};
struct compute_vec_mul_Reflection {
};
struct compute_vec_div_Reflection {
};
struct compute_vec_mod_Reflection {
};
struct compute_vec_and_Reflection {
};
struct compute_vec_or_Reflection {
};
struct compute_vec_xor_Reflection {
};
struct compute_vec_shift_left_Reflection {
};
struct compute_vec_shift_right_Reflection {
};
struct compute_vec_equal_Reflection {
};
struct compute_vec_nequal_Reflection {
};
struct compute_vec_bitwise_not_Reflection {
};
struct vec_Reflection {
    static constexpr auto  = "union glm::vec<4, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec4.hpp:73:4)";
    static constexpr auto  = "union glm::vec<4, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec4.hpp:74:4)";
    static constexpr auto  = "union glm::vec<4, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec4.hpp:75:4)";
    static constexpr auto  = "union glm::vec<4, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec4.hpp:76:4)";
};
struct _Reflection {
    static constexpr auto x = "T";
    static constexpr auto r = "T";
    static constexpr auto s = "T";
};
struct _Reflection {
    static constexpr auto y = "T";
    static constexpr auto g = "T";
    static constexpr auto t = "T";
};
struct _Reflection {
    static constexpr auto z = "T";
    static constexpr auto b = "T";
    static constexpr auto p = "T";
};
struct _Reflection {
    static constexpr auto w = "T";
    static constexpr auto a = "T";
    static constexpr auto q = "T";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[2]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[2]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[2]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[3]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[3]";
};
struct compute_abs_Reflection {
};
struct compute_abs_Reflection {
};
struct compute_abs_Reflection {
};
struct vec_Reflection {
    static constexpr auto  = "union glm::vec<1, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/.././ext/../detail/../detail/type_vec1.hpp:66:4)";
};
struct _Reflection {
    static constexpr auto x = "T";
    static constexpr auto r = "T";
    static constexpr auto s = "T";
};
struct TMin_Reflection {
};
struct TMax_Reflection {
};
struct TAbs_Reflection {
};
struct TRound_Reflection {
};
struct TTrunc_Reflection {
};
struct TFmod_Reflection {
};
struct compute_abs_vector_Reflection {
};
struct compute_mix_vector_Reflection {
};
struct compute_mix_vector_Reflection {
};
struct compute_mix_scalar_Reflection {
};
struct compute_mix_scalar_Reflection {
};
struct compute_mix_Reflection {
};
struct compute_mix_Reflection {
};
struct compute_sign_Reflection {
};
struct compute_sign_Reflection {
};
struct compute_floor_Reflection {
};
struct compute_ceil_Reflection {
};
struct compute_fract_Reflection {
};
struct compute_trunc_Reflection {
};
struct compute_round_Reflection {
};
struct compute_mod_Reflection {
};
struct compute_fma_Reflection {
};
struct compute_min_vector_Reflection {
};
struct compute_max_vector_Reflection {
};
struct compute_clamp_vector_Reflection {
};
struct compute_step_vector_Reflection {
};
struct compute_smoothstep_vector_Reflection {
};
struct convert_vec3_to_vec4W0_Reflection {
};
struct convert_vec3_to_vec4WZ_Reflection {
};
struct convert_vec3_to_vec4W1_Reflection {
};
struct convert_vec4_to_vec3_Reflection {
};
struct convert_splat_Reflection {
};
struct _Reflection {
    static constexpr auto in = "float";
    static constexpr auto out = "int";
};
struct _Reflection {
    static constexpr auto in = "float";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "int";
    static constexpr auto out = "float";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "float";
};
struct mul3x3_Reflection {
};
struct mul3x3_Reflection {
};
struct mat_Reflection {
    static constexpr auto value = "col_type[3]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[4]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[4]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[4]";
};
struct compute_log2_Reflection {
};
struct compute_sqrt_Reflection {
};
struct compute_inversesqrt_Reflection {
};
struct compute_inversesqrt_Reflection {
};
struct compute_length_Reflection {
};
struct compute_distance_Reflection {
};
struct compute_dot_Reflection {
};
struct compute_dot_Reflection {
};
struct compute_dot_Reflection {
};
struct compute_dot_Reflection {
};
struct compute_dot_Reflection {
};
struct compute_cross_Reflection {
};
struct compute_normalize_Reflection {
};
struct compute_faceforward_Reflection {
};
struct compute_reflect_Reflection {
};
struct compute_refract_Reflection {
};
struct mul4x4_Reflection {
};
struct mul4x4_Reflection {
};
struct mul4x4_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct compute_matrixCompMult_Reflection {
};
struct compute_matrixCompMult_type_Reflection {
};
struct compute_outerProduct_Reflection {
};
struct compute_outerProduct_type_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_type_Reflection {
};
struct compute_determinant_Reflection {
};
struct compute_determinant_Reflection {
};
struct compute_determinant_Reflection {
};
struct compute_determinant_Reflection {
};
struct compute_determinant_type_Reflection {
};
struct compute_inverse_Reflection {
};
struct compute_inverse_Reflection {
};
struct inv3x3_Reflection {
};
struct inv3x3_Reflection {
};
struct inv3x3_Reflection {
};
struct compute_inverse_Reflection {
};
struct compute_inverse_Reflection {
};
struct uif32_Reflection {
    static constexpr auto f = "float";
    static constexpr auto i = "unsigned int";
};
struct _Reflection {
    static constexpr auto in = "unsigned short[2]";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "unsigned short[2]";
};
struct _Reflection {
    static constexpr auto in = "short[2]";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "short[2]";
};
struct _Reflection {
    static constexpr auto in = "unsigned char[4]";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "unsigned char[4]";
};
struct _Reflection {
    static constexpr auto in = "signed char[4]";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "signed char[4]";
};
struct _Reflection {
    static constexpr auto in = "uint[2]";
    static constexpr auto out = "double";
};
struct _Reflection {
    static constexpr auto in = "double";
    static constexpr auto out = "uint[2]";
};
struct _Reflection {
    static constexpr auto in = "short[2]";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "short[2]";
};
struct compute_bitfieldReverseStep_Reflection {
};
struct compute_bitfieldReverseStep_Reflection {
};
struct compute_bitfieldBitCountStep_Reflection {
};
struct compute_bitfieldBitCountStep_Reflection {
};
struct compute_findLSB_Reflection {
};
struct compute_findMSB_step_vec_Reflection {
};
struct compute_findMSB_step_vec_Reflection {
};
struct compute_findMSB_vec_Reflection {
};
struct Input_Reflection {
};
struct WindowsInput_Reflection {
};
struct EditorCamera_Reflection {
    static constexpr auto Position = "glm::vec3";
    static constexpr auto Front = "glm::vec3";
    static constexpr auto Up = "glm::vec3";
    static constexpr auto Right = "glm::vec3";
    static constexpr auto WorldUp = "glm::vec3";
    static constexpr auto Yaw = "float";
    static constexpr auto Pitch = "float";
    static constexpr auto MovementSpeed = "float";
    static constexpr auto ShiftSpeed = "float";
    static constexpr auto Speed = "float";
    static constexpr auto MouseSensitivity = "float";
    static constexpr auto Zoom = "float";
};
struct Light_Reflection {
    static constexpr auto type = "LightType";
    static constexpr auto intensity = "float";
    static constexpr auto color = "glm::vec3";
    static constexpr auto innerCutOff = "float";
    static constexpr auto outerCutOff = "float";
};
struct LightManager_Reflection {
    static constexpr auto lights = "int";
    static constexpr auto maxLights = "int";
    static constexpr auto mainLight = "std::shared_ptr<Light>";
};
struct gladGLversionStruct_Reflection {
    static constexpr auto major = "int";
    static constexpr auto minor = "int";
};
struct Shader_Reflection {
    static constexpr auto ID = "unsigned int";
    static constexpr auto vertexPath = "int";
    static constexpr auto fragmentPath = "int";
    static constexpr auto geometryPath = "int";
    static constexpr auto fragmentID = "GLuint";
    static constexpr auto vertexID = "GLuint";
    static constexpr auto geometryID = "GLuint";
};
struct _Reflection {
    static constexpr auto read = "int (*)(void *, char *, int)";
    static constexpr auto skip = "void (*)(void *, int)";
    static constexpr auto eof = "int (*)(void *)";
};
struct aiVector3t_Reflection {
    static constexpr auto x = "TReal";
    static constexpr auto y = "TReal";
    static constexpr auto z = "TReal";
};
struct aiVector2t_Reflection {
    static constexpr auto x = "TReal";
    static constexpr auto y = "TReal";
};
struct aiColor4t_Reflection {
    static constexpr auto r = "TReal";
    static constexpr auto g = "TReal";
    static constexpr auto b = "TReal";
    static constexpr auto a = "TReal";
};
struct aiMatrix3x3t_Reflection {
    static constexpr auto a1 = "TReal";
    static constexpr auto a2 = "TReal";
    static constexpr auto a3 = "TReal";
    static constexpr auto b1 = "TReal";
    static constexpr auto b2 = "TReal";
    static constexpr auto b3 = "TReal";
    static constexpr auto c1 = "TReal";
    static constexpr auto c2 = "TReal";
    static constexpr auto c3 = "TReal";
};
struct aiMatrix4x4t_Reflection {
    static constexpr auto a1 = "TReal";
    static constexpr auto a2 = "TReal";
    static constexpr auto a3 = "TReal";
    static constexpr auto a4 = "TReal";
    static constexpr auto b1 = "TReal";
    static constexpr auto b2 = "TReal";
    static constexpr auto b3 = "TReal";
    static constexpr auto b4 = "TReal";
    static constexpr auto c1 = "TReal";
    static constexpr auto c2 = "TReal";
    static constexpr auto c3 = "TReal";
    static constexpr auto c4 = "TReal";
    static constexpr auto d1 = "TReal";
    static constexpr auto d2 = "TReal";
    static constexpr auto d3 = "TReal";
    static constexpr auto d4 = "TReal";
};
struct aiQuaterniont_Reflection {
    static constexpr auto w = "TReal";
    static constexpr auto x = "TReal";
    static constexpr auto y = "TReal";
    static constexpr auto z = "TReal";
};
struct AllocateFromAssimpHeap_Reflection {
};
struct aiPlane_Reflection {
    static constexpr auto a = "ai_real";
    static constexpr auto b = "ai_real";
    static constexpr auto c = "ai_real";
    static constexpr auto d = "ai_real";
};
struct aiRay_Reflection {
    static constexpr auto pos = "aiVector3D";
    static constexpr auto dir = "aiVector3D";
};
struct aiColor3D_Reflection {
    static constexpr auto r = "ai_real";
    static constexpr auto g = "ai_real";
    static constexpr auto b = "ai_real";
};
struct aiString_Reflection {
    static constexpr auto length = "size_t";
    static constexpr auto data = "char[1024]";
};
struct aiMemoryInfo_Reflection {
    static constexpr auto textures = "unsigned int";
    static constexpr auto materials = "unsigned int";
    static constexpr auto meshes = "unsigned int";
    static constexpr auto nodes = "unsigned int";
    static constexpr auto animations = "unsigned int";
    static constexpr auto cameras = "unsigned int";
    static constexpr auto lights = "unsigned int";
    static constexpr auto total = "unsigned int";
};
struct Importer_Reflection {
    static constexpr auto pimpl = "ImporterPimpl *";
};
struct aiTexel_Reflection {
    static constexpr auto b = "unsigned char";
    static constexpr auto g = "unsigned char";
    static constexpr auto r = "unsigned char";
    static constexpr auto a = "unsigned char";
};
struct aiTexture_Reflection {
    static constexpr auto mWidth = "unsigned int";
    static constexpr auto mHeight = "unsigned int";
    static constexpr auto achFormatHint = "char[9]";
    static constexpr auto pcData = "aiTexel *";
    static constexpr auto mFilename = "aiString";
};
struct aiFace_Reflection {
    static constexpr auto mNumIndices = "unsigned int";
    static constexpr auto mIndices = "unsigned int *";
};
struct aiVertexWeight_Reflection {
    static constexpr auto mVertexId = "unsigned int";
    static constexpr auto mWeight = "float";
};
struct aiBone_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mNumWeights = "unsigned int";
    static constexpr auto mWeights = "aiVertexWeight *";
    static constexpr auto mOffsetMatrix = "aiMatrix4x4";
};
struct aiAnimMesh_Reflection {
    static constexpr auto mVertices = "aiVector3D *";
    static constexpr auto mNormals = "aiVector3D *";
    static constexpr auto mTangents = "aiVector3D *";
    static constexpr auto mBitangents = "aiVector3D *";
    static constexpr auto mColors = "aiColor4D *[8]";
    static constexpr auto mTextureCoords = "aiVector3D *[8]";
    static constexpr auto mNumVertices = "unsigned int";
    static constexpr auto mWeight = "float";
};
struct aiMesh_Reflection {
    static constexpr auto mPrimitiveTypes = "unsigned int";
    static constexpr auto mNumVertices = "unsigned int";
    static constexpr auto mNumFaces = "unsigned int";
    static constexpr auto mVertices = "aiVector3D *";
    static constexpr auto mNormals = "aiVector3D *";
    static constexpr auto mTangents = "aiVector3D *";
    static constexpr auto mBitangents = "aiVector3D *";
    static constexpr auto mColors = "aiColor4D *[8]";
    static constexpr auto mTextureCoords = "aiVector3D *[8]";
    static constexpr auto mNumUVComponents = "unsigned int[8]";
    static constexpr auto mFaces = "aiFace *";
    static constexpr auto mNumBones = "unsigned int";
    static constexpr auto mBones = "aiBone **";
    static constexpr auto mMaterialIndex = "unsigned int";
    static constexpr auto mName = "aiString";
    static constexpr auto mNumAnimMeshes = "unsigned int";
    static constexpr auto mAnimMeshes = "aiAnimMesh **";
    static constexpr auto mMethod = "unsigned int";
};
struct aiLight_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mType = "aiLightSourceType";
    static constexpr auto mPosition = "aiVector3D";
    static constexpr auto mDirection = "aiVector3D";
    static constexpr auto mUp = "aiVector3D";
    static constexpr auto mAttenuationConstant = "float";
    static constexpr auto mAttenuationLinear = "float";
    static constexpr auto mAttenuationQuadratic = "float";
    static constexpr auto mColorDiffuse = "aiColor3D";
    static constexpr auto mColorSpecular = "aiColor3D";
    static constexpr auto mColorAmbient = "aiColor3D";
    static constexpr auto mAngleInnerCone = "float";
    static constexpr auto mAngleOuterCone = "float";
    static constexpr auto mSize = "aiVector2D";
};
struct aiCamera_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mPosition = "aiVector3D";
    static constexpr auto mUp = "aiVector3D";
    static constexpr auto mLookAt = "aiVector3D";
    static constexpr auto mHorizontalFOV = "float";
    static constexpr auto mClipPlaneNear = "float";
    static constexpr auto mClipPlaneFar = "float";
    static constexpr auto mAspect = "float";
};
struct aiUVTransform_Reflection {
    static constexpr auto mTranslation = "aiVector2D";
    static constexpr auto mScaling = "aiVector2D";
    static constexpr auto mRotation = "ai_real";
};
struct aiMaterialProperty_Reflection {
    static constexpr auto mKey = "aiString";
    static constexpr auto mSemantic = "unsigned int";
    static constexpr auto mIndex = "unsigned int";
    static constexpr auto mDataLength = "unsigned int";
    static constexpr auto mType = "aiPropertyTypeInfo";
    static constexpr auto mData = "char *";
};
struct aiMaterial_Reflection {
    static constexpr auto mProperties = "aiMaterialProperty **";
    static constexpr auto mNumProperties = "unsigned int";
    static constexpr auto mNumAllocated = "unsigned int";
};
struct aiVectorKey_Reflection {
    static constexpr auto mTime = "double";
    static constexpr auto mValue = "aiVector3D";
};
struct aiQuatKey_Reflection {
    static constexpr auto mTime = "double";
    static constexpr auto mValue = "aiQuaternion";
};
struct aiMeshKey_Reflection {
    static constexpr auto mTime = "double";
    static constexpr auto mValue = "unsigned int";
};
struct aiMeshMorphKey_Reflection {
    static constexpr auto mTime = "double";
    static constexpr auto mValues = "unsigned int *";
    static constexpr auto mWeights = "double *";
    static constexpr auto mNumValuesAndWeights = "unsigned int";
};
struct aiNodeAnim_Reflection {
    static constexpr auto mNodeName = "aiString";
    static constexpr auto mNumPositionKeys = "unsigned int";
    static constexpr auto mPositionKeys = "aiVectorKey *";
    static constexpr auto mNumRotationKeys = "unsigned int";
    static constexpr auto mRotationKeys = "aiQuatKey *";
    static constexpr auto mNumScalingKeys = "unsigned int";
    static constexpr auto mScalingKeys = "aiVectorKey *";
    static constexpr auto mPreState = "aiAnimBehaviour";
    static constexpr auto mPostState = "aiAnimBehaviour";
};
struct aiMeshAnim_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mNumKeys = "unsigned int";
    static constexpr auto mKeys = "aiMeshKey *";
};
struct aiMeshMorphAnim_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mNumKeys = "unsigned int";
    static constexpr auto mKeys = "aiMeshMorphKey *";
};
struct aiAnimation_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mDuration = "double";
    static constexpr auto mTicksPerSecond = "double";
    static constexpr auto mNumChannels = "unsigned int";
    static constexpr auto mChannels = "aiNodeAnim **";
    static constexpr auto mNumMeshChannels = "unsigned int";
    static constexpr auto mMeshChannels = "aiMeshAnim **";
    static constexpr auto mNumMorphMeshChannels = "unsigned int";
    static constexpr auto mMorphMeshChannels = "aiMeshMorphAnim **";
};
struct Interpolator_Reflection {
};
struct Interpolator_Reflection {
};
struct Interpolator_Reflection {
};
struct Interpolator_Reflection {
};
struct Interpolator_Reflection {
};
struct Interpolator_Reflection {
};
struct aiMetadataEntry_Reflection {
    static constexpr auto mType = "aiMetadataType";
    static constexpr auto mData = "void *";
};
struct aiMetadata_Reflection {
    static constexpr auto mNumProperties = "unsigned int";
    static constexpr auto mKeys = "aiString *";
    static constexpr auto mValues = "aiMetadataEntry *";
};
struct aiNode_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mTransformation = "aiMatrix4x4";
    static constexpr auto mParent = "aiNode *";
    static constexpr auto mNumChildren = "unsigned int";
    static constexpr auto mChildren = "aiNode **";
    static constexpr auto mNumMeshes = "unsigned int";
    static constexpr auto mMeshes = "unsigned int *";
    static constexpr auto mMetaData = "aiMetadata *";
};
struct aiScene_Reflection {
    static constexpr auto mFlags = "unsigned int";
    static constexpr auto mRootNode = "aiNode *";
    static constexpr auto mNumMeshes = "unsigned int";
    static constexpr auto mMeshes = "aiMesh **";
    static constexpr auto mNumMaterials = "unsigned int";
    static constexpr auto mMaterials = "aiMaterial **";
    static constexpr auto mNumAnimations = "unsigned int";
    static constexpr auto mAnimations = "aiAnimation **";
    static constexpr auto mNumTextures = "unsigned int";
    static constexpr auto mTextures = "aiTexture **";
    static constexpr auto mNumLights = "unsigned int";
    static constexpr auto mLights = "aiLight **";
    static constexpr auto mNumCameras = "unsigned int";
    static constexpr auto mCameras = "aiCamera **";
    static constexpr auto mMetaData = "aiMetadata *";
    static constexpr auto mPrivate = "void *";
};
struct GLFWvidmode_Reflection {
    static constexpr auto width = "int";
    static constexpr auto height = "int";
    static constexpr auto redBits = "int";
    static constexpr auto greenBits = "int";
    static constexpr auto blueBits = "int";
    static constexpr auto refreshRate = "int";
};
struct GLFWgammaramp_Reflection {
    static constexpr auto red = "unsigned short *";
    static constexpr auto green = "unsigned short *";
    static constexpr auto blue = "unsigned short *";
    static constexpr auto size = "unsigned int";
};
struct GLFWimage_Reflection {
    static constexpr auto width = "int";
    static constexpr auto height = "int";
    static constexpr auto pixels = "unsigned char *";
};
struct GLFWgamepadstate_Reflection {
    static constexpr auto buttons = "unsigned char[15]";
    static constexpr auto axes = "float[6]";
};
struct GLFWallocator_Reflection {
    static constexpr auto allocate = "GLFWallocatefun";
    static constexpr auto reallocate = "GLFWreallocatefun";
    static constexpr auto deallocate = "GLFWdeallocatefun";
    static constexpr auto user = "void *";
};
struct Texture_Reflection {
    static constexpr auto id = "unsigned int";
    static constexpr auto type = "int";
    static constexpr auto path = "int";
};
struct Material_Reflection {
    static constexpr auto AlbedoTexture = "std::shared_ptr<Texture>";
    static constexpr auto AlbedoColor = "glm::vec4";
    static constexpr auto MetallicTexture = "std::shared_ptr<Texture>";
    static constexpr auto Metallic = "float";
    static constexpr auto RoughnessTexture = "std::shared_ptr<Texture>";
    static constexpr auto Roughness = "float";
    static constexpr auto NormalTexture = "std::shared_ptr<Texture>";
    static constexpr auto shader = "std::shared_ptr<Shader>";
};
struct LightData_Reflection {
    static constexpr auto position = "glm::vec4";
    static constexpr auto direction = "glm::vec4";
    static constexpr auto lightColor = "glm::vec4";
    static constexpr auto projection = "glm::mat4";
    static constexpr auto view = "glm::mat4";
};
struct Vertex_Reflection {
    static constexpr auto Position = "glm::vec3";
    static constexpr auto Normal = "glm::vec3";
    static constexpr auto TexCoords = "glm::vec2";
    static constexpr auto Tangent = "glm::vec3";
    static constexpr auto Bitangent = "glm::vec3";
    static constexpr auto m_BoneIDs = "int[4]";
    static constexpr auto m_Weights = "float[4]";
};
struct Mesh_Reflection {
    static constexpr auto vertices = "int";
    static constexpr auto indices = "int";
    static constexpr auto VAO = "unsigned int";
    static constexpr auto SSBO = "unsigned int";
    static constexpr auto VBO = "unsigned int";
    static constexpr auto EBO = "unsigned int";
    static constexpr auto SHADOW_WIDTH = "const unsigned int";
    static constexpr auto SHADOW_HEIGHT = "const unsigned int";
    static constexpr auto depthMap = "unsigned int";
};
struct Renderer_Reflection {
    static constexpr auto mesh = "std::shared_ptr<Mesh>";
    static constexpr auto material = "std::shared_ptr<Material>";
    static constexpr auto modelMatrix = "glm::mat4";
    static constexpr auto viewMatrix = "glm::mat4";
    static constexpr auto projectionMatrix = "glm::mat4";
    static constexpr auto transform = "std::shared_ptr<Transform>";
};
struct RenderManager_Reflection {
    static constexpr auto shaderToRenderer = "int";
    static constexpr auto renderers = "int";
    static constexpr auto depthCubeMaps = "int";
    static constexpr auto additionalDepthFBOs = "int";
    static constexpr auto DirectionalShadowShader = "std::shared_ptr<Shader>";
    static constexpr auto AdditionalShadowShader = "std::shared_ptr<Shader>";
    static constexpr auto depthMapFBO = "unsigned int";
    static constexpr auto depthMap = "unsigned int";
    static constexpr auto MAIN_SHADOW_WIDTH = "const unsigned int";
    static constexpr auto MAIN_SHADOW_HEIGHT = "const unsigned int";
    static constexpr auto ADDITIONAL_SHADOW_WIDTH = "const unsigned int";
    static constexpr auto ADDITIONAL_SHADOW_HEIGHT = "const unsigned int";
    static constexpr auto lightManager = "std::shared_ptr<LightManager>";
    static constexpr auto camera = "std::shared_ptr<EditorCamera>";
    static constexpr auto mainLightView = "glm::mat4";
    static constexpr auto mainLightProj = "glm::mat4";
    static constexpr auto pointLights = "int";
    static constexpr auto screenShader = "std::shared_ptr<Shader>";
    static constexpr auto quadVertices = "float[24]";
    static constexpr auto framebuffer = "unsigned int";
    static constexpr auto textureColorbuffer = "unsigned int";
    static constexpr auto rbo = "unsigned int";
    static constexpr auto quadVAO = "unsigned int";
    static constexpr auto quadVBO = "unsigned int";
    static constexpr auto skyboxVAO = "unsigned int";
    static constexpr auto skyboxVBO = "unsigned int";
    static constexpr auto skyboxTexture = "unsigned int";
    static constexpr auto hdrTexture = "unsigned int";
    static constexpr auto irradianceMap = "unsigned int";
    static constexpr auto prefilterMap = "unsigned int";
    static constexpr auto brdfLUTTexture = "unsigned int";
    static constexpr auto irradianceShader = "std::shared_ptr<Shader>";
    static constexpr auto skyboxShader = "std::shared_ptr<Shader>";
    static constexpr auto skyboxMappingShader = "std::shared_ptr<Shader>";
    static constexpr auto preFilterShader = "std::shared_ptr<Shader>";
    static constexpr auto brdfShader = "std::shared_ptr<Shader>";
    static constexpr auto skyboxLocation = "int";
    static constexpr auto m_Width = "int";
    static constexpr auto m_Height = "int";
    static constexpr auto skyboxVertices = "float[108]";
};
struct Scene_Reflection {
    static constexpr auto camera = "std::shared_ptr<EditorCamera>";
    static constexpr auto lightManager = "std::shared_ptr<LightManager>";
    static constexpr auto renderManager = "int";
    static constexpr auto gameObjects = "int";
    static constexpr auto gameObjectsToDelete = "int";
};
struct SceneManager_Reflection {
    static constexpr auto currentScene = "std::shared_ptr<Scene>";
};
struct fpos_Reflection {
    static constexpr auto __st_ = "_StateT";
    static constexpr auto __off_ = "streamoff";
};
struct enable_if_Reflection {
};
struct enable_if_Reflection {
};
struct integral_constant_Reflection {
};
struct remove_cv_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct __equal_tag_Reflection {
};
struct __plus_tag_Reflection {
};
struct __totally_ordered_less_tag_Reflection {
};
struct __equal_to_Reflection {
};
struct __less_Reflection {
};
struct __less_Reflection {
};
struct __debug_less_Reflection {
    static constexpr auto __comp_ = "_Compare &";
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct is_floating_point_Reflection {
};
struct is_arithmetic_Reflection {
};
struct is_signed_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct is_convertible_Reflection {
};
struct is_function_Reflection {
};
struct is_reference_Reflection {
};
struct is_lvalue_reference_Reflection {
};
struct is_rvalue_reference_Reflection {
};
struct remove_all_extents_Reflection {
};
struct is_destructible_Reflection {
};
struct is_nothrow_destructible_Reflection {
};
struct is_same_Reflection {
};
struct __libcpp_is_referenceable_Reflection {
};
struct add_lvalue_reference_Reflection {
};
struct add_rvalue_reference_Reflection {
};
struct is_constructible_Reflection {
};
struct is_copy_constructible_Reflection {
};
struct is_move_constructible_Reflection {
};
struct is_default_constructible_Reflection {
};
struct _IfImpl_Reflection {
};
struct _IfImpl_Reflection {
};
struct conditional_Reflection {
};
struct conditional_Reflection {
};
struct is_void_Reflection {
};
struct remove_reference_Reflection {
};
struct add_pointer_Reflection {
};
struct is_array_Reflection {
};
struct remove_extent_Reflection {
};
struct decay_Reflection {
};
struct __type_identity_Reflection {
};
struct __empty_Reflection {
};
struct common_type_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct is_class_Reflection {
};
struct is_enum_Reflection {
};
struct is_union_Reflection {
};
struct extent_Reflection {
};
struct is_nothrow_assignable_Reflection {
};
struct is_nothrow_copy_assignable_Reflection {
};
struct is_nothrow_move_assignable_Reflection {
};
struct is_nothrow_constructible_Reflection {
};
struct is_nothrow_copy_constructible_Reflection {
};
struct is_nothrow_move_constructible_Reflection {
};
struct is_nothrow_default_constructible_Reflection {
};
struct is_assignable_Reflection {
};
struct is_copy_assignable_Reflection {
};
struct is_move_assignable_Reflection {
};
struct is_swappable_with_Reflection {
};
struct is_swappable_Reflection {
};
struct is_nothrow_swappable_with_Reflection {
};
struct is_nothrow_swappable_Reflection {
};
struct is_object_Reflection {
};
struct __nat_Reflection {
};
struct __type_list_Reflection {
};
struct __find_first_Reflection {
};
struct __find_first_Reflection {
};
struct make_signed_Reflection {
};
struct _OrImpl_Reflection {
};
struct _OrImpl_Reflection {
};
struct disjunction_Reflection {
};
struct remove_const_Reflection {
};
struct input_iterator_tag_Reflection {
};
struct output_iterator_tag_Reflection {
};
struct forward_iterator_tag_Reflection {
};
struct bidirectional_iterator_tag_Reflection {
};
struct random_access_iterator_tag_Reflection {
};
struct __iter_traits_cache_Reflection {
};
struct __iter_concept_concept_test_Reflection {
};
struct __iter_concept_category_test_Reflection {
};
struct __iter_concept_random_fallback_Reflection {
};
struct __test_iter_concept_Reflection {
};
struct __iter_concept_cache_Reflection {
};
struct __has_iterator_typedefs_Reflection {
};
struct __has_iterator_category_Reflection {
};
struct __has_iterator_concept_Reflection {
};
struct __iterator_traits_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __is_callable_Reflection {
};
struct initializer_list_Reflection {
    static constexpr auto __begin_ = "const _Ep *";
    static constexpr auto __size_ = "size_t";
};
struct __is_identity_Reflection {
};
struct __identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct is_base_of_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct is_member_pointer_Reflection {
};
struct is_member_object_pointer_Reflection {
};
struct is_member_function_pointer_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __invokable_r_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __invoke_of_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct is_invocable_Reflection {
};
struct is_invocable_r_Reflection {
};
struct is_nothrow_invocable_Reflection {
};
struct is_nothrow_invocable_r_Reflection {
};
struct invoke_result_Reflection {
};
struct __has_specialization_Reflection {
};
struct __has_specialization_Reflection {
};
struct __all_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct __has_pointer_Reflection {
};
struct __has_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __has_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __has_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_impl_Reflection {
};
struct pointer_traits_Reflection {
};
struct pointer_traits_Reflection {
};
struct __nat_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasArrow_Reflection {
};
struct _HasArrow_Reflection {
};
struct _IsFancyPointer_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct add_const_Reflection {
};
struct add_cv_Reflection {
};
struct add_volatile_Reflection {
};
struct __align_type_Reflection {
};
struct __struct_double_Reflection {
    static constexpr auto __lx = "long double";
};
struct __struct_double4_Reflection {
    static constexpr auto __lx = "double[4]";
};
struct __fallback_overaligned_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_max_align_Reflection {
};
struct __select_align_Reflection {
};
struct __find_max_align_Reflection {
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __align = "_Aligner";
    static constexpr auto __data = "unsigned char[(_Len + _Align - 1) / _Align * _Align]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1 - 1) / 1 * 1]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2 - 1) / 2 * 2]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4 - 1) / 4 * 4]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8 - 1) / 8 * 8]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 16 - 1) / 16 * 16]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 32 - 1) / 32 * 32]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 64 - 1) / 64 * 64]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 128 - 1) / 128 * 128]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 256 - 1) / 256 * 256]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 512 - 1) / 512 * 512]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1024 - 1) / 1024 * 1024]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2048 - 1) / 2048 * 2048]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4096 - 1) / 4096 * 4096]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8192 - 1) / 8192 * 8192]";
};
struct __static_max_Reflection {
};
struct __static_max_Reflection {
};
struct aligned_union_Reflection {
};
struct alignment_of_Reflection {
};
struct has_virtual_destructor_Reflection {
};
struct is_abstract_Reflection {
};
struct is_null_pointer_Reflection {
};
struct is_fundamental_Reflection {
};
struct is_compound_Reflection {
};
struct is_const_Reflection {
};
struct is_empty_Reflection {
};
struct is_literal_type_Reflection {
};
struct is_pod_Reflection {
};
struct is_pointer_Reflection {
};
struct is_polymorphic_Reflection {
};
struct is_scalar_Reflection {
};
struct is_standard_layout_Reflection {
};
struct is_trivial_Reflection {
};
struct is_trivially_assignable_Reflection {
};
struct is_trivially_copy_assignable_Reflection {
};
struct is_trivially_move_assignable_Reflection {
};
struct is_trivially_constructible_Reflection {
};
struct is_trivially_copy_constructible_Reflection {
};
struct is_trivially_move_constructible_Reflection {
};
struct is_trivially_default_constructible_Reflection {
};
struct is_trivially_copyable_Reflection {
};
struct is_trivially_destructible_Reflection {
};
struct is_unsigned_Reflection {
};
struct is_volatile_Reflection {
};
struct make_unsigned_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct remove_pointer_Reflection {
};
struct remove_volatile_Reflection {
};
struct result_of_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct underlying_type_Reflection {
};
struct __libcpp_is_final_Reflection {
};
struct is_final_Reflection {
};
struct has_unique_object_representations_Reflection {
};
struct is_aggregate_Reflection {
};
struct _Not_Reflection {
};
struct negation_Reflection {
};
struct _FirstPaddingByte_Reflection {
    static constexpr auto __v_ = "_Tp";
    static constexpr auto __first_padding_byte_ = "char";
};
struct __is_always_bitcastable_Reflection {
};
struct __is_equality_comparable_Reflection {
};
struct __libcpp_is_trivially_equality_comparable_impl_Reflection {
};
struct __is_less_than_comparable_Reflection {
};
struct __find_segment_Reflection {
    static constexpr auto __value_ = "const _Tp &";
};
struct __unary_function_keep_layout_base_Reflection {
};
struct __integer_sequence_Reflection {
};
struct integer_sequence_Reflection {
};
struct __tuple_indices_Reflection {
};
struct __make_tuple_indices_Reflection {
};
struct __tuple_types_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_size_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_sfinae_base_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct tuple_element_Reflection {
};
struct __check_tuple_constructor_fail_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __libcpp_is_trivially_relocatable_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_ref_decay_Reflection {
};
struct piecewise_construct_t_Reflection {
};
struct __non_trivially_copyable_base_Reflection {
};
struct pair_Reflection {
    static constexpr auto first = "_T1";
    static constexpr auto second = "_T2";
};
struct _CheckArgs_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct __get_pair_Reflection {
};
struct __get_pair_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct _PairT_Reflection {
    static constexpr auto first = "size_t";
    static constexpr auto second = "size_t";
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct _Reflection {
    static constexpr auto __t = "long double";
    static constexpr auto __s = "struct (unnamed struct at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__functional\hash.h:476:7)";
};
struct _Reflection {
    static constexpr auto __a = "size_t";
    static constexpr auto __b = "size_t";
};
struct __enum_hash_Reflection {
};
struct __enum_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __bounded_iter_Reflection {
    static constexpr auto __current_ = "_Iterator";
    static constexpr auto __begin_ = "_Iterator";
    static constexpr auto __end_ = "_Iterator";
};
struct __sfinae_underlying_type_Reflection {
};
struct __sfinae_underlying_type_Reflection {
};
struct iterator_Reflection {
};
struct reverse_iterator_Reflection {
    static constexpr auto __t_ = "_Iter";
    static constexpr auto current = "_Iter";
};
struct __unwrap_iter_impl_Reflection {
};
struct __wrap_iter_Reflection {
    static constexpr auto __i_ = "iterator_type";
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct pointer_traits_Reflection {
};
struct __pointer_Reflection {
};
struct __pointer_Reflection {
};
struct __has_const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __has_void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __has_const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __has_size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __has_alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __has_propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __has_propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __has_propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __has_is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __has_rebind_other_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct allocator_traits_Reflection {
};
struct __check_valid_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_cpp17_move_insertable_Reflection {
};
struct __is_cpp17_copy_insertable_Reflection {
};
struct __allocation_result_Reflection {
    static constexpr auto ptr = "_Pointer";
    static constexpr auto count = "size_t";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __noexcept_move_assign_container_Reflection {
};
struct memory_resource_Reflection {
};
struct __exception_guard_exceptions_Reflection {
    static constexpr auto __rollback_ = "_Rollback";
    static constexpr auto __completed_ = "_Bool";
};
struct __exception_guard_noexceptions_Reflection {
    static constexpr auto __completed_ = "_Bool";
};
struct __has_allocator_type_Reflection {
};
struct __uses_allocator_Reflection {
};
struct __uses_allocator_Reflection {
};
struct uses_allocator_Reflection {
};
struct allocator_arg_t_Reflection {
};
struct __uses_alloc_ctor_imp_Reflection {
};
struct __uses_alloc_ctor_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_t_Reflection {
};
struct __ignore_type_Reflection {
};
struct _Lazy_Reflection {
};
struct __promote_Reflection {
};
struct __tuple_leaf_Reflection {
    static constexpr auto __value_ = "_Hp";
};
struct __tuple_leaf_Reflection {
};
struct __all_default_constructible_Reflection {
};
struct __tuple_impl_Reflection {
};
struct tuple_Reflection {
    static constexpr auto __base_ = "_BaseT";
};
struct _IsThisTuple_Reflection {
};
struct _EnableUTypesCtor_Reflection {
};
struct _EnableCtorFromUTypesTuple_Reflection {
};
struct _CtorPredicateFromPair_Reflection {
};
struct _EnableCtorFromPair_Reflection {
};
struct _NothrowConstructibleFromPair_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _AssignPredicateFromPair_Reflection {
};
struct _EnableAssignFromPair_Reflection {
};
struct _NothrowAssignFromPair_Reflection {
};
struct tuple_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_cat_type_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_Reflection {
};
struct __tuple_cat_Reflection {
};
struct uses_allocator_Reflection {
};
struct bad_cast_Reflection {
};
struct bad_typeid_Reflection {
};
struct exception_ptr_Reflection {
    static constexpr auto __ptr1_ = "void *";
    static constexpr auto __ptr2_ = "void *";
};
struct nested_exception_Reflection {
    static constexpr auto __ptr_ = "exception_ptr";
};
struct __nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __can_dynamic_cast_Reflection {
};
struct __save_flags_Reflection {
    static constexpr auto __stream_ = "__stream_type &";
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __fill_ = "_CharT";
};
struct in_place_t_Reflection {
};
struct in_place_type_t_Reflection {
};
struct in_place_index_t_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct polymorphic_allocator_Reflection {
    static constexpr auto __res_ = "memory_resource *";
};
struct _ClassicAlgPolicy_Reflection {
};
struct _IterOps_Reflection {
};
struct char_traits_Reflection {
};
struct __char_traits_base_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct __is_allocator_Reflection {
};
struct logic_error_Reflection {
};
struct runtime_error_Reflection {
};
struct domain_error_Reflection {
};
struct invalid_argument_Reflection {
};
struct length_error_Reflection {
};
struct out_of_range_Reflection {
};
struct range_error_Reflection {
};
struct overflow_error_Reflection {
};
struct underflow_error_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto __data_ = "const value_type *";
    static constexpr auto __size_ = "size_type";
};
struct __assume_valid_Reflection {
};
struct __string_view_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __can_lower_copy_assignment_to_memmove_Reflection {
};
struct __can_lower_move_assignment_to_memmove_Reflection {
};
struct __can_rewrap_Reflection {
};
struct __copy_impl_Reflection {
};
struct _CopySegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __copy_backward_impl_Reflection {
};
struct nullopt_t_Reflection {
};
struct __secret_tag_Reflection {
};
struct __optional_construct_from_invoke_tag_Reflection {
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_storage_base_Reflection {
};
struct __optional_storage_base_Reflection {
    static constexpr auto __value_ = "int *";
};
struct __optional_copy_base_Reflection {
};
struct __optional_copy_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __is_std_optional_Reflection {
};
struct __is_std_optional_Reflection {
};
struct optional_Reflection {
};
struct _CheckOptionalArgsConstructor_Reflection {
};
struct _CheckOptionalLikeConstructor_Reflection {
};
struct __cxx_atomic_base_impl_Reflection {
    static constexpr auto __a_value = "_Atomic(_Tp)";
};
struct __cxx_atomic_impl_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_lcm_Reflection {
};
struct __static_abs_Reflection {
};
struct __static_sign_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_div_Reflection {
};
struct ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __ratio_multiply_Reflection {
};
struct __ratio_divide_Reflection {
};
struct __ratio_add_Reflection {
};
struct __ratio_subtract_Reflection {
};
struct ratio_equal_Reflection {
};
struct ratio_not_equal_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct ratio_less_Reflection {
};
struct ratio_less_equal_Reflection {
};
struct ratio_greater_Reflection {
};
struct ratio_greater_equal_Reflection {
};
struct __ratio_gcd_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct common_type_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct treat_as_floating_point_Reflection {
};
struct duration_values_Reflection {
};
struct duration_Reflection {
    static constexpr auto __rep_ = "rep";
};
struct __no_overflow_Reflection {
};
struct __mul_Reflection {
};
struct __mul_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_lt_Reflection {
};
struct __duration_lt_Reflection {
};
struct time_point_Reflection {
    static constexpr auto __d_ = "duration";
};
struct common_type_Reflection {
};
struct steady_clock_Reflection {
};
struct system_clock_Reflection {
};
struct __spinning_backoff_policy_Reflection {
};
struct __atomic_waitable_traits_Reflection {
};
struct __atomic_waitable_Reflection {
};
struct __atomic_wait_poll_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_wait_backoff_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_compare_unequal_to_Reflection {
    static constexpr auto __val_ = "_Tp";
};
struct __libcpp_is_always_lock_free_Reflection {
};
struct __atomic_base_Reflection {
    static constexpr auto __a_ = "int";
};
struct __atomic_base_Reflection {
};
struct __binary_function_keep_layout_base_Reflection {
};
struct plus_Reflection {
};
struct plus_Reflection {
};
struct minus_Reflection {
};
struct minus_Reflection {
};
struct multiplies_Reflection {
};
struct multiplies_Reflection {
};
struct divides_Reflection {
};
struct divides_Reflection {
};
struct modulus_Reflection {
};
struct modulus_Reflection {
};
struct negate_Reflection {
};
struct negate_Reflection {
};
struct bit_and_Reflection {
};
struct bit_and_Reflection {
};
struct bit_not_Reflection {
};
struct bit_not_Reflection {
};
struct bit_or_Reflection {
};
struct bit_or_Reflection {
};
struct bit_xor_Reflection {
};
struct bit_xor_Reflection {
};
struct equal_to_Reflection {
};
struct equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct less_Reflection {
};
struct less_Reflection {
};
struct less_equal_Reflection {
};
struct less_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_Reflection {
};
struct greater_Reflection {
};
struct logical_and_Reflection {
};
struct logical_and_Reflection {
};
struct logical_not_Reflection {
};
struct logical_not_Reflection {
};
struct logical_or_Reflection {
};
struct logical_or_Reflection {
};
struct atomic_Reflection {
};
struct atomic_Reflection {
};
struct atomic_flag_Reflection {
    static constexpr auto __a_ = "int";
};
struct back_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct front_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
    static constexpr auto iter = "int";
};
struct istream_iterator_Reflection {
    static constexpr auto __in_stream_ = "istream_type *";
    static constexpr auto __value_ = "_Tp";
};
struct istreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __proxy_Reflection {
    static constexpr auto __keep_ = "char_type";
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct move_iterator_Reflection {
    static constexpr auto __current_ = "_Iter";
};
struct ostream_iterator_Reflection {
    static constexpr auto __out_stream_ = "ostream_type *";
    static constexpr auto __delim_ = "const char_type *";
};
struct ostreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __dependent_type_Reflection {
};
struct monostate_Reflection {
};
struct hash_Reflection {
};
struct __farray_Reflection {
    static constexpr auto __buf_ = "_Tp[_Size]";
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_Reflection {
};
struct __valueless_t_Reflection {
};
struct __traits_Reflection {
};
struct __union_Reflection {
};
struct __base_Reflection {
};
struct __variant_Reflection {
};
struct __base_Reflection {
};
struct __dispatcher_Reflection {
};
struct __variant_Reflection {
};
struct __value_visitor_Reflection {
    static constexpr auto __visitor = "_Visitor &&";
};
struct __alt_Reflection {
    static constexpr auto __value = "__value_type";
};
struct __union_Reflection {
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_TriviallyAvailable, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Available, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Unavailable, _Index + 1, _Types...>";
};
struct __base_Reflection {
    static constexpr auto __data = "__union<_DestructibleTrait, 0, _Types...>";
    static constexpr auto __index = "int";
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __ctor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __impl_Reflection {
};
struct __no_narrowing_check_Reflection {
};
struct __narrowing_check_Reflection {
};
struct __overload_Reflection {
};
struct __all_overloads_Reflection {
};
struct __make_overloads_imp_Reflection {
};
struct variant_Reflection {
    static constexpr auto __impl_ = "__variant_detail::__impl<_Types...>";
};
struct __convert_to_bool_Reflection {
};
struct __has_result_type_Reflection {
};
struct __derives_from_unary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __derives_from_binary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct reference_wrapper_Reflection {
    static constexpr auto __f_ = "type *";
};
struct __allocation_guard_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __n_ = "_Size";
    static constexpr auto __ptr_ = "_Pointer";
};
struct __allocator_destructor_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __s_ = "size_type";
};
struct __move_impl_Reflection {
};
struct _MoveSegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __always_false_Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _AllocatorDestroyRangeReverse_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __first_ = "_Iter &";
    static constexpr auto __last_ = "_Iter &";
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __has_array_cookie_Reflection {
};
struct __private_constructor_tag_Reflection {
};
struct default_delete_Reflection {
};
struct default_delete_Reflection {
};
struct _EnableIfConvertible_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
};
struct __unique_ptr_array_bounds_stateless_Reflection {
};
struct __unique_ptr_array_bounds_stored_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
    static constexpr auto __checker_ = "_BoundsChecker";
};
struct _CheckArrayPointerConversion_Reflection {
};
struct _CheckArrayPointerConversion_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct bad_weak_ptr_Reflection {
};
struct __shared_count_Reflection {
    static constexpr auto __shared_owners_ = "long";
};
struct __shared_weak_count_Reflection {
    static constexpr auto __shared_weak_owners_ = "long";
};
struct __shared_ptr_pointer_Reflection {
    static constexpr auto __ptr_ = "_Tp";
    static constexpr auto __deleter_ = "_Dp";
    static constexpr auto __alloc_ = "_Alloc";
};
struct __for_overwrite_tag_Reflection {
};
struct __shared_ptr_emplace_Reflection {
    static constexpr auto __storage_ = "_Storage";
};
struct _Storage_Reflection {
    static constexpr auto __buffer_ = "char[sizeof(_Data)]";
};
struct _Data_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __elem_ = "int";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __compatible_with_Reflection {
};
struct __raw_pointer_compatible_with_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __well_formed_deleter_Reflection {
};
struct __shared_ptr_deleter_ctor_reqs_Reflection {
};
struct shared_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct __nullptr_sfinae_tag_Reflection {
};
struct __shared_ptr_default_allocator_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __sp_aligned_storage_Reflection {
    static constexpr auto __storage = "char[_Alignment]";
};
struct __unbounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __count_ = "size_t";
    static constexpr auto  = "union std::__unbounded_array_control_block<type-parameter-0-0[], type-parameter-0-1>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:952:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct __bounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto  = "union std::__bounded_array_control_block<type-parameter-0-0[_Np], type-parameter-0-2>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:1030:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[_Count]";
};
struct weak_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct enable_shared_from_this_Reflection {
    static constexpr auto __weak_this_ = "weak_ptr<_Tp>";
};
struct hash_Reflection {
};
struct __sp_mut_Reflection {
    static constexpr auto __lx_ = "void *";
};
struct raw_storage_iterator_Reflection {
    static constexpr auto __x_ = "_OutputIterator";
};
struct __temporary_buffer_deleter_Reflection {
    static constexpr auto __count_ = "ptrdiff_t";
};
struct __move_backward_impl_Reflection {
};
struct __destruct_n_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct __invert_Reflection {
    static constexpr auto __p_ = "_Predicate";
};
struct _ConstTimeDistance_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct _Reflection {
};
struct __aliasing_iterator_wrapper_Reflection {
};
struct __iterator_Reflection {
    static constexpr auto __base_ = "_BaseIter";
};
struct _MinmaxElementLessFunc_Reflection {
    static constexpr auto __comp_ = "_Comp &";
    static constexpr auto __proj_ = "_Proj &";
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct _ProjectedPred_Reflection {
    static constexpr auto __pred = "_Pred &";
    static constexpr auto __proj = "_Proj &";
};
struct __set_intersection_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_symmetric_difference_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_union_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_urng_Reflection {
};
struct __log2_Reflection {
};
struct __independent_bits_engine_Reflection {
    static constexpr auto __e_ = "_Engine &";
    static constexpr auto __w_ = "size_t";
    static constexpr auto __w0_ = "size_t";
    static constexpr auto __n_ = "size_t";
    static constexpr auto __n0_ = "size_t";
    static constexpr auto __y0_ = "_Working_result_type";
    static constexpr auto __y1_ = "_Working_result_type";
    static constexpr auto __mask0_ = "_Engine_result_type";
    static constexpr auto __mask1_ = "_Engine_result_type";
};
struct uniform_int_distribution_Reflection {
    static constexpr auto __p_ = "param_type";
};
struct param_type_Reflection {
    static constexpr auto __a_ = "result_type";
    static constexpr auto __b_ = "result_type";
};
struct __libcpp_debug_randomizer_Reflection {
    static constexpr auto __state_ = "int";
    static constexpr auto __inc_ = "int";
};
struct __stable_sort_switch_Reflection {
};
struct __reread_from_input_tag_Reflection {
};
struct __reread_from_output_tag_Reflection {
};
struct __read_from_tmp_value_tag_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __can_be_converted_to_string_view_Reflection {
};
struct __uninitialized_size_tag_Reflection {
};
struct __init_with_sentinel_tag_Reflection {
};
struct __padding_Reflection {
    static constexpr auto __padding_ = "char[_PaddingSize]";
};
struct __padding_Reflection {
};
struct basic_string_Reflection {
    static constexpr auto __rep_ = "__rep";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __long_Reflection {
    static constexpr auto  = "struct std::basic_string::__long::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:902:5)";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __data_ = "pointer";
};
struct _Reflection {
    static constexpr auto __is_long_ = "size_type";
    static constexpr auto __cap_ = "size_type";
};
struct __short_Reflection {
    static constexpr auto  = "struct std::basic_string::__short::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:913:5)";
    static constexpr auto __padding_ = "__padding<sizeof(value_type) - 1>";
    static constexpr auto __data_ = "value_type[__min_cap]";
};
struct _Reflection {
    static constexpr auto __is_long_ = "unsigned char";
    static constexpr auto __size_ = "unsigned char";
};
struct __rep_Reflection {
    static constexpr auto __s = "__short";
    static constexpr auto __l = "__long";
};
struct __string_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __lconv_storage_Reflection {
    static constexpr auto __lc_ = "int";
    static constexpr auto __decimal_point_ = "int";
    static constexpr auto __thousands_sep_ = "int";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __int_curr_symbol_ = "int";
    static constexpr auto __currency_symbol_ = "int";
    static constexpr auto __mon_decimal_point_ = "int";
    static constexpr auto __mon_thousands_sep_ = "int";
    static constexpr auto __mon_grouping_ = "int";
    static constexpr auto __positive_sign_ = "int";
    static constexpr auto __negative_sign_ = "int";
};
struct locale_t_Reflection {
    static constexpr auto __locale_str_ = "const char *";
    static constexpr auto __lc_ = "__lconv_storage *";
};
struct once_flag_Reflection {
    static constexpr auto __state_ = "_State_type";
};
struct __call_once_param_Reflection {
    static constexpr auto __f_ = "_Fp &";
};
struct __uninitialized_tag_Reflection {
};
struct __no_destroy_Reflection {
    static constexpr auto __obj_ = "char[sizeof(_Tp)]";
};
struct locale_Reflection {
    static constexpr auto __locale_ = "__imp *";
};
struct facet_Reflection {
};
struct id_Reflection {
    static constexpr auto __flag_ = "once_flag";
    static constexpr auto __id_ = "int";
};
struct collate_Reflection {
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_base_Reflection {
};
struct ctype_Reflection {
};
struct ctype_Reflection {
    static constexpr auto __tab_ = "const mask *";
    static constexpr auto __del_ = "_Bool";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_base_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_byname_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_byname_Reflection {
};
struct numpunct_byname_Reflection {
};
struct error_category_Reflection {
};
struct __do_message_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct error_condition_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct is_error_code_enum_Reflection {
};
struct error_code_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct system_error_Reflection {
    static constexpr auto __ec_ = "error_code";
};
struct ios_base_Reflection {
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __precision_ = "streamsize";
    static constexpr auto __width_ = "streamsize";
    static constexpr auto __rdstate_ = "iostate";
    static constexpr auto __exceptions_ = "iostate";
    static constexpr auto __rdbuf_ = "void *";
    static constexpr auto __loc_ = "void *";
    static constexpr auto __fn_ = "event_callback *";
    static constexpr auto __index_ = "int *";
    static constexpr auto __event_size_ = "size_t";
    static constexpr auto __event_cap_ = "size_t";
    static constexpr auto __iarray_ = "long *";
    static constexpr auto __iarray_size_ = "size_t";
    static constexpr auto __iarray_cap_ = "size_t";
    static constexpr auto __parray_ = "void **";
    static constexpr auto __parray_size_ = "size_t";
    static constexpr auto __parray_cap_ = "size_t";
};
struct is_error_code_enum_Reflection {
};
struct failure_Reflection {
};
struct Init_Reflection {
};
struct _FillHelper_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
    static constexpr auto __set_ = "_Bool";
};
struct _SentinelValueFill_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
};
struct basic_ios_Reflection {
    static constexpr auto __tie_ = "basic_ostream<char_type, traits_type> *";
    static constexpr auto __fill_ = "_FillType";
};
struct mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_mutex_t";
};
struct defer_lock_t_Reflection {
};
struct try_to_lock_t_Reflection {
};
struct adopt_lock_t_Reflection {
};
struct unique_lock_Reflection {
    static constexpr auto __m_ = "mutex_type *";
    static constexpr auto __owns_ = "_Bool";
};
struct condition_variable_Reflection {
    static constexpr auto __cv_ = "__libcpp_condvar_t";
};
struct lock_guard_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct __thread_id_Reflection {
    static constexpr auto __id_ = "__libcpp_thread_id";
};
struct recursive_mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_recursive_mutex_t";
};
struct timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __locked_ = "_Bool";
};
struct recursive_timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __count_ = "size_t";
    static constexpr auto __id_ = "__thread_id";
};
struct scoped_lock_Reflection {
};
struct scoped_lock_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct scoped_lock_Reflection {
    static constexpr auto __t_ = "_MutexTuple";
};
struct __has_storage_type_Reflection {
};
struct __bit_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_reference_Reflection {
};
struct __bit_const_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_array_Reflection {
    static constexpr auto __size_ = "difference_type";
    static constexpr auto __word_ = "__storage_type[4]";
};
struct __bit_iterator_Reflection {
    static constexpr auto __seg_ = "int";
    static constexpr auto __ctz_ = "unsigned int";
};
struct __has_storage_type_Reflection {
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type[_N_words]";
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type";
};
struct __bitset_Reflection {
};
struct bitset_Reflection {
};
struct hash_Reflection {
};
struct basic_streambuf_Reflection {
    static constexpr auto __loc_ = "locale";
    static constexpr auto __binp_ = "char_type *";
    static constexpr auto __ninp_ = "char_type *";
    static constexpr auto __einp_ = "char_type *";
    static constexpr auto __bout_ = "char_type *";
    static constexpr auto __nout_ = "char_type *";
    static constexpr auto __eout_ = "char_type *";
};
struct __num_get_base_Reflection {
};
struct __num_get_Reflection {
};
struct num_get_Reflection {
};
struct __num_put_base_Reflection {
};
struct __num_put_Reflection {
};
struct num_put_Reflection {
};
struct time_base_Reflection {
};
struct __time_get_c_storage_Reflection {
};
struct time_get_Reflection {
};
struct __time_get_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct __time_get_storage_Reflection {
    static constexpr auto __weeks_ = "string_type[14]";
    static constexpr auto __months_ = "string_type[24]";
    static constexpr auto __am_pm_ = "string_type[2]";
    static constexpr auto __c_ = "string_type";
    static constexpr auto __r_ = "string_type";
    static constexpr auto __x_ = "string_type";
    static constexpr auto __X_ = "string_type";
};
struct time_get_byname_Reflection {
};
struct __time_put_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct time_put_Reflection {
};
struct time_put_byname_Reflection {
};
struct money_base_Reflection {
};
struct pattern_Reflection {
    static constexpr auto field = "char[4]";
};
struct moneypunct_Reflection {
};
struct moneypunct_byname_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __curr_symbol_ = "string_type";
    static constexpr auto __positive_sign_ = "string_type";
    static constexpr auto __negative_sign_ = "string_type";
    static constexpr auto __frac_digits_ = "int";
    static constexpr auto __pos_format_ = "pattern";
    static constexpr auto __neg_format_ = "pattern";
};
struct __money_get_Reflection {
};
struct money_get_Reflection {
};
struct __money_put_Reflection {
};
struct money_put_Reflection {
};
struct messages_base_Reflection {
};
struct messages_Reflection {
};
struct messages_byname_Reflection {
};
struct wstring_convert_Reflection {
    static constexpr auto __byte_err_string_ = "byte_string";
    static constexpr auto __wide_err_string_ = "wide_string";
    static constexpr auto __cvtptr_ = "_Codecvt *";
    static constexpr auto __cvtstate_ = "state_type";
    static constexpr auto __cvtcount_ = "size_t";
};
struct wbuffer_convert_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __bufptr_ = "int *";
    static constexpr auto __cv_ = "_Codecvt *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ostream_Reflection {
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
    static constexpr auto __os_ = "basic_ostream<_CharT, _Traits> &";
};
struct __is_ostreamable_Reflection {
};
struct __is_ostreamable_Reflection {
};
struct basic_istream_Reflection {
    static constexpr auto __gc_ = "streamsize";
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
};
struct __is_istreamable_Reflection {
};
struct __is_istreamable_Reflection {
};
struct basic_iostream_Reflection {
};
struct array_Reflection {
    static constexpr auto __elems_ = "_Tp[_Size]";
};
struct array_Reflection {
    static constexpr auto __elems_ = "int[sizeof(_ArrayInStructT)]";
};
struct _ArrayInStructT_Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct __temp_value_Reflection {
    static constexpr auto  = "union std::__temp_value::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\temp_value.h:31:3)";
    static constexpr auto __a = "_Alloc &";
};
struct _Reflection {
    static constexpr auto __v = "_Tp";
};
struct __split_buffer_Reflection {
    static constexpr auto __first_ = "int";
    static constexpr auto __begin_ = "int";
    static constexpr auto __end_ = "int";
    static constexpr auto __end_cap_ = "int";
    static constexpr auto __alloc_ = "allocator_type";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "const int";
    static constexpr auto __dest_ = "int *";
};
struct __container_traits_Reflection {
};
struct __deque_block_size_Reflection {
};
struct __deque_iterator_Reflection {
    static constexpr auto __m_iter_ = "__map_iterator";
    static constexpr auto __ptr_ = "pointer";
};
struct deque_Reflection {
    static constexpr auto __map_ = "int";
    static constexpr auto __start_ = "size_type";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __deque_block_range_Reflection {
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __end_ = "const pointer";
};
struct __deque_range_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "int";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __end_ = "const pointer";
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __base_ = "deque<_Tp, _Allocator> *const";
};
struct __container_traits_Reflection {
};
struct binary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct is_bind_expression_Reflection {
};
struct is_placeholder_Reflection {
};
struct __ph_Reflection {
};
struct is_placeholder_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_Reflection {
    static constexpr auto __f_ = "int";
    static constexpr auto __bound_args_ = "_Td";
};
struct is_bind_expression_Reflection {
};
struct __bind_r_Reflection {
};
struct is_bind_expression_Reflection {
};
struct __mem_fn_Reflection {
    static constexpr auto __f_ = "type";
};
struct unary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct __builtin_new_allocator_Reflection {
};
struct __builtin_new_deleter_Reflection {
    static constexpr auto __size_ = "size_t";
    static constexpr auto __align_ = "size_t";
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct bad_function_call_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __alloc_func_Reflection {
    static constexpr auto __func_ = "_Fp";
    static constexpr auto __alloc_ = "_Ap";
};
struct __default_alloc_func_Reflection {
    static constexpr auto __f_ = "_Fp";
};
struct __base_Reflection {
};
struct __func_Reflection {
    static constexpr auto __f_ = "__alloc_func<_Fp, _Alloc, _Rp (_ArgTypes...)>";
};
struct __value_func_Reflection {
    static constexpr auto __buf_ = "int";
    static constexpr auto __f_ = "__func *";
};
struct __policy_storage_Reflection {
    static constexpr auto __small = "char[16]";
    static constexpr auto __large = "void *";
};
struct __use_small_storage_Reflection {
};
struct __policy_Reflection {
    static constexpr auto __clone = "void *(*const)(const void *)";
    static constexpr auto __destroy = "void (*const)(void *)";
    static constexpr auto __is_null = "const _Bool";
    static constexpr auto __type_info = "const int *const";
};
struct __policy_invoker_Reflection {
    static constexpr auto __call_ = "__Call";
};
struct __policy_func_Reflection {
    static constexpr auto __buf_ = "__policy_storage";
    static constexpr auto __invoker_ = "__invoker";
    static constexpr auto __policy_ = "const __policy *";
};
struct function_Reflection {
    static constexpr auto __f_ = "__func";
};
struct __callable_Reflection {
};
struct __extract_key_fail_tag_Reflection {
};
struct __extract_key_self_tag_Reflection {
};
struct __extract_key_first_tag_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __hash_node_base_Reflection {
    static constexpr auto __next_ = "__next_pointer";
};
struct __hash_node_Reflection {
    static constexpr auto __hash_ = "size_t";
    static constexpr auto  = "union std::__hash_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__hash_table:124:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __hash_key_value_types_Reflection {
};
struct __hash_key_value_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_node_types_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __make_hash_node_types_Reflection {
};
struct __hash_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_const_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __hash_const_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __bucket_list_deallocator_Reflection {
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __hash_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __enforce_unordered_container_requirements_Reflection {
};
struct __hash_table_Reflection {
    static constexpr auto __bucket_list_ = "__bucket_list";
    static constexpr auto __first_node_ = "__first_node";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __hasher_ = "hasher";
    static constexpr auto __max_load_factor_ = "float";
    static constexpr auto __key_eq_ = "key_equal";
};
struct __basic_node_handle_Reflection {
    static constexpr auto __ptr_ = "__node_pointer_type";
    static constexpr auto __alloc_ = "optional<allocator_type>";
};
struct __set_node_handle_specifics_Reflection {
};
struct __map_node_handle_specifics_Reflection {
};
struct __insert_return_type_Reflection {
    static constexpr auto position = "_Iterator";
    static constexpr auto inserted = "_Bool";
    static constexpr auto node = "_NodeType";
};
struct __unordered_map_hasher_Reflection {
};
struct __unordered_map_hasher_Reflection {
    static constexpr auto __hash_ = "_Hash";
};
struct __unordered_map_equal_Reflection {
};
struct __unordered_map_equal_Reflection {
    static constexpr auto __pred_ = "_Pred";
};
struct __hash_map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __hash_value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __hash_map_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct __hash_map_const_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct unordered_map_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multimap_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct to_chars_result_Reflection {
    static constexpr auto ptr = "char *";
    static constexpr auto ec = "errc";
};
struct __traits_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "pointer";
    static constexpr auto __end_ = "pointer";
    static constexpr auto __cap_ = "pointer";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Tp, _Alloc> &";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __v_ = "vector<_Tp, _Alloc> &";
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __new_end_ = "const const_pointer";
};
struct __has_storage_type_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "__storage_pointer";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __cap_ = "size_type";
    static constexpr auto __alloc_ = "__storage_allocator";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Bool, type-parameter-0-0> &";
};
struct hash_Reflection {
};
struct __container_traits_Reflection {
};
struct _BMSkipTable_Reflection {
    static constexpr auto __default_value_ = "const value_type";
    static constexpr auto __table_ = "int";
};
struct _BMSkipTable_Reflection {
    static constexpr auto __table_ = "std::array<value_type, 256>";
};
struct boyer_moore_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
    static constexpr auto __suffix_ = "shared_ptr<difference_type[]>";
};
struct boyer_moore_horspool_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
};
struct default_searcher_Reflection {
    static constexpr auto __first_ = "_ForwardIterator";
    static constexpr auto __last_ = "_ForwardIterator";
    static constexpr auto __pred_ = "_BinaryPredicate";
};
struct __not_fn_op_Reflection {
};
struct __not_fn_t_Reflection {
};
struct queue_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct priority_queue_Reflection {
    static constexpr auto c = "container_type";
    static constexpr auto comp = "value_compare";
};
struct uses_allocator_Reflection {
};
struct stack_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct _FilesystemClock_Reflection {
};
struct __forward_list_node_value_type_Reflection {
};
struct __forward_node_traits_Reflection {
};
struct __forward_begin_node_Reflection {
    static constexpr auto __next_ = "pointer";
};
struct __forward_list_node_Reflection {
    static constexpr auto  = "union std::__forward_list_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\forward_list:328:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __forward_list_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_base_Reflection {
    static constexpr auto __before_begin_ = "__begin_node";
    static constexpr auto __alloc_ = "__node_allocator";
};
struct forward_list_Reflection {
};
struct __container_traits_Reflection {
};
struct basic_stringbuf_Reflection {
    static constexpr auto __str_ = "string_type";
    static constexpr auto __hm_ = "char_type *";
    static constexpr auto __mode_ = "class ios_base::openmode";
};
struct basic_istringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_ostringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_stringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct unordered_set_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multiset_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct null_mutex_Reflection {
};
struct null_atomic_int_Reflection {
    static constexpr auto value = "int";
};
struct type_identity_Reflection {
};
struct is_contiguous_Reflection {
};
struct monostate_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto data_ = "const Char *";
    static constexpr auto size_ = "size_t";
};
struct is_char_Reflection {
};
struct is_char_Reflection {
};
struct compile_string_Reflection {
};
struct is_compile_string_Reflection {
};
struct is_string_Reflection {
};
struct char_t_impl_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct error_handler_Reflection {
};
struct basic_format_parse_context_Reflection {
    static constexpr auto format_str_ = "basic_string_view<Char>";
    static constexpr auto next_arg_id_ = "int";
};
struct compile_parse_context_Reflection {
    static constexpr auto num_args_ = "int";
    static constexpr auto types_ = "const type *";
};
struct buffer_Reflection {
    static constexpr auto ptr_ = "T *";
    static constexpr auto size_ = "size_t";
    static constexpr auto capacity_ = "size_t";
};
struct buffer_traits_Reflection {
};
struct fixed_buffer_traits_Reflection {
    static constexpr auto count_ = "size_t";
    static constexpr auto limit_ = "size_t";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto data_ = "T[buffer_size]";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "T *";
    static constexpr auto data_ = "T[buffer_size]";
};
struct counting_buffer_Reflection {
    static constexpr auto data_ = "T[buffer_size]";
    static constexpr auto count_ = "size_t";
};
struct formatter_Reflection {
};
struct appender_Reflection {
};
struct view_Reflection {
};
struct named_arg_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto value = "const T &";
};
struct named_arg_info_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto id = "int";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)]";
    static constexpr auto named_args_ = "named_arg_info<Char>[NUM_NAMED_ARGS]";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[NUM_ARGS != 0 ? NUM_ARGS : +1]";
};
struct is_named_arg_Reflection {
};
struct is_statically_named_arg_Reflection {
};
struct is_named_arg_Reflection {
};
struct unformattable_Reflection {
};
struct unformattable_char_Reflection {
};
struct unformattable_pointer_Reflection {
};
struct string_value_Reflection {
    static constexpr auto data = "const Char *";
    static constexpr auto size = "size_t";
};
struct named_arg_value_Reflection {
    static constexpr auto data = "const named_arg_info<Char> *";
    static constexpr auto size = "size_t";
};
struct custom_value_Reflection {
    static constexpr auto value = "void *";
    static constexpr auto format = "void (*)(void *, parse_context &, Context &)";
};
struct value_Reflection {
    static constexpr auto  = "union fmt::detail::value::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1261:3)";
};
struct _Reflection {
    static constexpr auto no_value = "monostate";
    static constexpr auto int_value = "int";
    static constexpr auto uint_value = "unsigned int";
    static constexpr auto long_long_value = "long long";
    static constexpr auto ulong_long_value = "unsigned long long";
    static constexpr auto int128_value = "int128_opt";
    static constexpr auto uint128_value = "uint128_opt";
    static constexpr auto bool_value = "_Bool";
    static constexpr auto char_value = "char_type";
    static constexpr auto float_value = "float";
    static constexpr auto double_value = "double";
    static constexpr auto long_double_value = "long double";
    static constexpr auto pointer = "const void *";
    static constexpr auto string = "string_value<char_type>";
    static constexpr auto custom = "custom_value<Context>";
    static constexpr auto named_args = "named_arg_value<char_type>";
};
struct format_as_result_Reflection {
};
struct has_format_as_Reflection {
};
struct arg_mapper_Reflection {
};
struct formattable_Reflection {
};
struct is_output_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct locale_ref_Reflection {
    static constexpr auto locale_ = "const void *";
};
struct basic_format_arg_Reflection {
    static constexpr auto value_ = "detail::value<Context>";
    static constexpr auto type_ = "detail::type";
};
struct handle_Reflection {
    static constexpr auto custom_ = "detail::custom_value<Context>";
};
struct basic_format_context_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto args_ = "basic_format_args<basic_format_context<OutputIt, Char> >";
    static constexpr auto loc_ = "detail::locale_ref";
};
struct format_arg_store_Reflection {
    static constexpr auto data_ = "int";
};
struct basic_format_args_Reflection {
    static constexpr auto desc_ = "unsigned long long";
    static constexpr auto  = "union fmt::basic_format_args::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1902:3)";
};
struct _Reflection {
    static constexpr auto values_ = "const detail::value<Context> *";
    static constexpr auto args_ = "const format_arg *";
};
struct fill_t_Reflection {
    static constexpr auto data_ = "Char[max_size]";
    static constexpr auto size_ = "unsigned char";
};
struct format_specs_Reflection {
    static constexpr auto width = "int";
    static constexpr auto precision = "int";
    static constexpr auto type = "presentation_type";
    static constexpr auto align = "align_t";
    static constexpr auto sign = "sign_t";
    static constexpr auto alt = "_Bool";
    static constexpr auto localized = "_Bool";
    static constexpr auto fill = "detail::fill_t<Char>";
};
struct arg_ref_Reflection {
    static constexpr auto kind = "arg_id_kind";
    static constexpr auto val = "union value";
};
struct value_Reflection {
    static constexpr auto index = "int";
    static constexpr auto name = "basic_string_view<Char>";
};
struct dynamic_format_specs_Reflection {
    static constexpr auto width_ref = "arg_ref<Char>";
    static constexpr auto precision_ref = "arg_ref<Char>";
};
struct dynamic_spec_id_handler_Reflection {
    static constexpr auto ctx = "basic_format_parse_context<Char> &";
    static constexpr auto ref = "arg_ref<Char> &";
};
struct _Reflection {
    static constexpr auto current_state = "state";
};
struct _Reflection {
    static constexpr auto begin = "const Char *&";
    static constexpr auto specs = "dynamic_format_specs<Char> &";
    static constexpr auto arg_type = "type";
};
struct id_adapter_Reflection {
    static constexpr auto handler = "Handler &";
    static constexpr auto arg_id = "int";
};
struct writer_Reflection {
    static constexpr auto handler_ = "Handler &";
};
struct strip_named_arg_Reflection {
};
struct strip_named_arg_Reflection {
};
struct format_string_checker_Reflection {
    static constexpr auto types_ = "type[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
    static constexpr auto context_ = "parse_context_type";
    static constexpr auto parse_funcs_ = "parse_func[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
};
struct vformat_args_Reflection {
};
struct vformat_args_Reflection {
};
struct runtime_format_string_Reflection {
    static constexpr auto str = "basic_string_view<Char>";
};
struct basic_format_string_Reflection {
    static constexpr auto str_ = "basic_string_view<Char>";
};
struct format_to_n_result_Reflection {
    static constexpr auto out = "OutputIt";
    static constexpr auto size = "size_t";
};
struct __uintr_frame_Reflection {
    static constexpr auto rip = "unsigned long long";
    static constexpr auto rflags = "unsigned long long";
    static constexpr auto rsp = "unsigned long long";
};
struct __mm_loadh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadh_pi_v2f32";
};
struct __mm_loadl_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadl_pi_v2f32";
};
struct __mm_load_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __mm_load1_ps_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_store_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_load1_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __loadu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __loadu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __loadu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_load_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadl_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_store_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __mm_loadl_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __storeu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __storeu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __storeu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_storel_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __mm_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __mm256_broadcast_sd_struct_Reflection {
    static constexpr auto __d = "double";
};
struct __mm256_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __loadu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __storeu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __mm_load_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __mm_store_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __loadu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __storeu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __loadu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __storeu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __loadu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __storeu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __tile1024i_str_Reflection {
    static constexpr auto row = "const unsigned short";
    static constexpr auto col = "const unsigned short";
    static constexpr auto tile = "_tile1024i";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __mm_store_sbh_struct_Reflection {
    static constexpr auto __u = "__bf16";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct string_literal_Reflection {
};
struct uint128_fallback_Reflection {
    static constexpr auto lo_ = "int";
    static constexpr auto hi_ = "int";
};
struct _Reflection {
    static constexpr auto  = "F";
};
struct count_code_points_Reflection {
    static constexpr auto count = "size_t *";
};
struct _Reflection {
    static constexpr auto  = "const char *";
    static constexpr auto  = "size_t &";
    static constexpr auto  = "size_t &";
};
struct is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_locale_Reflection {
};
struct basic_memory_buffer_Reflection {
    static constexpr auto store_ = "T[SIZE]";
    static constexpr auto alloc_ = "Allocator";
};
struct is_contiguous_Reflection {
};
struct format_error_Reflection {
};
struct loc_value_Reflection {
    static constexpr auto value_ = "int";
};
struct format_facet_Reflection {
    static constexpr auto separator_ = "int";
    static constexpr auto grouping_ = "int";
    static constexpr auto decimal_point_ = "int";
};
struct _Reflection {
};
struct thousands_sep_result_Reflection {
    static constexpr auto grouping = "int";
    static constexpr auto thousands_sep = "Char";
};
struct format_decimal_result_Reflection {
    static constexpr auto begin = "Iterator";
    static constexpr auto end = "Iterator";
};
struct utf8_to_utf16_Reflection {
    static constexpr auto buffer_ = "int";
};
struct to_utf8_Reflection {
    static constexpr auto buffer_ = "Buffer";
};
struct decimal_fp_Reflection {
    static constexpr auto significand = "int";
    static constexpr auto exponent = "int";
};
struct basic_fp_Reflection {
    static constexpr auto f = "F";
    static constexpr auto e = "int";
};
struct _Reflection {
};
struct find_escape_result_Reflection {
    static constexpr auto begin = "const Char *";
    static constexpr auto end = "const Char *";
    static constexpr auto cp = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct write_int_data_Reflection {
    static constexpr auto size = "size_t";
    static constexpr auto padding = "size_t";
};
struct _Reflection {
};
struct digit_grouping_Reflection {
    static constexpr auto grouping_ = "int";
    static constexpr auto thousands_sep_ = "int";
};
struct next_state_Reflection {
    static constexpr auto group = "int";
    static constexpr auto pos = "int";
};
struct write_int_arg_Reflection {
    static constexpr auto abs_value = "UInt";
    static constexpr auto prefix = "unsigned int";
};
struct loc_writer_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto sep = "int";
    static constexpr auto grouping = "int";
    static constexpr auto decimal_point = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct counting_iterator_Reflection {
    static constexpr auto count_ = "size_t";
};
struct value_type_Reflection {
};
struct _Reflection {
};
struct float_specs_Reflection {
    static constexpr auto precision = "int";
    static constexpr auto format = "float_format";
    static constexpr auto sign = "sign_t";
    static constexpr auto upper = "_Bool";
    static constexpr auto locale = "_Bool";
    static constexpr auto binary32 = "_Bool";
    static constexpr auto showpoint = "_Bool";
};
struct big_decimal_fp_Reflection {
    static constexpr auto significand = "const char *";
    static constexpr auto significand_size = "int";
    static constexpr auto exponent = "int";
};
struct fallback_digit_grouping_Reflection {
};
struct has_isfinite_Reflection {
};
struct bigint_Reflection {
    static constexpr auto bigits_ = "int";
    static constexpr auto exp_ = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct default_arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto args = "int";
    static constexpr auto loc = "locale_ref";
};
struct arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto locale = "locale_ref";
};
struct width_checker_Reflection {
};
struct precision_checker_Reflection {
};
struct udl_arg_Reflection {
    static constexpr auto str = "const Char *";
};
struct format_int_Reflection {
    static constexpr auto buffer_ = "char[0]";
    static constexpr auto str_ = "char *";
};
struct bytes_Reflection {
    static constexpr auto data_ = "string_view";
};
struct group_digits_view_Reflection {
    static constexpr auto value = "T";
};
struct nested_view_Reflection {
    static constexpr auto fmt = "const int *";
    static constexpr auto value = "const T *";
};
struct nested_formatter_Reflection {
    static constexpr auto width_ = "int";
    static constexpr auto fill_ = "detail::fill_t<char>";
    static constexpr auto align_ = "align_t";
    static constexpr auto formatter_ = "int";
};
struct join_view_Reflection {
    static constexpr auto begin = "It";
    static constexpr auto end = "Sentinel";
    static constexpr auto sep = "basic_string_view<Char>";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
    static constexpr auto divisor = "int";
    static constexpr auto shift_amount = "int";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct _Reflection {
    static constexpr auto  = "class fmt::detail::utf8_to_utf16 *";
};
struct singleton_Reflection {
    static constexpr auto upper = "unsigned char";
    static constexpr auto lower_count = "unsigned char";
};
struct is_convertible_to_basic_format_string_Reflection {
};
struct is_convertible_to_any_format_string_Reflection {
};
struct spdlog_ex_Reflection {
    static constexpr auto msg_ = "int";
};
struct source_loc_Reflection {
    static constexpr auto filename = "const char *";
    static constexpr auto line = "int";
    static constexpr auto funcname = "const char *";
};
struct file_event_handlers_Reflection {
    static constexpr auto before_open = "std::function<void (const int &)>";
    static constexpr auto after_open = "std::function<void (const int &, int *)>";
    static constexpr auto before_close = "std::function<void (const int &, int *)>";
    static constexpr auto after_close = "std::function<void (const int &)>";
};
struct condition_variable_any_Reflection {
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __mut_ = "shared_ptr<mutex>";
};
struct __unlock_guard_Reflection {
    static constexpr auto __lock_ = "_Lock &";
};
struct __thread_struct_Reflection {
    static constexpr auto __p_ = "__thread_struct_imp *";
};
struct __thread_specific_ptr_Reflection {
    static constexpr auto __key_ = "__libcpp_tls_key";
};
struct hash_Reflection {
};
struct thread_Reflection {
    static constexpr auto __t_ = "__libcpp_thread_t";
};
struct periodic_worker_Reflection {
    static constexpr auto active_ = "_Bool";
    static constexpr auto worker_thread_ = "std::thread";
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto cv_ = "std::condition_variable";
};
struct registry_Reflection {
    static constexpr auto logger_map_mutex_ = "std::mutex";
    static constexpr auto flusher_mutex_ = "std::mutex";
    static constexpr auto tp_mutex_ = "std::recursive_mutex";
    static constexpr auto log_levels_ = "int";
    static constexpr auto formatter_ = "int";
    static constexpr auto global_log_level_ = "spdlog::level::level_enum";
    static constexpr auto flush_level_ = "level::level_enum";
    static constexpr auto err_handler_ = "err_handler";
    static constexpr auto tp_ = "std::shared_ptr<thread_pool>";
    static constexpr auto periodic_flusher_ = "int";
    static constexpr auto default_logger_ = "std::shared_ptr<logger>";
    static constexpr auto automatic_registration_ = "_Bool";
    static constexpr auto backtrace_n_messages_ = "size_t";
};
struct circular_q_Reflection {
    static constexpr auto max_items_ = "size_t";
    static constexpr auto head_ = "int";
    static constexpr auto tail_ = "int";
    static constexpr auto overrun_counter_ = "size_t";
    static constexpr auto v_ = "int";
};
struct log_msg_Reflection {
    static constexpr auto logger_name = "string_view_t";
    static constexpr auto level = "level::level_enum";
    static constexpr auto time = "log_clock::time_point";
    static constexpr auto thread_id = "size_t";
    static constexpr auto color_range_start = "size_t";
    static constexpr auto color_range_end = "size_t";
    static constexpr auto source = "source_loc";
    static constexpr auto payload = "string_view_t";
};
struct log_msg_buffer_Reflection {
    static constexpr auto buffer = "int";
};
struct backtracer_Reflection {
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto enabled_ = "std::atomic<_Bool>";
    static constexpr auto messages_ = "circular_q<log_msg_buffer>";
};
struct logger_Reflection {
    static constexpr auto name_ = "int";
    static constexpr auto sinks_ = "int";
    static constexpr auto level_ = "spdlog::level_t";
    static constexpr auto flush_level_ = "spdlog::level_t";
    static constexpr auto custom_err_handler_ = "err_handler";
    static constexpr auto tracer_ = "details::backtracer";
};
struct formatter_Reflection {
};
struct padding_info_Reflection {
    static constexpr auto width_ = "size_t";
    static constexpr auto side_ = "pad_side";
    static constexpr auto truncate_ = "_Bool";
    static constexpr auto enabled_ = "_Bool";
};
struct flag_formatter_Reflection {
    static constexpr auto padinfo_ = "padding_info";
};
struct custom_flag_formatter_Reflection {
};
struct pattern_formatter_Reflection {
    static constexpr auto pattern_ = "int";
    static constexpr auto eol_ = "int";
    static constexpr auto pattern_time_type_ = "pattern_time_type";
    static constexpr auto need_localtime_ = "_Bool";
    static constexpr auto cached_tm_ = "int";
    static constexpr auto last_log_secs_ = "std::chrono::seconds";
    static constexpr auto formatters_ = "int";
    static constexpr auto custom_handlers_ = "int";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_node_base_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_node_types_Reflection {
};
struct __make_tree_node_types_Reflection {
};
struct __tree_end_node_Reflection {
    static constexpr auto __left_ = "pointer";
};
struct __tree_node_base_Reflection {
    static constexpr auto __right_ = "pointer";
    static constexpr auto __parent_ = "__parent_pointer";
    static constexpr auto __is_black_ = "_Bool";
};
struct __tree_node_Reflection {
    static constexpr auto __value_ = "__node_value_type";
};
struct __tree_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __tree_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_Reflection {
    static constexpr auto __begin_node_ = "__iter_pointer";
    static constexpr auto __end_node_ = "__end_node_t";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __value_comp_ = "value_compare";
};
struct _DetachedTreeCache_Reflection {
    static constexpr auto __t_ = "__tree<_Tp, _Compare, _Allocator> *";
    static constexpr auto __cache_root_ = "__node_pointer";
    static constexpr auto __cache_elem_ = "__node_pointer";
};
struct __map_value_compare_Reflection {
};
struct __map_value_compare_Reflection {
    static constexpr auto __comp_ = "_Compare";
};
struct __map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __extract_key_value_types_Reflection {
};
struct __map_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct __map_const_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct map_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct multimap_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct mdc_Reflection {
};
struct scoped_padder_Reflection {
    static constexpr auto padinfo_ = "const padding_info &";
    static constexpr auto dest_ = "int &";
    static constexpr auto remaining_pad_ = "long";
    static constexpr auto spaces_ = "string_view_t";
};
struct null_scoped_padder_Reflection {
};
struct name_formatter_Reflection {
};
struct level_formatter_Reflection {
};
struct short_level_formatter_Reflection {
};
struct a_formatter_Reflection {
};
struct A_formatter_Reflection {
};
struct b_formatter_Reflection {
};
struct B_formatter_Reflection {
};
struct c_formatter_Reflection {
};
struct C_formatter_Reflection {
};
struct D_formatter_Reflection {
};
struct Y_formatter_Reflection {
};
struct m_formatter_Reflection {
};
struct d_formatter_Reflection {
};
struct H_formatter_Reflection {
};
struct I_formatter_Reflection {
};
struct M_formatter_Reflection {
};
struct S_formatter_Reflection {
};
struct e_formatter_Reflection {
};
struct f_formatter_Reflection {
};
struct F_formatter_Reflection {
};
struct E_formatter_Reflection {
};
struct p_formatter_Reflection {
};
struct r_formatter_Reflection {
};
struct R_formatter_Reflection {
};
struct T_formatter_Reflection {
};
struct z_formatter_Reflection {
    static constexpr auto last_update_ = "log_clock::time_point";
    static constexpr auto offset_minutes_ = "int";
};
struct t_formatter_Reflection {
};
struct pid_formatter_Reflection {
};
struct v_formatter_Reflection {
};
struct ch_formatter_Reflection {
    static constexpr auto ch_ = "char";
};
struct aggregate_formatter_Reflection {
    static constexpr auto str_ = "int";
};
struct color_start_formatter_Reflection {
};
struct color_stop_formatter_Reflection {
};
struct source_location_formatter_Reflection {
};
struct source_filename_formatter_Reflection {
};
struct short_filename_formatter_Reflection {
};
struct source_linenum_formatter_Reflection {
};
struct source_funcname_formatter_Reflection {
};
struct elapsed_formatter_Reflection {
    static constexpr auto last_message_time_ = "log_clock::time_point";
};
struct mdc_formatter_Reflection {
};
struct full_formatter_Reflection {
    static constexpr auto cache_timestamp_ = "std::chrono::seconds";
    static constexpr auto cached_datetime_ = "int";
    static constexpr auto mdc_formatter_ = "mdc_formatter<null_scoped_padder>";
};
struct sink_Reflection {
    static constexpr auto level_ = "level_t";
};
struct console_mutex_Reflection {
};
struct console_nullmutex_Reflection {
};
struct wincolor_sink_Reflection {
    static constexpr auto out_handle_ = "void *";
    static constexpr auto mutex_ = "mutex_t &";
    static constexpr auto should_do_colors_ = "_Bool";
    static constexpr auto formatter_ = "int";
    static constexpr auto colors_ = "std::array<int, level::n_levels>";
};
struct wincolor_stdout_sink_Reflection {
};
struct wincolor_stderr_sink_Reflection {
};
struct synchronous_factory_Reflection {
};
struct file_helper_Reflection {
    static constexpr auto open_tries_ = "const int";
    static constexpr auto open_interval_ = "const unsigned int";
    static constexpr auto fd_ = "int *";
    static constexpr auto filename_ = "int";
    static constexpr auto event_handlers_ = "file_event_handlers";
};
struct base_sink_Reflection {
    static constexpr auto formatter_ = "int";
    static constexpr auto mutex_ = "Mutex";
};
struct basic_file_sink_Reflection {
    static constexpr auto file_helper_ = "details::file_helper";
};
struct __iom_t1_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t2_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t3_Reflection {
    static constexpr auto __base_ = "int";
};
struct __iom_t4_Reflection {
    static constexpr auto __fill_ = "_CharT";
};
struct __iom_t5_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t6_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t7_Reflection {
    static constexpr auto __mon_ = "_MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t8_Reflection {
    static constexpr auto __mon_ = "const _MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t9_Reflection {
    static constexpr auto __tm_ = "int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __iom_t10_Reflection {
    static constexpr auto __tm_ = "const int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __quoted_output_proxy_Reflection {
    static constexpr auto __first_ = "const _CharT *";
    static constexpr auto __last_ = "const _CharT *";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __quoted_proxy_Reflection {
    static constexpr auto __string_ = "basic_string<_CharT, _Traits, _Allocator> &";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct _NullSentinel_Reflection {
};
struct __is_pathable_string_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_iter_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct path_Reflection {
    static constexpr auto __pn_ = "string_type";
};
struct basic_filebuf_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __file_ = "int *";
    static constexpr auto __cv_ = "const codecvt<char_type, char, state_type> *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __st_last_ = "state_type";
    static constexpr auto __om_ = "class ios_base::openmode";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ifstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_ofstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_fstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct file_status_Reflection {
    static constexpr auto __ft_ = "file_type";
    static constexpr auto __prms_ = "perms";
};
struct space_info_Reflection {
    static constexpr auto capacity = "int";
    static constexpr auto free = "int";
    static constexpr auto available = "int";
};
struct directory_entry_Reflection {
    static constexpr auto __p_ = "_Path";
    static constexpr auto __data_ = "__cached_data";
};
struct __cached_data_Reflection {
    static constexpr auto __size_ = "int";
    static constexpr auto __nlink_ = "int";
    static constexpr auto __write_time_ = "file_time_type";
    static constexpr auto __sym_perms_ = "perms";
    static constexpr auto __non_sym_perms_ = "perms";
    static constexpr auto __type_ = "file_type";
    static constexpr auto __cache_type_ = "_CacheType";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct __dir_element_proxy_Reflection {
    static constexpr auto __elem_ = "directory_entry";
};
struct directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__dir_stream>";
};
struct iterator_Reflection {
    static constexpr auto __stashed_elem_ = "path";
    static constexpr auto __path_ptr_ = "const path *";
    static constexpr auto __entry_ = "class path::__string_view";
    static constexpr auto __state_ = "_ParserState";
};
struct recursive_directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__shared_imp>";
    static constexpr auto __rec_ = "_Bool";
};
struct formatbuf_Reflection {
    static constexpr auto buffer_ = "buffer<char_type> &";
};
struct file_access_tag_Reflection {
};
struct file_access_Reflection {
};
struct streamed_view_Reflection {
    static constexpr auto value = "const T &";
};
struct basic_ostream_formatter_Reflection {
};
struct Logger_Reflection {
};
struct RenderContext_Reflection {
};
struct OpenGLContext_Reflection {
    static constexpr auto m_WindowHandle = "GLFWwindow *";
};
struct Input_Reflection {
};
struct WindowsInput_Reflection {
};
struct fpos_Reflection {
    static constexpr auto __st_ = "_StateT";
    static constexpr auto __off_ = "streamoff";
};
struct enable_if_Reflection {
};
struct enable_if_Reflection {
};
struct integral_constant_Reflection {
};
struct remove_cv_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct __equal_tag_Reflection {
};
struct __plus_tag_Reflection {
};
struct __totally_ordered_less_tag_Reflection {
};
struct __equal_to_Reflection {
};
struct __less_Reflection {
};
struct __less_Reflection {
};
struct __debug_less_Reflection {
    static constexpr auto __comp_ = "_Compare &";
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct is_floating_point_Reflection {
};
struct is_arithmetic_Reflection {
};
struct is_signed_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct is_convertible_Reflection {
};
struct is_function_Reflection {
};
struct is_reference_Reflection {
};
struct is_lvalue_reference_Reflection {
};
struct is_rvalue_reference_Reflection {
};
struct remove_all_extents_Reflection {
};
struct is_destructible_Reflection {
};
struct is_nothrow_destructible_Reflection {
};
struct is_same_Reflection {
};
struct __libcpp_is_referenceable_Reflection {
};
struct add_lvalue_reference_Reflection {
};
struct add_rvalue_reference_Reflection {
};
struct is_constructible_Reflection {
};
struct is_copy_constructible_Reflection {
};
struct is_move_constructible_Reflection {
};
struct is_default_constructible_Reflection {
};
struct _IfImpl_Reflection {
};
struct _IfImpl_Reflection {
};
struct conditional_Reflection {
};
struct conditional_Reflection {
};
struct is_void_Reflection {
};
struct remove_reference_Reflection {
};
struct add_pointer_Reflection {
};
struct is_array_Reflection {
};
struct remove_extent_Reflection {
};
struct decay_Reflection {
};
struct __type_identity_Reflection {
};
struct __empty_Reflection {
};
struct common_type_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct is_class_Reflection {
};
struct is_enum_Reflection {
};
struct is_union_Reflection {
};
struct extent_Reflection {
};
struct is_nothrow_assignable_Reflection {
};
struct is_nothrow_copy_assignable_Reflection {
};
struct is_nothrow_move_assignable_Reflection {
};
struct is_nothrow_constructible_Reflection {
};
struct is_nothrow_copy_constructible_Reflection {
};
struct is_nothrow_move_constructible_Reflection {
};
struct is_nothrow_default_constructible_Reflection {
};
struct is_assignable_Reflection {
};
struct is_copy_assignable_Reflection {
};
struct is_move_assignable_Reflection {
};
struct is_swappable_with_Reflection {
};
struct is_swappable_Reflection {
};
struct is_nothrow_swappable_with_Reflection {
};
struct is_nothrow_swappable_Reflection {
};
struct is_object_Reflection {
};
struct __nat_Reflection {
};
struct __type_list_Reflection {
};
struct __find_first_Reflection {
};
struct __find_first_Reflection {
};
struct make_signed_Reflection {
};
struct _OrImpl_Reflection {
};
struct _OrImpl_Reflection {
};
struct disjunction_Reflection {
};
struct remove_const_Reflection {
};
struct input_iterator_tag_Reflection {
};
struct output_iterator_tag_Reflection {
};
struct forward_iterator_tag_Reflection {
};
struct bidirectional_iterator_tag_Reflection {
};
struct random_access_iterator_tag_Reflection {
};
struct __iter_traits_cache_Reflection {
};
struct __iter_concept_concept_test_Reflection {
};
struct __iter_concept_category_test_Reflection {
};
struct __iter_concept_random_fallback_Reflection {
};
struct __test_iter_concept_Reflection {
};
struct __iter_concept_cache_Reflection {
};
struct __has_iterator_typedefs_Reflection {
};
struct __has_iterator_category_Reflection {
};
struct __has_iterator_concept_Reflection {
};
struct __iterator_traits_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __is_callable_Reflection {
};
struct initializer_list_Reflection {
    static constexpr auto __begin_ = "const _Ep *";
    static constexpr auto __size_ = "size_t";
};
struct __is_identity_Reflection {
};
struct __identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct is_base_of_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct is_member_pointer_Reflection {
};
struct is_member_object_pointer_Reflection {
};
struct is_member_function_pointer_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __invokable_r_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __invoke_of_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct is_invocable_Reflection {
};
struct is_invocable_r_Reflection {
};
struct is_nothrow_invocable_Reflection {
};
struct is_nothrow_invocable_r_Reflection {
};
struct invoke_result_Reflection {
};
struct __has_specialization_Reflection {
};
struct __has_specialization_Reflection {
};
struct __all_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct __has_pointer_Reflection {
};
struct __has_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __has_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __has_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_impl_Reflection {
};
struct pointer_traits_Reflection {
};
struct pointer_traits_Reflection {
};
struct __nat_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasArrow_Reflection {
};
struct _HasArrow_Reflection {
};
struct _IsFancyPointer_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct add_const_Reflection {
};
struct add_cv_Reflection {
};
struct add_volatile_Reflection {
};
struct __align_type_Reflection {
};
struct __struct_double_Reflection {
    static constexpr auto __lx = "long double";
};
struct __struct_double4_Reflection {
    static constexpr auto __lx = "double[4]";
};
struct __fallback_overaligned_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_max_align_Reflection {
};
struct __select_align_Reflection {
};
struct __find_max_align_Reflection {
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __align = "_Aligner";
    static constexpr auto __data = "unsigned char[(_Len + _Align - 1) / _Align * _Align]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1 - 1) / 1 * 1]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2 - 1) / 2 * 2]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4 - 1) / 4 * 4]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8 - 1) / 8 * 8]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 16 - 1) / 16 * 16]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 32 - 1) / 32 * 32]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 64 - 1) / 64 * 64]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 128 - 1) / 128 * 128]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 256 - 1) / 256 * 256]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 512 - 1) / 512 * 512]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1024 - 1) / 1024 * 1024]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2048 - 1) / 2048 * 2048]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4096 - 1) / 4096 * 4096]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8192 - 1) / 8192 * 8192]";
};
struct __static_max_Reflection {
};
struct __static_max_Reflection {
};
struct aligned_union_Reflection {
};
struct alignment_of_Reflection {
};
struct has_virtual_destructor_Reflection {
};
struct is_abstract_Reflection {
};
struct is_null_pointer_Reflection {
};
struct is_fundamental_Reflection {
};
struct is_compound_Reflection {
};
struct is_const_Reflection {
};
struct is_empty_Reflection {
};
struct is_literal_type_Reflection {
};
struct is_pod_Reflection {
};
struct is_pointer_Reflection {
};
struct is_polymorphic_Reflection {
};
struct is_scalar_Reflection {
};
struct is_standard_layout_Reflection {
};
struct is_trivial_Reflection {
};
struct is_trivially_assignable_Reflection {
};
struct is_trivially_copy_assignable_Reflection {
};
struct is_trivially_move_assignable_Reflection {
};
struct is_trivially_constructible_Reflection {
};
struct is_trivially_copy_constructible_Reflection {
};
struct is_trivially_move_constructible_Reflection {
};
struct is_trivially_default_constructible_Reflection {
};
struct is_trivially_copyable_Reflection {
};
struct is_trivially_destructible_Reflection {
};
struct is_unsigned_Reflection {
};
struct is_volatile_Reflection {
};
struct make_unsigned_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct remove_pointer_Reflection {
};
struct remove_volatile_Reflection {
};
struct result_of_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct underlying_type_Reflection {
};
struct __libcpp_is_final_Reflection {
};
struct is_final_Reflection {
};
struct has_unique_object_representations_Reflection {
};
struct is_aggregate_Reflection {
};
struct _Not_Reflection {
};
struct negation_Reflection {
};
struct _FirstPaddingByte_Reflection {
    static constexpr auto __v_ = "_Tp";
    static constexpr auto __first_padding_byte_ = "char";
};
struct __is_always_bitcastable_Reflection {
};
struct __is_equality_comparable_Reflection {
};
struct __libcpp_is_trivially_equality_comparable_impl_Reflection {
};
struct __is_less_than_comparable_Reflection {
};
struct __find_segment_Reflection {
    static constexpr auto __value_ = "const _Tp &";
};
struct __unary_function_keep_layout_base_Reflection {
};
struct __integer_sequence_Reflection {
};
struct integer_sequence_Reflection {
};
struct __tuple_indices_Reflection {
};
struct __make_tuple_indices_Reflection {
};
struct __tuple_types_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_size_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_sfinae_base_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct tuple_element_Reflection {
};
struct __check_tuple_constructor_fail_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __libcpp_is_trivially_relocatable_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_ref_decay_Reflection {
};
struct piecewise_construct_t_Reflection {
};
struct __non_trivially_copyable_base_Reflection {
};
struct pair_Reflection {
    static constexpr auto first = "_T1";
    static constexpr auto second = "_T2";
};
struct _CheckArgs_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct __get_pair_Reflection {
};
struct __get_pair_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct _PairT_Reflection {
    static constexpr auto first = "size_t";
    static constexpr auto second = "size_t";
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct _Reflection {
    static constexpr auto __t = "long double";
    static constexpr auto __s = "struct (unnamed struct at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__functional\hash.h:476:7)";
};
struct _Reflection {
    static constexpr auto __a = "size_t";
    static constexpr auto __b = "size_t";
};
struct __enum_hash_Reflection {
};
struct __enum_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __bounded_iter_Reflection {
    static constexpr auto __current_ = "_Iterator";
    static constexpr auto __begin_ = "_Iterator";
    static constexpr auto __end_ = "_Iterator";
};
struct __sfinae_underlying_type_Reflection {
};
struct __sfinae_underlying_type_Reflection {
};
struct iterator_Reflection {
};
struct reverse_iterator_Reflection {
    static constexpr auto __t_ = "_Iter";
    static constexpr auto current = "_Iter";
};
struct __unwrap_iter_impl_Reflection {
};
struct __wrap_iter_Reflection {
    static constexpr auto __i_ = "iterator_type";
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct pointer_traits_Reflection {
};
struct __pointer_Reflection {
};
struct __pointer_Reflection {
};
struct __has_const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __has_void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __has_const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __has_size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __has_alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __has_propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __has_propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __has_propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __has_is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __has_rebind_other_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct allocator_traits_Reflection {
};
struct __check_valid_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_cpp17_move_insertable_Reflection {
};
struct __is_cpp17_copy_insertable_Reflection {
};
struct __allocation_result_Reflection {
    static constexpr auto ptr = "_Pointer";
    static constexpr auto count = "size_t";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __noexcept_move_assign_container_Reflection {
};
struct memory_resource_Reflection {
};
struct __exception_guard_exceptions_Reflection {
    static constexpr auto __rollback_ = "_Rollback";
    static constexpr auto __completed_ = "_Bool";
};
struct __exception_guard_noexceptions_Reflection {
    static constexpr auto __completed_ = "_Bool";
};
struct __has_allocator_type_Reflection {
};
struct __uses_allocator_Reflection {
};
struct __uses_allocator_Reflection {
};
struct uses_allocator_Reflection {
};
struct allocator_arg_t_Reflection {
};
struct __uses_alloc_ctor_imp_Reflection {
};
struct __uses_alloc_ctor_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_t_Reflection {
};
struct __ignore_type_Reflection {
};
struct _Lazy_Reflection {
};
struct __promote_Reflection {
};
struct __tuple_leaf_Reflection {
    static constexpr auto __value_ = "_Hp";
};
struct __tuple_leaf_Reflection {
};
struct __all_default_constructible_Reflection {
};
struct __tuple_impl_Reflection {
};
struct tuple_Reflection {
    static constexpr auto __base_ = "_BaseT";
};
struct _IsThisTuple_Reflection {
};
struct _EnableUTypesCtor_Reflection {
};
struct _EnableCtorFromUTypesTuple_Reflection {
};
struct _CtorPredicateFromPair_Reflection {
};
struct _EnableCtorFromPair_Reflection {
};
struct _NothrowConstructibleFromPair_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _AssignPredicateFromPair_Reflection {
};
struct _EnableAssignFromPair_Reflection {
};
struct _NothrowAssignFromPair_Reflection {
};
struct tuple_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_cat_type_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_Reflection {
};
struct __tuple_cat_Reflection {
};
struct uses_allocator_Reflection {
};
struct bad_cast_Reflection {
};
struct bad_typeid_Reflection {
};
struct exception_ptr_Reflection {
    static constexpr auto __ptr1_ = "void *";
    static constexpr auto __ptr2_ = "void *";
};
struct nested_exception_Reflection {
    static constexpr auto __ptr_ = "exception_ptr";
};
struct __nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __can_dynamic_cast_Reflection {
};
struct __save_flags_Reflection {
    static constexpr auto __stream_ = "__stream_type &";
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __fill_ = "_CharT";
};
struct in_place_t_Reflection {
};
struct in_place_type_t_Reflection {
};
struct in_place_index_t_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct polymorphic_allocator_Reflection {
    static constexpr auto __res_ = "memory_resource *";
};
struct _ClassicAlgPolicy_Reflection {
};
struct _IterOps_Reflection {
};
struct char_traits_Reflection {
};
struct __char_traits_base_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct __is_allocator_Reflection {
};
struct logic_error_Reflection {
};
struct runtime_error_Reflection {
};
struct domain_error_Reflection {
};
struct invalid_argument_Reflection {
};
struct length_error_Reflection {
};
struct out_of_range_Reflection {
};
struct range_error_Reflection {
};
struct overflow_error_Reflection {
};
struct underflow_error_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto __data_ = "const value_type *";
    static constexpr auto __size_ = "size_type";
};
struct __assume_valid_Reflection {
};
struct __string_view_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __can_lower_copy_assignment_to_memmove_Reflection {
};
struct __can_lower_move_assignment_to_memmove_Reflection {
};
struct __can_rewrap_Reflection {
};
struct __copy_impl_Reflection {
};
struct _CopySegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __copy_backward_impl_Reflection {
};
struct nullopt_t_Reflection {
};
struct __secret_tag_Reflection {
};
struct __optional_construct_from_invoke_tag_Reflection {
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_storage_base_Reflection {
};
struct __optional_storage_base_Reflection {
    static constexpr auto __value_ = "int *";
};
struct __optional_copy_base_Reflection {
};
struct __optional_copy_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __is_std_optional_Reflection {
};
struct __is_std_optional_Reflection {
};
struct optional_Reflection {
};
struct _CheckOptionalArgsConstructor_Reflection {
};
struct _CheckOptionalLikeConstructor_Reflection {
};
struct __cxx_atomic_base_impl_Reflection {
    static constexpr auto __a_value = "_Atomic(_Tp)";
};
struct __cxx_atomic_impl_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_lcm_Reflection {
};
struct __static_abs_Reflection {
};
struct __static_sign_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_div_Reflection {
};
struct ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __ratio_multiply_Reflection {
};
struct __ratio_divide_Reflection {
};
struct __ratio_add_Reflection {
};
struct __ratio_subtract_Reflection {
};
struct ratio_equal_Reflection {
};
struct ratio_not_equal_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct ratio_less_Reflection {
};
struct ratio_less_equal_Reflection {
};
struct ratio_greater_Reflection {
};
struct ratio_greater_equal_Reflection {
};
struct __ratio_gcd_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct common_type_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct treat_as_floating_point_Reflection {
};
struct duration_values_Reflection {
};
struct duration_Reflection {
    static constexpr auto __rep_ = "rep";
};
struct __no_overflow_Reflection {
};
struct __mul_Reflection {
};
struct __mul_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_lt_Reflection {
};
struct __duration_lt_Reflection {
};
struct time_point_Reflection {
    static constexpr auto __d_ = "duration";
};
struct common_type_Reflection {
};
struct steady_clock_Reflection {
};
struct system_clock_Reflection {
};
struct __spinning_backoff_policy_Reflection {
};
struct __atomic_waitable_traits_Reflection {
};
struct __atomic_waitable_Reflection {
};
struct __atomic_wait_poll_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_wait_backoff_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_compare_unequal_to_Reflection {
    static constexpr auto __val_ = "_Tp";
};
struct __libcpp_is_always_lock_free_Reflection {
};
struct __atomic_base_Reflection {
    static constexpr auto __a_ = "int";
};
struct __atomic_base_Reflection {
};
struct __binary_function_keep_layout_base_Reflection {
};
struct plus_Reflection {
};
struct plus_Reflection {
};
struct minus_Reflection {
};
struct minus_Reflection {
};
struct multiplies_Reflection {
};
struct multiplies_Reflection {
};
struct divides_Reflection {
};
struct divides_Reflection {
};
struct modulus_Reflection {
};
struct modulus_Reflection {
};
struct negate_Reflection {
};
struct negate_Reflection {
};
struct bit_and_Reflection {
};
struct bit_and_Reflection {
};
struct bit_not_Reflection {
};
struct bit_not_Reflection {
};
struct bit_or_Reflection {
};
struct bit_or_Reflection {
};
struct bit_xor_Reflection {
};
struct bit_xor_Reflection {
};
struct equal_to_Reflection {
};
struct equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct less_Reflection {
};
struct less_Reflection {
};
struct less_equal_Reflection {
};
struct less_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_Reflection {
};
struct greater_Reflection {
};
struct logical_and_Reflection {
};
struct logical_and_Reflection {
};
struct logical_not_Reflection {
};
struct logical_not_Reflection {
};
struct logical_or_Reflection {
};
struct logical_or_Reflection {
};
struct atomic_Reflection {
};
struct atomic_Reflection {
};
struct atomic_flag_Reflection {
    static constexpr auto __a_ = "int";
};
struct back_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct front_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
    static constexpr auto iter = "int";
};
struct istream_iterator_Reflection {
    static constexpr auto __in_stream_ = "istream_type *";
    static constexpr auto __value_ = "_Tp";
};
struct istreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __proxy_Reflection {
    static constexpr auto __keep_ = "char_type";
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct move_iterator_Reflection {
    static constexpr auto __current_ = "_Iter";
};
struct ostream_iterator_Reflection {
    static constexpr auto __out_stream_ = "ostream_type *";
    static constexpr auto __delim_ = "const char_type *";
};
struct ostreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __dependent_type_Reflection {
};
struct monostate_Reflection {
};
struct hash_Reflection {
};
struct __farray_Reflection {
    static constexpr auto __buf_ = "_Tp[_Size]";
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_Reflection {
};
struct __valueless_t_Reflection {
};
struct __traits_Reflection {
};
struct __union_Reflection {
};
struct __base_Reflection {
};
struct __variant_Reflection {
};
struct __base_Reflection {
};
struct __dispatcher_Reflection {
};
struct __variant_Reflection {
};
struct __value_visitor_Reflection {
    static constexpr auto __visitor = "_Visitor &&";
};
struct __alt_Reflection {
    static constexpr auto __value = "__value_type";
};
struct __union_Reflection {
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_TriviallyAvailable, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Available, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Unavailable, _Index + 1, _Types...>";
};
struct __base_Reflection {
    static constexpr auto __data = "__union<_DestructibleTrait, 0, _Types...>";
    static constexpr auto __index = "int";
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __ctor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __impl_Reflection {
};
struct __no_narrowing_check_Reflection {
};
struct __narrowing_check_Reflection {
};
struct __overload_Reflection {
};
struct __all_overloads_Reflection {
};
struct __make_overloads_imp_Reflection {
};
struct variant_Reflection {
    static constexpr auto __impl_ = "__variant_detail::__impl<_Types...>";
};
struct __convert_to_bool_Reflection {
};
struct __has_result_type_Reflection {
};
struct __derives_from_unary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __derives_from_binary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct reference_wrapper_Reflection {
    static constexpr auto __f_ = "type *";
};
struct __allocation_guard_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __n_ = "_Size";
    static constexpr auto __ptr_ = "_Pointer";
};
struct __allocator_destructor_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __s_ = "size_type";
};
struct __move_impl_Reflection {
};
struct _MoveSegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __always_false_Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _AllocatorDestroyRangeReverse_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __first_ = "_Iter &";
    static constexpr auto __last_ = "_Iter &";
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __has_array_cookie_Reflection {
};
struct __private_constructor_tag_Reflection {
};
struct default_delete_Reflection {
};
struct default_delete_Reflection {
};
struct _EnableIfConvertible_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
};
struct __unique_ptr_array_bounds_stateless_Reflection {
};
struct __unique_ptr_array_bounds_stored_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
    static constexpr auto __checker_ = "_BoundsChecker";
};
struct _CheckArrayPointerConversion_Reflection {
};
struct _CheckArrayPointerConversion_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct bad_weak_ptr_Reflection {
};
struct __shared_count_Reflection {
    static constexpr auto __shared_owners_ = "long";
};
struct __shared_weak_count_Reflection {
    static constexpr auto __shared_weak_owners_ = "long";
};
struct __shared_ptr_pointer_Reflection {
    static constexpr auto __ptr_ = "_Tp";
    static constexpr auto __deleter_ = "_Dp";
    static constexpr auto __alloc_ = "_Alloc";
};
struct __for_overwrite_tag_Reflection {
};
struct __shared_ptr_emplace_Reflection {
    static constexpr auto __storage_ = "_Storage";
};
struct _Storage_Reflection {
    static constexpr auto __buffer_ = "char[sizeof(_Data)]";
};
struct _Data_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __elem_ = "int";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __compatible_with_Reflection {
};
struct __raw_pointer_compatible_with_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __well_formed_deleter_Reflection {
};
struct __shared_ptr_deleter_ctor_reqs_Reflection {
};
struct shared_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct __nullptr_sfinae_tag_Reflection {
};
struct __shared_ptr_default_allocator_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __sp_aligned_storage_Reflection {
    static constexpr auto __storage = "char[_Alignment]";
};
struct __unbounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __count_ = "size_t";
    static constexpr auto  = "union std::__unbounded_array_control_block<type-parameter-0-0[], type-parameter-0-1>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:952:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct __bounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto  = "union std::__bounded_array_control_block<type-parameter-0-0[_Np], type-parameter-0-2>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:1030:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[_Count]";
};
struct weak_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct enable_shared_from_this_Reflection {
    static constexpr auto __weak_this_ = "weak_ptr<_Tp>";
};
struct hash_Reflection {
};
struct __sp_mut_Reflection {
    static constexpr auto __lx_ = "void *";
};
struct raw_storage_iterator_Reflection {
    static constexpr auto __x_ = "_OutputIterator";
};
struct __temporary_buffer_deleter_Reflection {
    static constexpr auto __count_ = "ptrdiff_t";
};
struct __move_backward_impl_Reflection {
};
struct __destruct_n_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct __invert_Reflection {
    static constexpr auto __p_ = "_Predicate";
};
struct _ConstTimeDistance_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct _Reflection {
};
struct __aliasing_iterator_wrapper_Reflection {
};
struct __iterator_Reflection {
    static constexpr auto __base_ = "_BaseIter";
};
struct _MinmaxElementLessFunc_Reflection {
    static constexpr auto __comp_ = "_Comp &";
    static constexpr auto __proj_ = "_Proj &";
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct _ProjectedPred_Reflection {
    static constexpr auto __pred = "_Pred &";
    static constexpr auto __proj = "_Proj &";
};
struct __set_intersection_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_symmetric_difference_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_union_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_urng_Reflection {
};
struct __log2_Reflection {
};
struct __independent_bits_engine_Reflection {
    static constexpr auto __e_ = "_Engine &";
    static constexpr auto __w_ = "size_t";
    static constexpr auto __w0_ = "size_t";
    static constexpr auto __n_ = "size_t";
    static constexpr auto __n0_ = "size_t";
    static constexpr auto __y0_ = "_Working_result_type";
    static constexpr auto __y1_ = "_Working_result_type";
    static constexpr auto __mask0_ = "_Engine_result_type";
    static constexpr auto __mask1_ = "_Engine_result_type";
};
struct uniform_int_distribution_Reflection {
    static constexpr auto __p_ = "param_type";
};
struct param_type_Reflection {
    static constexpr auto __a_ = "result_type";
    static constexpr auto __b_ = "result_type";
};
struct __libcpp_debug_randomizer_Reflection {
    static constexpr auto __state_ = "int";
    static constexpr auto __inc_ = "int";
};
struct __stable_sort_switch_Reflection {
};
struct __reread_from_input_tag_Reflection {
};
struct __reread_from_output_tag_Reflection {
};
struct __read_from_tmp_value_tag_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __can_be_converted_to_string_view_Reflection {
};
struct __uninitialized_size_tag_Reflection {
};
struct __init_with_sentinel_tag_Reflection {
};
struct __padding_Reflection {
    static constexpr auto __padding_ = "char[_PaddingSize]";
};
struct __padding_Reflection {
};
struct basic_string_Reflection {
    static constexpr auto __rep_ = "__rep";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __long_Reflection {
    static constexpr auto  = "struct std::basic_string::__long::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:902:5)";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __data_ = "pointer";
};
struct _Reflection {
    static constexpr auto __is_long_ = "size_type";
    static constexpr auto __cap_ = "size_type";
};
struct __short_Reflection {
    static constexpr auto  = "struct std::basic_string::__short::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:913:5)";
    static constexpr auto __padding_ = "__padding<sizeof(value_type) - 1>";
    static constexpr auto __data_ = "value_type[__min_cap]";
};
struct _Reflection {
    static constexpr auto __is_long_ = "unsigned char";
    static constexpr auto __size_ = "unsigned char";
};
struct __rep_Reflection {
    static constexpr auto __s = "__short";
    static constexpr auto __l = "__long";
};
struct __string_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __lconv_storage_Reflection {
    static constexpr auto __lc_ = "int";
    static constexpr auto __decimal_point_ = "int";
    static constexpr auto __thousands_sep_ = "int";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __int_curr_symbol_ = "int";
    static constexpr auto __currency_symbol_ = "int";
    static constexpr auto __mon_decimal_point_ = "int";
    static constexpr auto __mon_thousands_sep_ = "int";
    static constexpr auto __mon_grouping_ = "int";
    static constexpr auto __positive_sign_ = "int";
    static constexpr auto __negative_sign_ = "int";
};
struct locale_t_Reflection {
    static constexpr auto __locale_str_ = "const char *";
    static constexpr auto __lc_ = "__lconv_storage *";
};
struct once_flag_Reflection {
    static constexpr auto __state_ = "_State_type";
};
struct __call_once_param_Reflection {
    static constexpr auto __f_ = "_Fp &";
};
struct __uninitialized_tag_Reflection {
};
struct __no_destroy_Reflection {
    static constexpr auto __obj_ = "char[sizeof(_Tp)]";
};
struct locale_Reflection {
    static constexpr auto __locale_ = "__imp *";
};
struct facet_Reflection {
};
struct id_Reflection {
    static constexpr auto __flag_ = "once_flag";
    static constexpr auto __id_ = "int";
};
struct collate_Reflection {
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_base_Reflection {
};
struct ctype_Reflection {
};
struct ctype_Reflection {
    static constexpr auto __tab_ = "const mask *";
    static constexpr auto __del_ = "_Bool";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_base_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_byname_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_byname_Reflection {
};
struct numpunct_byname_Reflection {
};
struct error_category_Reflection {
};
struct __do_message_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct error_condition_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct is_error_code_enum_Reflection {
};
struct error_code_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct system_error_Reflection {
    static constexpr auto __ec_ = "error_code";
};
struct ios_base_Reflection {
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __precision_ = "streamsize";
    static constexpr auto __width_ = "streamsize";
    static constexpr auto __rdstate_ = "iostate";
    static constexpr auto __exceptions_ = "iostate";
    static constexpr auto __rdbuf_ = "void *";
    static constexpr auto __loc_ = "void *";
    static constexpr auto __fn_ = "event_callback *";
    static constexpr auto __index_ = "int *";
    static constexpr auto __event_size_ = "size_t";
    static constexpr auto __event_cap_ = "size_t";
    static constexpr auto __iarray_ = "long *";
    static constexpr auto __iarray_size_ = "size_t";
    static constexpr auto __iarray_cap_ = "size_t";
    static constexpr auto __parray_ = "void **";
    static constexpr auto __parray_size_ = "size_t";
    static constexpr auto __parray_cap_ = "size_t";
};
struct is_error_code_enum_Reflection {
};
struct failure_Reflection {
};
struct Init_Reflection {
};
struct _FillHelper_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
    static constexpr auto __set_ = "_Bool";
};
struct _SentinelValueFill_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
};
struct basic_ios_Reflection {
    static constexpr auto __tie_ = "basic_ostream<char_type, traits_type> *";
    static constexpr auto __fill_ = "_FillType";
};
struct mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_mutex_t";
};
struct defer_lock_t_Reflection {
};
struct try_to_lock_t_Reflection {
};
struct adopt_lock_t_Reflection {
};
struct unique_lock_Reflection {
    static constexpr auto __m_ = "mutex_type *";
    static constexpr auto __owns_ = "_Bool";
};
struct condition_variable_Reflection {
    static constexpr auto __cv_ = "__libcpp_condvar_t";
};
struct lock_guard_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct __thread_id_Reflection {
    static constexpr auto __id_ = "__libcpp_thread_id";
};
struct recursive_mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_recursive_mutex_t";
};
struct timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __locked_ = "_Bool";
};
struct recursive_timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __count_ = "size_t";
    static constexpr auto __id_ = "__thread_id";
};
struct scoped_lock_Reflection {
};
struct scoped_lock_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct scoped_lock_Reflection {
    static constexpr auto __t_ = "_MutexTuple";
};
struct __has_storage_type_Reflection {
};
struct __bit_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_reference_Reflection {
};
struct __bit_const_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_array_Reflection {
    static constexpr auto __size_ = "difference_type";
    static constexpr auto __word_ = "__storage_type[4]";
};
struct __bit_iterator_Reflection {
    static constexpr auto __seg_ = "int";
    static constexpr auto __ctz_ = "unsigned int";
};
struct __has_storage_type_Reflection {
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type[_N_words]";
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type";
};
struct __bitset_Reflection {
};
struct bitset_Reflection {
};
struct hash_Reflection {
};
struct basic_streambuf_Reflection {
    static constexpr auto __loc_ = "locale";
    static constexpr auto __binp_ = "char_type *";
    static constexpr auto __ninp_ = "char_type *";
    static constexpr auto __einp_ = "char_type *";
    static constexpr auto __bout_ = "char_type *";
    static constexpr auto __nout_ = "char_type *";
    static constexpr auto __eout_ = "char_type *";
};
struct __num_get_base_Reflection {
};
struct __num_get_Reflection {
};
struct num_get_Reflection {
};
struct __num_put_base_Reflection {
};
struct __num_put_Reflection {
};
struct num_put_Reflection {
};
struct time_base_Reflection {
};
struct __time_get_c_storage_Reflection {
};
struct time_get_Reflection {
};
struct __time_get_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct __time_get_storage_Reflection {
    static constexpr auto __weeks_ = "string_type[14]";
    static constexpr auto __months_ = "string_type[24]";
    static constexpr auto __am_pm_ = "string_type[2]";
    static constexpr auto __c_ = "string_type";
    static constexpr auto __r_ = "string_type";
    static constexpr auto __x_ = "string_type";
    static constexpr auto __X_ = "string_type";
};
struct time_get_byname_Reflection {
};
struct __time_put_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct time_put_Reflection {
};
struct time_put_byname_Reflection {
};
struct money_base_Reflection {
};
struct pattern_Reflection {
    static constexpr auto field = "char[4]";
};
struct moneypunct_Reflection {
};
struct moneypunct_byname_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __curr_symbol_ = "string_type";
    static constexpr auto __positive_sign_ = "string_type";
    static constexpr auto __negative_sign_ = "string_type";
    static constexpr auto __frac_digits_ = "int";
    static constexpr auto __pos_format_ = "pattern";
    static constexpr auto __neg_format_ = "pattern";
};
struct __money_get_Reflection {
};
struct money_get_Reflection {
};
struct __money_put_Reflection {
};
struct money_put_Reflection {
};
struct messages_base_Reflection {
};
struct messages_Reflection {
};
struct messages_byname_Reflection {
};
struct wstring_convert_Reflection {
    static constexpr auto __byte_err_string_ = "byte_string";
    static constexpr auto __wide_err_string_ = "wide_string";
    static constexpr auto __cvtptr_ = "_Codecvt *";
    static constexpr auto __cvtstate_ = "state_type";
    static constexpr auto __cvtcount_ = "size_t";
};
struct wbuffer_convert_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __bufptr_ = "int *";
    static constexpr auto __cv_ = "_Codecvt *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ostream_Reflection {
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
    static constexpr auto __os_ = "basic_ostream<_CharT, _Traits> &";
};
struct __is_ostreamable_Reflection {
};
struct __is_ostreamable_Reflection {
};
struct basic_istream_Reflection {
    static constexpr auto __gc_ = "streamsize";
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
};
struct __is_istreamable_Reflection {
};
struct __is_istreamable_Reflection {
};
struct basic_iostream_Reflection {
};
struct array_Reflection {
    static constexpr auto __elems_ = "_Tp[_Size]";
};
struct array_Reflection {
    static constexpr auto __elems_ = "int[sizeof(_ArrayInStructT)]";
};
struct _ArrayInStructT_Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct __temp_value_Reflection {
    static constexpr auto  = "union std::__temp_value::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\temp_value.h:31:3)";
    static constexpr auto __a = "_Alloc &";
};
struct _Reflection {
    static constexpr auto __v = "_Tp";
};
struct __split_buffer_Reflection {
    static constexpr auto __first_ = "int";
    static constexpr auto __begin_ = "int";
    static constexpr auto __end_ = "int";
    static constexpr auto __end_cap_ = "int";
    static constexpr auto __alloc_ = "allocator_type";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "const int";
    static constexpr auto __dest_ = "int *";
};
struct __container_traits_Reflection {
};
struct __deque_block_size_Reflection {
};
struct __deque_iterator_Reflection {
    static constexpr auto __m_iter_ = "__map_iterator";
    static constexpr auto __ptr_ = "pointer";
};
struct deque_Reflection {
    static constexpr auto __map_ = "int";
    static constexpr auto __start_ = "size_type";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __deque_block_range_Reflection {
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __end_ = "const pointer";
};
struct __deque_range_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "int";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __end_ = "const pointer";
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __base_ = "deque<_Tp, _Allocator> *const";
};
struct __container_traits_Reflection {
};
struct binary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct is_bind_expression_Reflection {
};
struct is_placeholder_Reflection {
};
struct __ph_Reflection {
};
struct is_placeholder_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_Reflection {
    static constexpr auto __f_ = "int";
    static constexpr auto __bound_args_ = "_Td";
};
struct is_bind_expression_Reflection {
};
struct __bind_r_Reflection {
};
struct is_bind_expression_Reflection {
};
struct __mem_fn_Reflection {
    static constexpr auto __f_ = "type";
};
struct unary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct __builtin_new_allocator_Reflection {
};
struct __builtin_new_deleter_Reflection {
    static constexpr auto __size_ = "size_t";
    static constexpr auto __align_ = "size_t";
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct bad_function_call_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __alloc_func_Reflection {
    static constexpr auto __func_ = "_Fp";
    static constexpr auto __alloc_ = "_Ap";
};
struct __default_alloc_func_Reflection {
    static constexpr auto __f_ = "_Fp";
};
struct __base_Reflection {
};
struct __func_Reflection {
    static constexpr auto __f_ = "__alloc_func<_Fp, _Alloc, _Rp (_ArgTypes...)>";
};
struct __value_func_Reflection {
    static constexpr auto __buf_ = "int";
    static constexpr auto __f_ = "__func *";
};
struct __policy_storage_Reflection {
    static constexpr auto __small = "char[16]";
    static constexpr auto __large = "void *";
};
struct __use_small_storage_Reflection {
};
struct __policy_Reflection {
    static constexpr auto __clone = "void *(*const)(const void *)";
    static constexpr auto __destroy = "void (*const)(void *)";
    static constexpr auto __is_null = "const _Bool";
    static constexpr auto __type_info = "const int *const";
};
struct __policy_invoker_Reflection {
    static constexpr auto __call_ = "__Call";
};
struct __policy_func_Reflection {
    static constexpr auto __buf_ = "__policy_storage";
    static constexpr auto __invoker_ = "__invoker";
    static constexpr auto __policy_ = "const __policy *";
};
struct function_Reflection {
    static constexpr auto __f_ = "__func";
};
struct __callable_Reflection {
};
struct __extract_key_fail_tag_Reflection {
};
struct __extract_key_self_tag_Reflection {
};
struct __extract_key_first_tag_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __hash_node_base_Reflection {
    static constexpr auto __next_ = "__next_pointer";
};
struct __hash_node_Reflection {
    static constexpr auto __hash_ = "size_t";
    static constexpr auto  = "union std::__hash_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__hash_table:124:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __hash_key_value_types_Reflection {
};
struct __hash_key_value_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_node_types_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __make_hash_node_types_Reflection {
};
struct __hash_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_const_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __hash_const_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __bucket_list_deallocator_Reflection {
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __hash_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __enforce_unordered_container_requirements_Reflection {
};
struct __hash_table_Reflection {
    static constexpr auto __bucket_list_ = "__bucket_list";
    static constexpr auto __first_node_ = "__first_node";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __hasher_ = "hasher";
    static constexpr auto __max_load_factor_ = "float";
    static constexpr auto __key_eq_ = "key_equal";
};
struct __basic_node_handle_Reflection {
    static constexpr auto __ptr_ = "__node_pointer_type";
    static constexpr auto __alloc_ = "optional<allocator_type>";
};
struct __set_node_handle_specifics_Reflection {
};
struct __map_node_handle_specifics_Reflection {
};
struct __insert_return_type_Reflection {
    static constexpr auto position = "_Iterator";
    static constexpr auto inserted = "_Bool";
    static constexpr auto node = "_NodeType";
};
struct __unordered_map_hasher_Reflection {
};
struct __unordered_map_hasher_Reflection {
    static constexpr auto __hash_ = "_Hash";
};
struct __unordered_map_equal_Reflection {
};
struct __unordered_map_equal_Reflection {
    static constexpr auto __pred_ = "_Pred";
};
struct __hash_map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __hash_value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __hash_map_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct __hash_map_const_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct unordered_map_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multimap_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct to_chars_result_Reflection {
    static constexpr auto ptr = "char *";
    static constexpr auto ec = "errc";
};
struct __traits_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "pointer";
    static constexpr auto __end_ = "pointer";
    static constexpr auto __cap_ = "pointer";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Tp, _Alloc> &";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __v_ = "vector<_Tp, _Alloc> &";
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __new_end_ = "const const_pointer";
};
struct __has_storage_type_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "__storage_pointer";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __cap_ = "size_type";
    static constexpr auto __alloc_ = "__storage_allocator";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Bool, type-parameter-0-0> &";
};
struct hash_Reflection {
};
struct __container_traits_Reflection {
};
struct _BMSkipTable_Reflection {
    static constexpr auto __default_value_ = "const value_type";
    static constexpr auto __table_ = "int";
};
struct _BMSkipTable_Reflection {
    static constexpr auto __table_ = "std::array<value_type, 256>";
};
struct boyer_moore_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
    static constexpr auto __suffix_ = "shared_ptr<difference_type[]>";
};
struct boyer_moore_horspool_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
};
struct default_searcher_Reflection {
    static constexpr auto __first_ = "_ForwardIterator";
    static constexpr auto __last_ = "_ForwardIterator";
    static constexpr auto __pred_ = "_BinaryPredicate";
};
struct __not_fn_op_Reflection {
};
struct __not_fn_t_Reflection {
};
struct queue_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct priority_queue_Reflection {
    static constexpr auto c = "container_type";
    static constexpr auto comp = "value_compare";
};
struct uses_allocator_Reflection {
};
struct stack_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct _FilesystemClock_Reflection {
};
struct __forward_list_node_value_type_Reflection {
};
struct __forward_node_traits_Reflection {
};
struct __forward_begin_node_Reflection {
    static constexpr auto __next_ = "pointer";
};
struct __forward_list_node_Reflection {
    static constexpr auto  = "union std::__forward_list_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\forward_list:328:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __forward_list_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_base_Reflection {
    static constexpr auto __before_begin_ = "__begin_node";
    static constexpr auto __alloc_ = "__node_allocator";
};
struct forward_list_Reflection {
};
struct __container_traits_Reflection {
};
struct basic_stringbuf_Reflection {
    static constexpr auto __str_ = "string_type";
    static constexpr auto __hm_ = "char_type *";
    static constexpr auto __mode_ = "class ios_base::openmode";
};
struct basic_istringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_ostringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_stringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct unordered_set_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multiset_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct null_mutex_Reflection {
};
struct null_atomic_int_Reflection {
    static constexpr auto value = "int";
};
struct type_identity_Reflection {
};
struct is_contiguous_Reflection {
};
struct monostate_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto data_ = "const Char *";
    static constexpr auto size_ = "size_t";
};
struct is_char_Reflection {
};
struct is_char_Reflection {
};
struct compile_string_Reflection {
};
struct is_compile_string_Reflection {
};
struct is_string_Reflection {
};
struct char_t_impl_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct error_handler_Reflection {
};
struct basic_format_parse_context_Reflection {
    static constexpr auto format_str_ = "basic_string_view<Char>";
    static constexpr auto next_arg_id_ = "int";
};
struct compile_parse_context_Reflection {
    static constexpr auto num_args_ = "int";
    static constexpr auto types_ = "const type *";
};
struct buffer_Reflection {
    static constexpr auto ptr_ = "T *";
    static constexpr auto size_ = "size_t";
    static constexpr auto capacity_ = "size_t";
};
struct buffer_traits_Reflection {
};
struct fixed_buffer_traits_Reflection {
    static constexpr auto count_ = "size_t";
    static constexpr auto limit_ = "size_t";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto data_ = "T[buffer_size]";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "T *";
    static constexpr auto data_ = "T[buffer_size]";
};
struct counting_buffer_Reflection {
    static constexpr auto data_ = "T[buffer_size]";
    static constexpr auto count_ = "size_t";
};
struct formatter_Reflection {
};
struct appender_Reflection {
};
struct view_Reflection {
};
struct named_arg_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto value = "const T &";
};
struct named_arg_info_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto id = "int";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)]";
    static constexpr auto named_args_ = "named_arg_info<Char>[NUM_NAMED_ARGS]";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[NUM_ARGS != 0 ? NUM_ARGS : +1]";
};
struct is_named_arg_Reflection {
};
struct is_statically_named_arg_Reflection {
};
struct is_named_arg_Reflection {
};
struct unformattable_Reflection {
};
struct unformattable_char_Reflection {
};
struct unformattable_pointer_Reflection {
};
struct string_value_Reflection {
    static constexpr auto data = "const Char *";
    static constexpr auto size = "size_t";
};
struct named_arg_value_Reflection {
    static constexpr auto data = "const named_arg_info<Char> *";
    static constexpr auto size = "size_t";
};
struct custom_value_Reflection {
    static constexpr auto value = "void *";
    static constexpr auto format = "void (*)(void *, parse_context &, Context &)";
};
struct value_Reflection {
    static constexpr auto  = "union fmt::detail::value::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1261:3)";
};
struct _Reflection {
    static constexpr auto no_value = "monostate";
    static constexpr auto int_value = "int";
    static constexpr auto uint_value = "unsigned int";
    static constexpr auto long_long_value = "long long";
    static constexpr auto ulong_long_value = "unsigned long long";
    static constexpr auto int128_value = "int128_opt";
    static constexpr auto uint128_value = "uint128_opt";
    static constexpr auto bool_value = "_Bool";
    static constexpr auto char_value = "char_type";
    static constexpr auto float_value = "float";
    static constexpr auto double_value = "double";
    static constexpr auto long_double_value = "long double";
    static constexpr auto pointer = "const void *";
    static constexpr auto string = "string_value<char_type>";
    static constexpr auto custom = "custom_value<Context>";
    static constexpr auto named_args = "named_arg_value<char_type>";
};
struct format_as_result_Reflection {
};
struct has_format_as_Reflection {
};
struct arg_mapper_Reflection {
};
struct formattable_Reflection {
};
struct is_output_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct locale_ref_Reflection {
    static constexpr auto locale_ = "const void *";
};
struct basic_format_arg_Reflection {
    static constexpr auto value_ = "detail::value<Context>";
    static constexpr auto type_ = "detail::type";
};
struct handle_Reflection {
    static constexpr auto custom_ = "detail::custom_value<Context>";
};
struct basic_format_context_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto args_ = "basic_format_args<basic_format_context<OutputIt, Char> >";
    static constexpr auto loc_ = "detail::locale_ref";
};
struct format_arg_store_Reflection {
    static constexpr auto data_ = "int";
};
struct basic_format_args_Reflection {
    static constexpr auto desc_ = "unsigned long long";
    static constexpr auto  = "union fmt::basic_format_args::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1902:3)";
};
struct _Reflection {
    static constexpr auto values_ = "const detail::value<Context> *";
    static constexpr auto args_ = "const format_arg *";
};
struct fill_t_Reflection {
    static constexpr auto data_ = "Char[max_size]";
    static constexpr auto size_ = "unsigned char";
};
struct format_specs_Reflection {
    static constexpr auto width = "int";
    static constexpr auto precision = "int";
    static constexpr auto type = "presentation_type";
    static constexpr auto align = "align_t";
    static constexpr auto sign = "sign_t";
    static constexpr auto alt = "_Bool";
    static constexpr auto localized = "_Bool";
    static constexpr auto fill = "detail::fill_t<Char>";
};
struct arg_ref_Reflection {
    static constexpr auto kind = "arg_id_kind";
    static constexpr auto val = "union value";
};
struct value_Reflection {
    static constexpr auto index = "int";
    static constexpr auto name = "basic_string_view<Char>";
};
struct dynamic_format_specs_Reflection {
    static constexpr auto width_ref = "arg_ref<Char>";
    static constexpr auto precision_ref = "arg_ref<Char>";
};
struct dynamic_spec_id_handler_Reflection {
    static constexpr auto ctx = "basic_format_parse_context<Char> &";
    static constexpr auto ref = "arg_ref<Char> &";
};
struct _Reflection {
    static constexpr auto current_state = "state";
};
struct _Reflection {
    static constexpr auto begin = "const Char *&";
    static constexpr auto specs = "dynamic_format_specs<Char> &";
    static constexpr auto arg_type = "type";
};
struct id_adapter_Reflection {
    static constexpr auto handler = "Handler &";
    static constexpr auto arg_id = "int";
};
struct writer_Reflection {
    static constexpr auto handler_ = "Handler &";
};
struct strip_named_arg_Reflection {
};
struct strip_named_arg_Reflection {
};
struct format_string_checker_Reflection {
    static constexpr auto types_ = "type[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
    static constexpr auto context_ = "parse_context_type";
    static constexpr auto parse_funcs_ = "parse_func[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
};
struct vformat_args_Reflection {
};
struct vformat_args_Reflection {
};
struct runtime_format_string_Reflection {
    static constexpr auto str = "basic_string_view<Char>";
};
struct basic_format_string_Reflection {
    static constexpr auto str_ = "basic_string_view<Char>";
};
struct format_to_n_result_Reflection {
    static constexpr auto out = "OutputIt";
    static constexpr auto size = "size_t";
};
struct __uintr_frame_Reflection {
    static constexpr auto rip = "unsigned long long";
    static constexpr auto rflags = "unsigned long long";
    static constexpr auto rsp = "unsigned long long";
};
struct __mm_loadh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadh_pi_v2f32";
};
struct __mm_loadl_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadl_pi_v2f32";
};
struct __mm_load_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __mm_load1_ps_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_store_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_load1_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __loadu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __loadu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __loadu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_load_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadl_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_store_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __mm_loadl_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __storeu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __storeu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __storeu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_storel_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __mm_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __mm256_broadcast_sd_struct_Reflection {
    static constexpr auto __d = "double";
};
struct __mm256_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __loadu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __storeu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __mm_load_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __mm_store_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __loadu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __storeu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __loadu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __storeu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __loadu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __storeu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __tile1024i_str_Reflection {
    static constexpr auto row = "const unsigned short";
    static constexpr auto col = "const unsigned short";
    static constexpr auto tile = "_tile1024i";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __mm_store_sbh_struct_Reflection {
    static constexpr auto __u = "__bf16";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct string_literal_Reflection {
};
struct uint128_fallback_Reflection {
    static constexpr auto lo_ = "int";
    static constexpr auto hi_ = "int";
};
struct _Reflection {
    static constexpr auto  = "F";
};
struct count_code_points_Reflection {
    static constexpr auto count = "size_t *";
};
struct _Reflection {
    static constexpr auto  = "const char *";
    static constexpr auto  = "size_t &";
    static constexpr auto  = "size_t &";
};
struct is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_locale_Reflection {
};
struct basic_memory_buffer_Reflection {
    static constexpr auto store_ = "T[SIZE]";
    static constexpr auto alloc_ = "Allocator";
};
struct is_contiguous_Reflection {
};
struct format_error_Reflection {
};
struct loc_value_Reflection {
    static constexpr auto value_ = "int";
};
struct format_facet_Reflection {
    static constexpr auto separator_ = "int";
    static constexpr auto grouping_ = "int";
    static constexpr auto decimal_point_ = "int";
};
struct _Reflection {
};
struct thousands_sep_result_Reflection {
    static constexpr auto grouping = "int";
    static constexpr auto thousands_sep = "Char";
};
struct format_decimal_result_Reflection {
    static constexpr auto begin = "Iterator";
    static constexpr auto end = "Iterator";
};
struct utf8_to_utf16_Reflection {
    static constexpr auto buffer_ = "int";
};
struct to_utf8_Reflection {
    static constexpr auto buffer_ = "Buffer";
};
struct decimal_fp_Reflection {
    static constexpr auto significand = "int";
    static constexpr auto exponent = "int";
};
struct basic_fp_Reflection {
    static constexpr auto f = "F";
    static constexpr auto e = "int";
};
struct _Reflection {
};
struct find_escape_result_Reflection {
    static constexpr auto begin = "const Char *";
    static constexpr auto end = "const Char *";
    static constexpr auto cp = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct write_int_data_Reflection {
    static constexpr auto size = "size_t";
    static constexpr auto padding = "size_t";
};
struct _Reflection {
};
struct digit_grouping_Reflection {
    static constexpr auto grouping_ = "int";
    static constexpr auto thousands_sep_ = "int";
};
struct next_state_Reflection {
    static constexpr auto group = "int";
    static constexpr auto pos = "int";
};
struct write_int_arg_Reflection {
    static constexpr auto abs_value = "UInt";
    static constexpr auto prefix = "unsigned int";
};
struct loc_writer_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto sep = "int";
    static constexpr auto grouping = "int";
    static constexpr auto decimal_point = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct counting_iterator_Reflection {
    static constexpr auto count_ = "size_t";
};
struct value_type_Reflection {
};
struct _Reflection {
};
struct float_specs_Reflection {
    static constexpr auto precision = "int";
    static constexpr auto format = "float_format";
    static constexpr auto sign = "sign_t";
    static constexpr auto upper = "_Bool";
    static constexpr auto locale = "_Bool";
    static constexpr auto binary32 = "_Bool";
    static constexpr auto showpoint = "_Bool";
};
struct big_decimal_fp_Reflection {
    static constexpr auto significand = "const char *";
    static constexpr auto significand_size = "int";
    static constexpr auto exponent = "int";
};
struct fallback_digit_grouping_Reflection {
};
struct has_isfinite_Reflection {
};
struct bigint_Reflection {
    static constexpr auto bigits_ = "int";
    static constexpr auto exp_ = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct default_arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto args = "int";
    static constexpr auto loc = "locale_ref";
};
struct arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto locale = "locale_ref";
};
struct width_checker_Reflection {
};
struct precision_checker_Reflection {
};
struct udl_arg_Reflection {
    static constexpr auto str = "const Char *";
};
struct format_int_Reflection {
    static constexpr auto buffer_ = "char[0]";
    static constexpr auto str_ = "char *";
};
struct bytes_Reflection {
    static constexpr auto data_ = "string_view";
};
struct group_digits_view_Reflection {
    static constexpr auto value = "T";
};
struct nested_view_Reflection {
    static constexpr auto fmt = "const int *";
    static constexpr auto value = "const T *";
};
struct nested_formatter_Reflection {
    static constexpr auto width_ = "int";
    static constexpr auto fill_ = "detail::fill_t<char>";
    static constexpr auto align_ = "align_t";
    static constexpr auto formatter_ = "int";
};
struct join_view_Reflection {
    static constexpr auto begin = "It";
    static constexpr auto end = "Sentinel";
    static constexpr auto sep = "basic_string_view<Char>";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
    static constexpr auto divisor = "int";
    static constexpr auto shift_amount = "int";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct _Reflection {
    static constexpr auto  = "class fmt::detail::utf8_to_utf16 *";
};
struct singleton_Reflection {
    static constexpr auto upper = "unsigned char";
    static constexpr auto lower_count = "unsigned char";
};
struct is_convertible_to_basic_format_string_Reflection {
};
struct is_convertible_to_any_format_string_Reflection {
};
struct spdlog_ex_Reflection {
    static constexpr auto msg_ = "int";
};
struct source_loc_Reflection {
    static constexpr auto filename = "const char *";
    static constexpr auto line = "int";
    static constexpr auto funcname = "const char *";
};
struct file_event_handlers_Reflection {
    static constexpr auto before_open = "std::function<void (const int &)>";
    static constexpr auto after_open = "std::function<void (const int &, int *)>";
    static constexpr auto before_close = "std::function<void (const int &, int *)>";
    static constexpr auto after_close = "std::function<void (const int &)>";
};
struct condition_variable_any_Reflection {
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __mut_ = "shared_ptr<mutex>";
};
struct __unlock_guard_Reflection {
    static constexpr auto __lock_ = "_Lock &";
};
struct __thread_struct_Reflection {
    static constexpr auto __p_ = "__thread_struct_imp *";
};
struct __thread_specific_ptr_Reflection {
    static constexpr auto __key_ = "__libcpp_tls_key";
};
struct hash_Reflection {
};
struct thread_Reflection {
    static constexpr auto __t_ = "__libcpp_thread_t";
};
struct periodic_worker_Reflection {
    static constexpr auto active_ = "_Bool";
    static constexpr auto worker_thread_ = "std::thread";
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto cv_ = "std::condition_variable";
};
struct registry_Reflection {
    static constexpr auto logger_map_mutex_ = "std::mutex";
    static constexpr auto flusher_mutex_ = "std::mutex";
    static constexpr auto tp_mutex_ = "std::recursive_mutex";
    static constexpr auto log_levels_ = "int";
    static constexpr auto formatter_ = "int";
    static constexpr auto global_log_level_ = "spdlog::level::level_enum";
    static constexpr auto flush_level_ = "level::level_enum";
    static constexpr auto err_handler_ = "err_handler";
    static constexpr auto tp_ = "std::shared_ptr<thread_pool>";
    static constexpr auto periodic_flusher_ = "int";
    static constexpr auto default_logger_ = "std::shared_ptr<logger>";
    static constexpr auto automatic_registration_ = "_Bool";
    static constexpr auto backtrace_n_messages_ = "size_t";
};
struct circular_q_Reflection {
    static constexpr auto max_items_ = "size_t";
    static constexpr auto head_ = "int";
    static constexpr auto tail_ = "int";
    static constexpr auto overrun_counter_ = "size_t";
    static constexpr auto v_ = "int";
};
struct log_msg_Reflection {
    static constexpr auto logger_name = "string_view_t";
    static constexpr auto level = "level::level_enum";
    static constexpr auto time = "log_clock::time_point";
    static constexpr auto thread_id = "size_t";
    static constexpr auto color_range_start = "size_t";
    static constexpr auto color_range_end = "size_t";
    static constexpr auto source = "source_loc";
    static constexpr auto payload = "string_view_t";
};
struct log_msg_buffer_Reflection {
    static constexpr auto buffer = "int";
};
struct backtracer_Reflection {
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto enabled_ = "std::atomic<_Bool>";
    static constexpr auto messages_ = "circular_q<log_msg_buffer>";
};
struct logger_Reflection {
    static constexpr auto name_ = "int";
    static constexpr auto sinks_ = "int";
    static constexpr auto level_ = "spdlog::level_t";
    static constexpr auto flush_level_ = "spdlog::level_t";
    static constexpr auto custom_err_handler_ = "err_handler";
    static constexpr auto tracer_ = "details::backtracer";
};
struct formatter_Reflection {
};
struct padding_info_Reflection {
    static constexpr auto width_ = "size_t";
    static constexpr auto side_ = "pad_side";
    static constexpr auto truncate_ = "_Bool";
    static constexpr auto enabled_ = "_Bool";
};
struct flag_formatter_Reflection {
    static constexpr auto padinfo_ = "padding_info";
};
struct custom_flag_formatter_Reflection {
};
struct pattern_formatter_Reflection {
    static constexpr auto pattern_ = "int";
    static constexpr auto eol_ = "int";
    static constexpr auto pattern_time_type_ = "pattern_time_type";
    static constexpr auto need_localtime_ = "_Bool";
    static constexpr auto cached_tm_ = "int";
    static constexpr auto last_log_secs_ = "std::chrono::seconds";
    static constexpr auto formatters_ = "int";
    static constexpr auto custom_handlers_ = "int";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_node_base_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_node_types_Reflection {
};
struct __make_tree_node_types_Reflection {
};
struct __tree_end_node_Reflection {
    static constexpr auto __left_ = "pointer";
};
struct __tree_node_base_Reflection {
    static constexpr auto __right_ = "pointer";
    static constexpr auto __parent_ = "__parent_pointer";
    static constexpr auto __is_black_ = "_Bool";
};
struct __tree_node_Reflection {
    static constexpr auto __value_ = "__node_value_type";
};
struct __tree_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __tree_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_Reflection {
    static constexpr auto __begin_node_ = "__iter_pointer";
    static constexpr auto __end_node_ = "__end_node_t";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __value_comp_ = "value_compare";
};
struct _DetachedTreeCache_Reflection {
    static constexpr auto __t_ = "__tree<_Tp, _Compare, _Allocator> *";
    static constexpr auto __cache_root_ = "__node_pointer";
    static constexpr auto __cache_elem_ = "__node_pointer";
};
struct __map_value_compare_Reflection {
};
struct __map_value_compare_Reflection {
    static constexpr auto __comp_ = "_Compare";
};
struct __map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __extract_key_value_types_Reflection {
};
struct __map_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct __map_const_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct map_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct multimap_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct mdc_Reflection {
};
struct scoped_padder_Reflection {
    static constexpr auto padinfo_ = "const padding_info &";
    static constexpr auto dest_ = "int &";
    static constexpr auto remaining_pad_ = "long";
    static constexpr auto spaces_ = "string_view_t";
};
struct null_scoped_padder_Reflection {
};
struct name_formatter_Reflection {
};
struct level_formatter_Reflection {
};
struct short_level_formatter_Reflection {
};
struct a_formatter_Reflection {
};
struct A_formatter_Reflection {
};
struct b_formatter_Reflection {
};
struct B_formatter_Reflection {
};
struct c_formatter_Reflection {
};
struct C_formatter_Reflection {
};
struct D_formatter_Reflection {
};
struct Y_formatter_Reflection {
};
struct m_formatter_Reflection {
};
struct d_formatter_Reflection {
};
struct H_formatter_Reflection {
};
struct I_formatter_Reflection {
};
struct M_formatter_Reflection {
};
struct S_formatter_Reflection {
};
struct e_formatter_Reflection {
};
struct f_formatter_Reflection {
};
struct F_formatter_Reflection {
};
struct E_formatter_Reflection {
};
struct p_formatter_Reflection {
};
struct r_formatter_Reflection {
};
struct R_formatter_Reflection {
};
struct T_formatter_Reflection {
};
struct z_formatter_Reflection {
    static constexpr auto last_update_ = "log_clock::time_point";
    static constexpr auto offset_minutes_ = "int";
};
struct t_formatter_Reflection {
};
struct pid_formatter_Reflection {
};
struct v_formatter_Reflection {
};
struct ch_formatter_Reflection {
    static constexpr auto ch_ = "char";
};
struct aggregate_formatter_Reflection {
    static constexpr auto str_ = "int";
};
struct color_start_formatter_Reflection {
};
struct color_stop_formatter_Reflection {
};
struct source_location_formatter_Reflection {
};
struct source_filename_formatter_Reflection {
};
struct short_filename_formatter_Reflection {
};
struct source_linenum_formatter_Reflection {
};
struct source_funcname_formatter_Reflection {
};
struct elapsed_formatter_Reflection {
    static constexpr auto last_message_time_ = "log_clock::time_point";
};
struct mdc_formatter_Reflection {
};
struct full_formatter_Reflection {
    static constexpr auto cache_timestamp_ = "std::chrono::seconds";
    static constexpr auto cached_datetime_ = "int";
    static constexpr auto mdc_formatter_ = "mdc_formatter<null_scoped_padder>";
};
struct sink_Reflection {
    static constexpr auto level_ = "level_t";
};
struct console_mutex_Reflection {
};
struct console_nullmutex_Reflection {
};
struct wincolor_sink_Reflection {
    static constexpr auto out_handle_ = "void *";
    static constexpr auto mutex_ = "mutex_t &";
    static constexpr auto should_do_colors_ = "_Bool";
    static constexpr auto formatter_ = "int";
    static constexpr auto colors_ = "std::array<int, level::n_levels>";
};
struct wincolor_stdout_sink_Reflection {
};
struct wincolor_stderr_sink_Reflection {
};
struct synchronous_factory_Reflection {
};
struct file_helper_Reflection {
    static constexpr auto open_tries_ = "const int";
    static constexpr auto open_interval_ = "const unsigned int";
    static constexpr auto fd_ = "int *";
    static constexpr auto filename_ = "int";
    static constexpr auto event_handlers_ = "file_event_handlers";
};
struct base_sink_Reflection {
    static constexpr auto formatter_ = "int";
    static constexpr auto mutex_ = "Mutex";
};
struct basic_file_sink_Reflection {
    static constexpr auto file_helper_ = "details::file_helper";
};
struct __iom_t1_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t2_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t3_Reflection {
    static constexpr auto __base_ = "int";
};
struct __iom_t4_Reflection {
    static constexpr auto __fill_ = "_CharT";
};
struct __iom_t5_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t6_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t7_Reflection {
    static constexpr auto __mon_ = "_MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t8_Reflection {
    static constexpr auto __mon_ = "const _MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t9_Reflection {
    static constexpr auto __tm_ = "int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __iom_t10_Reflection {
    static constexpr auto __tm_ = "const int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __quoted_output_proxy_Reflection {
    static constexpr auto __first_ = "const _CharT *";
    static constexpr auto __last_ = "const _CharT *";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __quoted_proxy_Reflection {
    static constexpr auto __string_ = "basic_string<_CharT, _Traits, _Allocator> &";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct _NullSentinel_Reflection {
};
struct __is_pathable_string_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_iter_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct path_Reflection {
    static constexpr auto __pn_ = "string_type";
};
struct basic_filebuf_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __file_ = "int *";
    static constexpr auto __cv_ = "const codecvt<char_type, char, state_type> *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __st_last_ = "state_type";
    static constexpr auto __om_ = "class ios_base::openmode";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ifstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_ofstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_fstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct file_status_Reflection {
    static constexpr auto __ft_ = "file_type";
    static constexpr auto __prms_ = "perms";
};
struct space_info_Reflection {
    static constexpr auto capacity = "int";
    static constexpr auto free = "int";
    static constexpr auto available = "int";
};
struct directory_entry_Reflection {
    static constexpr auto __p_ = "_Path";
    static constexpr auto __data_ = "__cached_data";
};
struct __cached_data_Reflection {
    static constexpr auto __size_ = "int";
    static constexpr auto __nlink_ = "int";
    static constexpr auto __write_time_ = "file_time_type";
    static constexpr auto __sym_perms_ = "perms";
    static constexpr auto __non_sym_perms_ = "perms";
    static constexpr auto __type_ = "file_type";
    static constexpr auto __cache_type_ = "_CacheType";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct __dir_element_proxy_Reflection {
    static constexpr auto __elem_ = "directory_entry";
};
struct directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__dir_stream>";
};
struct iterator_Reflection {
    static constexpr auto __stashed_elem_ = "path";
    static constexpr auto __path_ptr_ = "const path *";
    static constexpr auto __entry_ = "class path::__string_view";
    static constexpr auto __state_ = "_ParserState";
};
struct recursive_directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__shared_imp>";
    static constexpr auto __rec_ = "_Bool";
};
struct formatbuf_Reflection {
    static constexpr auto buffer_ = "buffer<char_type> &";
};
struct file_access_tag_Reflection {
};
struct file_access_Reflection {
};
struct streamed_view_Reflection {
    static constexpr auto value = "const T &";
};
struct basic_ostream_formatter_Reflection {
};
struct Logger_Reflection {
};
struct Event_Reflection {
    static constexpr auto Handled = "_Bool";
};
struct EventDispatcher_Reflection {
    static constexpr auto m_Event = "Event &";
};
struct WindowProperties_Reflection {
    static constexpr auto Title = "int";
    static constexpr auto Width = "unsigned int";
    static constexpr auto Height = "unsigned int";
};
struct Window_Reflection {
};
struct GLFWvidmode_Reflection {
    static constexpr auto width = "int";
    static constexpr auto height = "int";
    static constexpr auto redBits = "int";
    static constexpr auto greenBits = "int";
    static constexpr auto blueBits = "int";
    static constexpr auto refreshRate = "int";
};
struct GLFWgammaramp_Reflection {
    static constexpr auto red = "unsigned short *";
    static constexpr auto green = "unsigned short *";
    static constexpr auto blue = "unsigned short *";
    static constexpr auto size = "unsigned int";
};
struct GLFWimage_Reflection {
    static constexpr auto width = "int";
    static constexpr auto height = "int";
    static constexpr auto pixels = "unsigned char *";
};
struct GLFWgamepadstate_Reflection {
    static constexpr auto buttons = "unsigned char[15]";
    static constexpr auto axes = "float[6]";
};
struct GLFWallocator_Reflection {
    static constexpr auto allocate = "GLFWallocatefun";
    static constexpr auto reallocate = "GLFWreallocatefun";
    static constexpr auto deallocate = "GLFWdeallocatefun";
    static constexpr auto user = "void *";
};
struct RenderContext_Reflection {
};
struct WindowsWindow_Reflection {
    static constexpr auto m_Window = "GLFWwindow *";
    static constexpr auto m_Context = "RenderContext *";
    static constexpr auto m_Data = "WindowData";
};
struct WindowData_Reflection {
    static constexpr auto Title = "int";
    static constexpr auto Width = "unsigned int";
    static constexpr auto Height = "unsigned int";
    static constexpr auto VSync = "_Bool";
    static constexpr auto EventCallBack = "EventCallBackFn";
};
struct fpos_Reflection {
    static constexpr auto __st_ = "_StateT";
    static constexpr auto __off_ = "streamoff";
};
struct enable_if_Reflection {
};
struct enable_if_Reflection {
};
struct integral_constant_Reflection {
};
struct remove_cv_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct __equal_tag_Reflection {
};
struct __plus_tag_Reflection {
};
struct __totally_ordered_less_tag_Reflection {
};
struct __equal_to_Reflection {
};
struct __less_Reflection {
};
struct __less_Reflection {
};
struct __debug_less_Reflection {
    static constexpr auto __comp_ = "_Compare &";
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct is_floating_point_Reflection {
};
struct is_arithmetic_Reflection {
};
struct is_signed_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct is_convertible_Reflection {
};
struct is_function_Reflection {
};
struct is_reference_Reflection {
};
struct is_lvalue_reference_Reflection {
};
struct is_rvalue_reference_Reflection {
};
struct remove_all_extents_Reflection {
};
struct is_destructible_Reflection {
};
struct is_nothrow_destructible_Reflection {
};
struct is_same_Reflection {
};
struct __libcpp_is_referenceable_Reflection {
};
struct add_lvalue_reference_Reflection {
};
struct add_rvalue_reference_Reflection {
};
struct is_constructible_Reflection {
};
struct is_copy_constructible_Reflection {
};
struct is_move_constructible_Reflection {
};
struct is_default_constructible_Reflection {
};
struct _IfImpl_Reflection {
};
struct _IfImpl_Reflection {
};
struct conditional_Reflection {
};
struct conditional_Reflection {
};
struct is_void_Reflection {
};
struct remove_reference_Reflection {
};
struct add_pointer_Reflection {
};
struct is_array_Reflection {
};
struct remove_extent_Reflection {
};
struct decay_Reflection {
};
struct __type_identity_Reflection {
};
struct __empty_Reflection {
};
struct common_type_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct is_class_Reflection {
};
struct is_enum_Reflection {
};
struct is_union_Reflection {
};
struct extent_Reflection {
};
struct is_nothrow_assignable_Reflection {
};
struct is_nothrow_copy_assignable_Reflection {
};
struct is_nothrow_move_assignable_Reflection {
};
struct is_nothrow_constructible_Reflection {
};
struct is_nothrow_copy_constructible_Reflection {
};
struct is_nothrow_move_constructible_Reflection {
};
struct is_nothrow_default_constructible_Reflection {
};
struct is_assignable_Reflection {
};
struct is_copy_assignable_Reflection {
};
struct is_move_assignable_Reflection {
};
struct is_swappable_with_Reflection {
};
struct is_swappable_Reflection {
};
struct is_nothrow_swappable_with_Reflection {
};
struct is_nothrow_swappable_Reflection {
};
struct is_object_Reflection {
};
struct __nat_Reflection {
};
struct __type_list_Reflection {
};
struct __find_first_Reflection {
};
struct __find_first_Reflection {
};
struct make_signed_Reflection {
};
struct _OrImpl_Reflection {
};
struct _OrImpl_Reflection {
};
struct disjunction_Reflection {
};
struct remove_const_Reflection {
};
struct input_iterator_tag_Reflection {
};
struct output_iterator_tag_Reflection {
};
struct forward_iterator_tag_Reflection {
};
struct bidirectional_iterator_tag_Reflection {
};
struct random_access_iterator_tag_Reflection {
};
struct __iter_traits_cache_Reflection {
};
struct __iter_concept_concept_test_Reflection {
};
struct __iter_concept_category_test_Reflection {
};
struct __iter_concept_random_fallback_Reflection {
};
struct __test_iter_concept_Reflection {
};
struct __iter_concept_cache_Reflection {
};
struct __has_iterator_typedefs_Reflection {
};
struct __has_iterator_category_Reflection {
};
struct __has_iterator_concept_Reflection {
};
struct __iterator_traits_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __is_callable_Reflection {
};
struct initializer_list_Reflection {
    static constexpr auto __begin_ = "const _Ep *";
    static constexpr auto __size_ = "size_t";
};
struct __is_identity_Reflection {
};
struct __identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct is_base_of_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct is_member_pointer_Reflection {
};
struct is_member_object_pointer_Reflection {
};
struct is_member_function_pointer_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __invokable_r_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __invoke_of_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct is_invocable_Reflection {
};
struct is_invocable_r_Reflection {
};
struct is_nothrow_invocable_Reflection {
};
struct is_nothrow_invocable_r_Reflection {
};
struct invoke_result_Reflection {
};
struct __has_specialization_Reflection {
};
struct __has_specialization_Reflection {
};
struct __all_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct __has_pointer_Reflection {
};
struct __has_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __has_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __has_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_impl_Reflection {
};
struct pointer_traits_Reflection {
};
struct pointer_traits_Reflection {
};
struct __nat_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasArrow_Reflection {
};
struct _HasArrow_Reflection {
};
struct _IsFancyPointer_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct add_const_Reflection {
};
struct add_cv_Reflection {
};
struct add_volatile_Reflection {
};
struct __align_type_Reflection {
};
struct __struct_double_Reflection {
    static constexpr auto __lx = "long double";
};
struct __struct_double4_Reflection {
    static constexpr auto __lx = "double[4]";
};
struct __fallback_overaligned_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_max_align_Reflection {
};
struct __select_align_Reflection {
};
struct __find_max_align_Reflection {
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __align = "_Aligner";
    static constexpr auto __data = "unsigned char[(_Len + _Align - 1) / _Align * _Align]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1 - 1) / 1 * 1]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2 - 1) / 2 * 2]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4 - 1) / 4 * 4]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8 - 1) / 8 * 8]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 16 - 1) / 16 * 16]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 32 - 1) / 32 * 32]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 64 - 1) / 64 * 64]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 128 - 1) / 128 * 128]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 256 - 1) / 256 * 256]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 512 - 1) / 512 * 512]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1024 - 1) / 1024 * 1024]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2048 - 1) / 2048 * 2048]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4096 - 1) / 4096 * 4096]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8192 - 1) / 8192 * 8192]";
};
struct __static_max_Reflection {
};
struct __static_max_Reflection {
};
struct aligned_union_Reflection {
};
struct alignment_of_Reflection {
};
struct has_virtual_destructor_Reflection {
};
struct is_abstract_Reflection {
};
struct is_null_pointer_Reflection {
};
struct is_fundamental_Reflection {
};
struct is_compound_Reflection {
};
struct is_const_Reflection {
};
struct is_empty_Reflection {
};
struct is_literal_type_Reflection {
};
struct is_pod_Reflection {
};
struct is_pointer_Reflection {
};
struct is_polymorphic_Reflection {
};
struct is_scalar_Reflection {
};
struct is_standard_layout_Reflection {
};
struct is_trivial_Reflection {
};
struct is_trivially_assignable_Reflection {
};
struct is_trivially_copy_assignable_Reflection {
};
struct is_trivially_move_assignable_Reflection {
};
struct is_trivially_constructible_Reflection {
};
struct is_trivially_copy_constructible_Reflection {
};
struct is_trivially_move_constructible_Reflection {
};
struct is_trivially_default_constructible_Reflection {
};
struct is_trivially_copyable_Reflection {
};
struct is_trivially_destructible_Reflection {
};
struct is_unsigned_Reflection {
};
struct is_volatile_Reflection {
};
struct make_unsigned_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct remove_pointer_Reflection {
};
struct remove_volatile_Reflection {
};
struct result_of_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct underlying_type_Reflection {
};
struct __libcpp_is_final_Reflection {
};
struct is_final_Reflection {
};
struct has_unique_object_representations_Reflection {
};
struct is_aggregate_Reflection {
};
struct _Not_Reflection {
};
struct negation_Reflection {
};
struct _FirstPaddingByte_Reflection {
    static constexpr auto __v_ = "_Tp";
    static constexpr auto __first_padding_byte_ = "char";
};
struct __is_always_bitcastable_Reflection {
};
struct __is_equality_comparable_Reflection {
};
struct __libcpp_is_trivially_equality_comparable_impl_Reflection {
};
struct __is_less_than_comparable_Reflection {
};
struct __find_segment_Reflection {
    static constexpr auto __value_ = "const _Tp &";
};
struct __unary_function_keep_layout_base_Reflection {
};
struct __integer_sequence_Reflection {
};
struct integer_sequence_Reflection {
};
struct __tuple_indices_Reflection {
};
struct __make_tuple_indices_Reflection {
};
struct __tuple_types_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_size_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_sfinae_base_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct tuple_element_Reflection {
};
struct __check_tuple_constructor_fail_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __libcpp_is_trivially_relocatable_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_ref_decay_Reflection {
};
struct piecewise_construct_t_Reflection {
};
struct __non_trivially_copyable_base_Reflection {
};
struct pair_Reflection {
    static constexpr auto first = "_T1";
    static constexpr auto second = "_T2";
};
struct _CheckArgs_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct __get_pair_Reflection {
};
struct __get_pair_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct _PairT_Reflection {
    static constexpr auto first = "size_t";
    static constexpr auto second = "size_t";
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct _Reflection {
    static constexpr auto __t = "long double";
    static constexpr auto __s = "struct (unnamed struct at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__functional\hash.h:476:7)";
};
struct _Reflection {
    static constexpr auto __a = "size_t";
    static constexpr auto __b = "size_t";
};
struct __enum_hash_Reflection {
};
struct __enum_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __bounded_iter_Reflection {
    static constexpr auto __current_ = "_Iterator";
    static constexpr auto __begin_ = "_Iterator";
    static constexpr auto __end_ = "_Iterator";
};
struct __sfinae_underlying_type_Reflection {
};
struct __sfinae_underlying_type_Reflection {
};
struct iterator_Reflection {
};
struct reverse_iterator_Reflection {
    static constexpr auto __t_ = "_Iter";
    static constexpr auto current = "_Iter";
};
struct __unwrap_iter_impl_Reflection {
};
struct __wrap_iter_Reflection {
    static constexpr auto __i_ = "iterator_type";
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct pointer_traits_Reflection {
};
struct __pointer_Reflection {
};
struct __pointer_Reflection {
};
struct __has_const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __has_void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __has_const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __has_size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __has_alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __has_propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __has_propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __has_propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __has_is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __has_rebind_other_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct allocator_traits_Reflection {
};
struct __check_valid_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_cpp17_move_insertable_Reflection {
};
struct __is_cpp17_copy_insertable_Reflection {
};
struct __allocation_result_Reflection {
    static constexpr auto ptr = "_Pointer";
    static constexpr auto count = "size_t";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __noexcept_move_assign_container_Reflection {
};
struct memory_resource_Reflection {
};
struct __exception_guard_exceptions_Reflection {
    static constexpr auto __rollback_ = "_Rollback";
    static constexpr auto __completed_ = "_Bool";
};
struct __exception_guard_noexceptions_Reflection {
    static constexpr auto __completed_ = "_Bool";
};
struct __has_allocator_type_Reflection {
};
struct __uses_allocator_Reflection {
};
struct __uses_allocator_Reflection {
};
struct uses_allocator_Reflection {
};
struct allocator_arg_t_Reflection {
};
struct __uses_alloc_ctor_imp_Reflection {
};
struct __uses_alloc_ctor_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_t_Reflection {
};
struct __ignore_type_Reflection {
};
struct _Lazy_Reflection {
};
struct __promote_Reflection {
};
struct __tuple_leaf_Reflection {
    static constexpr auto __value_ = "_Hp";
};
struct __tuple_leaf_Reflection {
};
struct __all_default_constructible_Reflection {
};
struct __tuple_impl_Reflection {
};
struct tuple_Reflection {
    static constexpr auto __base_ = "_BaseT";
};
struct _IsThisTuple_Reflection {
};
struct _EnableUTypesCtor_Reflection {
};
struct _EnableCtorFromUTypesTuple_Reflection {
};
struct _CtorPredicateFromPair_Reflection {
};
struct _EnableCtorFromPair_Reflection {
};
struct _NothrowConstructibleFromPair_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _AssignPredicateFromPair_Reflection {
};
struct _EnableAssignFromPair_Reflection {
};
struct _NothrowAssignFromPair_Reflection {
};
struct tuple_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_cat_type_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_Reflection {
};
struct __tuple_cat_Reflection {
};
struct uses_allocator_Reflection {
};
struct bad_cast_Reflection {
};
struct bad_typeid_Reflection {
};
struct exception_ptr_Reflection {
    static constexpr auto __ptr1_ = "void *";
    static constexpr auto __ptr2_ = "void *";
};
struct nested_exception_Reflection {
    static constexpr auto __ptr_ = "exception_ptr";
};
struct __nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __can_dynamic_cast_Reflection {
};
struct __save_flags_Reflection {
    static constexpr auto __stream_ = "__stream_type &";
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __fill_ = "_CharT";
};
struct in_place_t_Reflection {
};
struct in_place_type_t_Reflection {
};
struct in_place_index_t_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct polymorphic_allocator_Reflection {
    static constexpr auto __res_ = "memory_resource *";
};
struct _ClassicAlgPolicy_Reflection {
};
struct _IterOps_Reflection {
};
struct char_traits_Reflection {
};
struct __char_traits_base_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct __is_allocator_Reflection {
};
struct logic_error_Reflection {
};
struct runtime_error_Reflection {
};
struct domain_error_Reflection {
};
struct invalid_argument_Reflection {
};
struct length_error_Reflection {
};
struct out_of_range_Reflection {
};
struct range_error_Reflection {
};
struct overflow_error_Reflection {
};
struct underflow_error_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto __data_ = "const value_type *";
    static constexpr auto __size_ = "size_type";
};
struct __assume_valid_Reflection {
};
struct __string_view_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __can_lower_copy_assignment_to_memmove_Reflection {
};
struct __can_lower_move_assignment_to_memmove_Reflection {
};
struct __can_rewrap_Reflection {
};
struct __copy_impl_Reflection {
};
struct _CopySegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __copy_backward_impl_Reflection {
};
struct nullopt_t_Reflection {
};
struct __secret_tag_Reflection {
};
struct __optional_construct_from_invoke_tag_Reflection {
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_storage_base_Reflection {
};
struct __optional_storage_base_Reflection {
    static constexpr auto __value_ = "int *";
};
struct __optional_copy_base_Reflection {
};
struct __optional_copy_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __is_std_optional_Reflection {
};
struct __is_std_optional_Reflection {
};
struct optional_Reflection {
};
struct _CheckOptionalArgsConstructor_Reflection {
};
struct _CheckOptionalLikeConstructor_Reflection {
};
struct __cxx_atomic_base_impl_Reflection {
    static constexpr auto __a_value = "_Atomic(_Tp)";
};
struct __cxx_atomic_impl_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_lcm_Reflection {
};
struct __static_abs_Reflection {
};
struct __static_sign_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_div_Reflection {
};
struct ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __ratio_multiply_Reflection {
};
struct __ratio_divide_Reflection {
};
struct __ratio_add_Reflection {
};
struct __ratio_subtract_Reflection {
};
struct ratio_equal_Reflection {
};
struct ratio_not_equal_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct ratio_less_Reflection {
};
struct ratio_less_equal_Reflection {
};
struct ratio_greater_Reflection {
};
struct ratio_greater_equal_Reflection {
};
struct __ratio_gcd_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct common_type_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct treat_as_floating_point_Reflection {
};
struct duration_values_Reflection {
};
struct duration_Reflection {
    static constexpr auto __rep_ = "rep";
};
struct __no_overflow_Reflection {
};
struct __mul_Reflection {
};
struct __mul_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_lt_Reflection {
};
struct __duration_lt_Reflection {
};
struct time_point_Reflection {
    static constexpr auto __d_ = "duration";
};
struct common_type_Reflection {
};
struct steady_clock_Reflection {
};
struct system_clock_Reflection {
};
struct __spinning_backoff_policy_Reflection {
};
struct __atomic_waitable_traits_Reflection {
};
struct __atomic_waitable_Reflection {
};
struct __atomic_wait_poll_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_wait_backoff_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_compare_unequal_to_Reflection {
    static constexpr auto __val_ = "_Tp";
};
struct __libcpp_is_always_lock_free_Reflection {
};
struct __atomic_base_Reflection {
    static constexpr auto __a_ = "int";
};
struct __atomic_base_Reflection {
};
struct __binary_function_keep_layout_base_Reflection {
};
struct plus_Reflection {
};
struct plus_Reflection {
};
struct minus_Reflection {
};
struct minus_Reflection {
};
struct multiplies_Reflection {
};
struct multiplies_Reflection {
};
struct divides_Reflection {
};
struct divides_Reflection {
};
struct modulus_Reflection {
};
struct modulus_Reflection {
};
struct negate_Reflection {
};
struct negate_Reflection {
};
struct bit_and_Reflection {
};
struct bit_and_Reflection {
};
struct bit_not_Reflection {
};
struct bit_not_Reflection {
};
struct bit_or_Reflection {
};
struct bit_or_Reflection {
};
struct bit_xor_Reflection {
};
struct bit_xor_Reflection {
};
struct equal_to_Reflection {
};
struct equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct less_Reflection {
};
struct less_Reflection {
};
struct less_equal_Reflection {
};
struct less_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_Reflection {
};
struct greater_Reflection {
};
struct logical_and_Reflection {
};
struct logical_and_Reflection {
};
struct logical_not_Reflection {
};
struct logical_not_Reflection {
};
struct logical_or_Reflection {
};
struct logical_or_Reflection {
};
struct atomic_Reflection {
};
struct atomic_Reflection {
};
struct atomic_flag_Reflection {
    static constexpr auto __a_ = "int";
};
struct back_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct front_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
    static constexpr auto iter = "int";
};
struct istream_iterator_Reflection {
    static constexpr auto __in_stream_ = "istream_type *";
    static constexpr auto __value_ = "_Tp";
};
struct istreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __proxy_Reflection {
    static constexpr auto __keep_ = "char_type";
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct move_iterator_Reflection {
    static constexpr auto __current_ = "_Iter";
};
struct ostream_iterator_Reflection {
    static constexpr auto __out_stream_ = "ostream_type *";
    static constexpr auto __delim_ = "const char_type *";
};
struct ostreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __dependent_type_Reflection {
};
struct monostate_Reflection {
};
struct hash_Reflection {
};
struct __farray_Reflection {
    static constexpr auto __buf_ = "_Tp[_Size]";
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_Reflection {
};
struct __valueless_t_Reflection {
};
struct __traits_Reflection {
};
struct __union_Reflection {
};
struct __base_Reflection {
};
struct __variant_Reflection {
};
struct __base_Reflection {
};
struct __dispatcher_Reflection {
};
struct __variant_Reflection {
};
struct __value_visitor_Reflection {
    static constexpr auto __visitor = "_Visitor &&";
};
struct __alt_Reflection {
    static constexpr auto __value = "__value_type";
};
struct __union_Reflection {
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_TriviallyAvailable, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Available, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Unavailable, _Index + 1, _Types...>";
};
struct __base_Reflection {
    static constexpr auto __data = "__union<_DestructibleTrait, 0, _Types...>";
    static constexpr auto __index = "int";
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __ctor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __impl_Reflection {
};
struct __no_narrowing_check_Reflection {
};
struct __narrowing_check_Reflection {
};
struct __overload_Reflection {
};
struct __all_overloads_Reflection {
};
struct __make_overloads_imp_Reflection {
};
struct variant_Reflection {
    static constexpr auto __impl_ = "__variant_detail::__impl<_Types...>";
};
struct __convert_to_bool_Reflection {
};
struct __has_result_type_Reflection {
};
struct __derives_from_unary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __derives_from_binary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct reference_wrapper_Reflection {
    static constexpr auto __f_ = "type *";
};
struct __allocation_guard_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __n_ = "_Size";
    static constexpr auto __ptr_ = "_Pointer";
};
struct __allocator_destructor_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __s_ = "size_type";
};
struct __move_impl_Reflection {
};
struct _MoveSegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __always_false_Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _AllocatorDestroyRangeReverse_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __first_ = "_Iter &";
    static constexpr auto __last_ = "_Iter &";
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __has_array_cookie_Reflection {
};
struct __private_constructor_tag_Reflection {
};
struct default_delete_Reflection {
};
struct default_delete_Reflection {
};
struct _EnableIfConvertible_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
};
struct __unique_ptr_array_bounds_stateless_Reflection {
};
struct __unique_ptr_array_bounds_stored_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
    static constexpr auto __checker_ = "_BoundsChecker";
};
struct _CheckArrayPointerConversion_Reflection {
};
struct _CheckArrayPointerConversion_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct bad_weak_ptr_Reflection {
};
struct __shared_count_Reflection {
    static constexpr auto __shared_owners_ = "long";
};
struct __shared_weak_count_Reflection {
    static constexpr auto __shared_weak_owners_ = "long";
};
struct __shared_ptr_pointer_Reflection {
    static constexpr auto __ptr_ = "_Tp";
    static constexpr auto __deleter_ = "_Dp";
    static constexpr auto __alloc_ = "_Alloc";
};
struct __for_overwrite_tag_Reflection {
};
struct __shared_ptr_emplace_Reflection {
    static constexpr auto __storage_ = "_Storage";
};
struct _Storage_Reflection {
    static constexpr auto __buffer_ = "char[sizeof(_Data)]";
};
struct _Data_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __elem_ = "int";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __compatible_with_Reflection {
};
struct __raw_pointer_compatible_with_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __well_formed_deleter_Reflection {
};
struct __shared_ptr_deleter_ctor_reqs_Reflection {
};
struct shared_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct __nullptr_sfinae_tag_Reflection {
};
struct __shared_ptr_default_allocator_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __sp_aligned_storage_Reflection {
    static constexpr auto __storage = "char[_Alignment]";
};
struct __unbounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __count_ = "size_t";
    static constexpr auto  = "union std::__unbounded_array_control_block<type-parameter-0-0[], type-parameter-0-1>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:952:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct __bounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto  = "union std::__bounded_array_control_block<type-parameter-0-0[_Np], type-parameter-0-2>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:1030:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[_Count]";
};
struct weak_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct enable_shared_from_this_Reflection {
    static constexpr auto __weak_this_ = "weak_ptr<_Tp>";
};
struct hash_Reflection {
};
struct __sp_mut_Reflection {
    static constexpr auto __lx_ = "void *";
};
struct raw_storage_iterator_Reflection {
    static constexpr auto __x_ = "_OutputIterator";
};
struct __temporary_buffer_deleter_Reflection {
    static constexpr auto __count_ = "ptrdiff_t";
};
struct __move_backward_impl_Reflection {
};
struct __destruct_n_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct __invert_Reflection {
    static constexpr auto __p_ = "_Predicate";
};
struct _ConstTimeDistance_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct _Reflection {
};
struct __aliasing_iterator_wrapper_Reflection {
};
struct __iterator_Reflection {
    static constexpr auto __base_ = "_BaseIter";
};
struct _MinmaxElementLessFunc_Reflection {
    static constexpr auto __comp_ = "_Comp &";
    static constexpr auto __proj_ = "_Proj &";
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct _ProjectedPred_Reflection {
    static constexpr auto __pred = "_Pred &";
    static constexpr auto __proj = "_Proj &";
};
struct __set_intersection_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_symmetric_difference_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_union_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_urng_Reflection {
};
struct __log2_Reflection {
};
struct __independent_bits_engine_Reflection {
    static constexpr auto __e_ = "_Engine &";
    static constexpr auto __w_ = "size_t";
    static constexpr auto __w0_ = "size_t";
    static constexpr auto __n_ = "size_t";
    static constexpr auto __n0_ = "size_t";
    static constexpr auto __y0_ = "_Working_result_type";
    static constexpr auto __y1_ = "_Working_result_type";
    static constexpr auto __mask0_ = "_Engine_result_type";
    static constexpr auto __mask1_ = "_Engine_result_type";
};
struct uniform_int_distribution_Reflection {
    static constexpr auto __p_ = "param_type";
};
struct param_type_Reflection {
    static constexpr auto __a_ = "result_type";
    static constexpr auto __b_ = "result_type";
};
struct __libcpp_debug_randomizer_Reflection {
    static constexpr auto __state_ = "int";
    static constexpr auto __inc_ = "int";
};
struct __stable_sort_switch_Reflection {
};
struct __reread_from_input_tag_Reflection {
};
struct __reread_from_output_tag_Reflection {
};
struct __read_from_tmp_value_tag_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __can_be_converted_to_string_view_Reflection {
};
struct __uninitialized_size_tag_Reflection {
};
struct __init_with_sentinel_tag_Reflection {
};
struct __padding_Reflection {
    static constexpr auto __padding_ = "char[_PaddingSize]";
};
struct __padding_Reflection {
};
struct basic_string_Reflection {
    static constexpr auto __rep_ = "__rep";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __long_Reflection {
    static constexpr auto  = "struct std::basic_string::__long::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:902:5)";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __data_ = "pointer";
};
struct _Reflection {
    static constexpr auto __is_long_ = "size_type";
    static constexpr auto __cap_ = "size_type";
};
struct __short_Reflection {
    static constexpr auto  = "struct std::basic_string::__short::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:913:5)";
    static constexpr auto __padding_ = "__padding<sizeof(value_type) - 1>";
    static constexpr auto __data_ = "value_type[__min_cap]";
};
struct _Reflection {
    static constexpr auto __is_long_ = "unsigned char";
    static constexpr auto __size_ = "unsigned char";
};
struct __rep_Reflection {
    static constexpr auto __s = "__short";
    static constexpr auto __l = "__long";
};
struct __string_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __lconv_storage_Reflection {
    static constexpr auto __lc_ = "int";
    static constexpr auto __decimal_point_ = "int";
    static constexpr auto __thousands_sep_ = "int";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __int_curr_symbol_ = "int";
    static constexpr auto __currency_symbol_ = "int";
    static constexpr auto __mon_decimal_point_ = "int";
    static constexpr auto __mon_thousands_sep_ = "int";
    static constexpr auto __mon_grouping_ = "int";
    static constexpr auto __positive_sign_ = "int";
    static constexpr auto __negative_sign_ = "int";
};
struct locale_t_Reflection {
    static constexpr auto __locale_str_ = "const char *";
    static constexpr auto __lc_ = "__lconv_storage *";
};
struct once_flag_Reflection {
    static constexpr auto __state_ = "_State_type";
};
struct __call_once_param_Reflection {
    static constexpr auto __f_ = "_Fp &";
};
struct __uninitialized_tag_Reflection {
};
struct __no_destroy_Reflection {
    static constexpr auto __obj_ = "char[sizeof(_Tp)]";
};
struct locale_Reflection {
    static constexpr auto __locale_ = "__imp *";
};
struct facet_Reflection {
};
struct id_Reflection {
    static constexpr auto __flag_ = "once_flag";
    static constexpr auto __id_ = "int";
};
struct collate_Reflection {
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_base_Reflection {
};
struct ctype_Reflection {
};
struct ctype_Reflection {
    static constexpr auto __tab_ = "const mask *";
    static constexpr auto __del_ = "_Bool";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_base_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_byname_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_byname_Reflection {
};
struct numpunct_byname_Reflection {
};
struct error_category_Reflection {
};
struct __do_message_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct error_condition_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct is_error_code_enum_Reflection {
};
struct error_code_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct system_error_Reflection {
    static constexpr auto __ec_ = "error_code";
};
struct ios_base_Reflection {
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __precision_ = "streamsize";
    static constexpr auto __width_ = "streamsize";
    static constexpr auto __rdstate_ = "iostate";
    static constexpr auto __exceptions_ = "iostate";
    static constexpr auto __rdbuf_ = "void *";
    static constexpr auto __loc_ = "void *";
    static constexpr auto __fn_ = "event_callback *";
    static constexpr auto __index_ = "int *";
    static constexpr auto __event_size_ = "size_t";
    static constexpr auto __event_cap_ = "size_t";
    static constexpr auto __iarray_ = "long *";
    static constexpr auto __iarray_size_ = "size_t";
    static constexpr auto __iarray_cap_ = "size_t";
    static constexpr auto __parray_ = "void **";
    static constexpr auto __parray_size_ = "size_t";
    static constexpr auto __parray_cap_ = "size_t";
};
struct is_error_code_enum_Reflection {
};
struct failure_Reflection {
};
struct Init_Reflection {
};
struct _FillHelper_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
    static constexpr auto __set_ = "_Bool";
};
struct _SentinelValueFill_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
};
struct basic_ios_Reflection {
    static constexpr auto __tie_ = "basic_ostream<char_type, traits_type> *";
    static constexpr auto __fill_ = "_FillType";
};
struct mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_mutex_t";
};
struct defer_lock_t_Reflection {
};
struct try_to_lock_t_Reflection {
};
struct adopt_lock_t_Reflection {
};
struct unique_lock_Reflection {
    static constexpr auto __m_ = "mutex_type *";
    static constexpr auto __owns_ = "_Bool";
};
struct condition_variable_Reflection {
    static constexpr auto __cv_ = "__libcpp_condvar_t";
};
struct lock_guard_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct __thread_id_Reflection {
    static constexpr auto __id_ = "__libcpp_thread_id";
};
struct recursive_mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_recursive_mutex_t";
};
struct timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __locked_ = "_Bool";
};
struct recursive_timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __count_ = "size_t";
    static constexpr auto __id_ = "__thread_id";
};
struct scoped_lock_Reflection {
};
struct scoped_lock_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct scoped_lock_Reflection {
    static constexpr auto __t_ = "_MutexTuple";
};
struct __has_storage_type_Reflection {
};
struct __bit_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_reference_Reflection {
};
struct __bit_const_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_array_Reflection {
    static constexpr auto __size_ = "difference_type";
    static constexpr auto __word_ = "__storage_type[4]";
};
struct __bit_iterator_Reflection {
    static constexpr auto __seg_ = "int";
    static constexpr auto __ctz_ = "unsigned int";
};
struct __has_storage_type_Reflection {
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type[_N_words]";
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type";
};
struct __bitset_Reflection {
};
struct bitset_Reflection {
};
struct hash_Reflection {
};
struct basic_streambuf_Reflection {
    static constexpr auto __loc_ = "locale";
    static constexpr auto __binp_ = "char_type *";
    static constexpr auto __ninp_ = "char_type *";
    static constexpr auto __einp_ = "char_type *";
    static constexpr auto __bout_ = "char_type *";
    static constexpr auto __nout_ = "char_type *";
    static constexpr auto __eout_ = "char_type *";
};
struct __num_get_base_Reflection {
};
struct __num_get_Reflection {
};
struct num_get_Reflection {
};
struct __num_put_base_Reflection {
};
struct __num_put_Reflection {
};
struct num_put_Reflection {
};
struct time_base_Reflection {
};
struct __time_get_c_storage_Reflection {
};
struct time_get_Reflection {
};
struct __time_get_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct __time_get_storage_Reflection {
    static constexpr auto __weeks_ = "string_type[14]";
    static constexpr auto __months_ = "string_type[24]";
    static constexpr auto __am_pm_ = "string_type[2]";
    static constexpr auto __c_ = "string_type";
    static constexpr auto __r_ = "string_type";
    static constexpr auto __x_ = "string_type";
    static constexpr auto __X_ = "string_type";
};
struct time_get_byname_Reflection {
};
struct __time_put_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct time_put_Reflection {
};
struct time_put_byname_Reflection {
};
struct money_base_Reflection {
};
struct pattern_Reflection {
    static constexpr auto field = "char[4]";
};
struct moneypunct_Reflection {
};
struct moneypunct_byname_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __curr_symbol_ = "string_type";
    static constexpr auto __positive_sign_ = "string_type";
    static constexpr auto __negative_sign_ = "string_type";
    static constexpr auto __frac_digits_ = "int";
    static constexpr auto __pos_format_ = "pattern";
    static constexpr auto __neg_format_ = "pattern";
};
struct __money_get_Reflection {
};
struct money_get_Reflection {
};
struct __money_put_Reflection {
};
struct money_put_Reflection {
};
struct messages_base_Reflection {
};
struct messages_Reflection {
};
struct messages_byname_Reflection {
};
struct wstring_convert_Reflection {
    static constexpr auto __byte_err_string_ = "byte_string";
    static constexpr auto __wide_err_string_ = "wide_string";
    static constexpr auto __cvtptr_ = "_Codecvt *";
    static constexpr auto __cvtstate_ = "state_type";
    static constexpr auto __cvtcount_ = "size_t";
};
struct wbuffer_convert_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __bufptr_ = "int *";
    static constexpr auto __cv_ = "_Codecvt *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ostream_Reflection {
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
    static constexpr auto __os_ = "basic_ostream<_CharT, _Traits> &";
};
struct __is_ostreamable_Reflection {
};
struct __is_ostreamable_Reflection {
};
struct basic_istream_Reflection {
    static constexpr auto __gc_ = "streamsize";
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
};
struct __is_istreamable_Reflection {
};
struct __is_istreamable_Reflection {
};
struct basic_iostream_Reflection {
};
struct array_Reflection {
    static constexpr auto __elems_ = "_Tp[_Size]";
};
struct array_Reflection {
    static constexpr auto __elems_ = "int[sizeof(_ArrayInStructT)]";
};
struct _ArrayInStructT_Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct __temp_value_Reflection {
    static constexpr auto  = "union std::__temp_value::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\temp_value.h:31:3)";
    static constexpr auto __a = "_Alloc &";
};
struct _Reflection {
    static constexpr auto __v = "_Tp";
};
struct __split_buffer_Reflection {
    static constexpr auto __first_ = "int";
    static constexpr auto __begin_ = "int";
    static constexpr auto __end_ = "int";
    static constexpr auto __end_cap_ = "int";
    static constexpr auto __alloc_ = "allocator_type";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "const int";
    static constexpr auto __dest_ = "int *";
};
struct __container_traits_Reflection {
};
struct __deque_block_size_Reflection {
};
struct __deque_iterator_Reflection {
    static constexpr auto __m_iter_ = "__map_iterator";
    static constexpr auto __ptr_ = "pointer";
};
struct deque_Reflection {
    static constexpr auto __map_ = "int";
    static constexpr auto __start_ = "size_type";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __deque_block_range_Reflection {
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __end_ = "const pointer";
};
struct __deque_range_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "int";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __end_ = "const pointer";
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __base_ = "deque<_Tp, _Allocator> *const";
};
struct __container_traits_Reflection {
};
struct binary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct is_bind_expression_Reflection {
};
struct is_placeholder_Reflection {
};
struct __ph_Reflection {
};
struct is_placeholder_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_Reflection {
    static constexpr auto __f_ = "int";
    static constexpr auto __bound_args_ = "_Td";
};
struct is_bind_expression_Reflection {
};
struct __bind_r_Reflection {
};
struct is_bind_expression_Reflection {
};
struct __mem_fn_Reflection {
    static constexpr auto __f_ = "type";
};
struct unary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct __builtin_new_allocator_Reflection {
};
struct __builtin_new_deleter_Reflection {
    static constexpr auto __size_ = "size_t";
    static constexpr auto __align_ = "size_t";
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct bad_function_call_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __alloc_func_Reflection {
    static constexpr auto __func_ = "_Fp";
    static constexpr auto __alloc_ = "_Ap";
};
struct __default_alloc_func_Reflection {
    static constexpr auto __f_ = "_Fp";
};
struct __base_Reflection {
};
struct __func_Reflection {
    static constexpr auto __f_ = "__alloc_func<_Fp, _Alloc, _Rp (_ArgTypes...)>";
};
struct __value_func_Reflection {
    static constexpr auto __buf_ = "int";
    static constexpr auto __f_ = "__func *";
};
struct __policy_storage_Reflection {
    static constexpr auto __small = "char[16]";
    static constexpr auto __large = "void *";
};
struct __use_small_storage_Reflection {
};
struct __policy_Reflection {
    static constexpr auto __clone = "void *(*const)(const void *)";
    static constexpr auto __destroy = "void (*const)(void *)";
    static constexpr auto __is_null = "const _Bool";
    static constexpr auto __type_info = "const int *const";
};
struct __policy_invoker_Reflection {
    static constexpr auto __call_ = "__Call";
};
struct __policy_func_Reflection {
    static constexpr auto __buf_ = "__policy_storage";
    static constexpr auto __invoker_ = "__invoker";
    static constexpr auto __policy_ = "const __policy *";
};
struct function_Reflection {
    static constexpr auto __f_ = "__func";
};
struct __callable_Reflection {
};
struct __extract_key_fail_tag_Reflection {
};
struct __extract_key_self_tag_Reflection {
};
struct __extract_key_first_tag_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __hash_node_base_Reflection {
    static constexpr auto __next_ = "__next_pointer";
};
struct __hash_node_Reflection {
    static constexpr auto __hash_ = "size_t";
    static constexpr auto  = "union std::__hash_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__hash_table:124:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __hash_key_value_types_Reflection {
};
struct __hash_key_value_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_node_types_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __make_hash_node_types_Reflection {
};
struct __hash_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_const_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __hash_const_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __bucket_list_deallocator_Reflection {
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __hash_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __enforce_unordered_container_requirements_Reflection {
};
struct __hash_table_Reflection {
    static constexpr auto __bucket_list_ = "__bucket_list";
    static constexpr auto __first_node_ = "__first_node";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __hasher_ = "hasher";
    static constexpr auto __max_load_factor_ = "float";
    static constexpr auto __key_eq_ = "key_equal";
};
struct __basic_node_handle_Reflection {
    static constexpr auto __ptr_ = "__node_pointer_type";
    static constexpr auto __alloc_ = "optional<allocator_type>";
};
struct __set_node_handle_specifics_Reflection {
};
struct __map_node_handle_specifics_Reflection {
};
struct __insert_return_type_Reflection {
    static constexpr auto position = "_Iterator";
    static constexpr auto inserted = "_Bool";
    static constexpr auto node = "_NodeType";
};
struct __unordered_map_hasher_Reflection {
};
struct __unordered_map_hasher_Reflection {
    static constexpr auto __hash_ = "_Hash";
};
struct __unordered_map_equal_Reflection {
};
struct __unordered_map_equal_Reflection {
    static constexpr auto __pred_ = "_Pred";
};
struct __hash_map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __hash_value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __hash_map_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct __hash_map_const_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct unordered_map_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multimap_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct to_chars_result_Reflection {
    static constexpr auto ptr = "char *";
    static constexpr auto ec = "errc";
};
struct __traits_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "pointer";
    static constexpr auto __end_ = "pointer";
    static constexpr auto __cap_ = "pointer";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Tp, _Alloc> &";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __v_ = "vector<_Tp, _Alloc> &";
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __new_end_ = "const const_pointer";
};
struct __has_storage_type_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "__storage_pointer";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __cap_ = "size_type";
    static constexpr auto __alloc_ = "__storage_allocator";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Bool, type-parameter-0-0> &";
};
struct hash_Reflection {
};
struct __container_traits_Reflection {
};
struct _BMSkipTable_Reflection {
    static constexpr auto __default_value_ = "const value_type";
    static constexpr auto __table_ = "int";
};
struct _BMSkipTable_Reflection {
    static constexpr auto __table_ = "std::array<value_type, 256>";
};
struct boyer_moore_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
    static constexpr auto __suffix_ = "shared_ptr<difference_type[]>";
};
struct boyer_moore_horspool_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
};
struct default_searcher_Reflection {
    static constexpr auto __first_ = "_ForwardIterator";
    static constexpr auto __last_ = "_ForwardIterator";
    static constexpr auto __pred_ = "_BinaryPredicate";
};
struct __not_fn_op_Reflection {
};
struct __not_fn_t_Reflection {
};
struct queue_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct priority_queue_Reflection {
    static constexpr auto c = "container_type";
    static constexpr auto comp = "value_compare";
};
struct uses_allocator_Reflection {
};
struct stack_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct _FilesystemClock_Reflection {
};
struct __forward_list_node_value_type_Reflection {
};
struct __forward_node_traits_Reflection {
};
struct __forward_begin_node_Reflection {
    static constexpr auto __next_ = "pointer";
};
struct __forward_list_node_Reflection {
    static constexpr auto  = "union std::__forward_list_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\forward_list:328:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __forward_list_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_base_Reflection {
    static constexpr auto __before_begin_ = "__begin_node";
    static constexpr auto __alloc_ = "__node_allocator";
};
struct forward_list_Reflection {
};
struct __container_traits_Reflection {
};
struct basic_stringbuf_Reflection {
    static constexpr auto __str_ = "string_type";
    static constexpr auto __hm_ = "char_type *";
    static constexpr auto __mode_ = "class ios_base::openmode";
};
struct basic_istringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_ostringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_stringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct unordered_set_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multiset_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct null_mutex_Reflection {
};
struct null_atomic_int_Reflection {
    static constexpr auto value = "int";
};
struct type_identity_Reflection {
};
struct is_contiguous_Reflection {
};
struct monostate_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto data_ = "const Char *";
    static constexpr auto size_ = "size_t";
};
struct is_char_Reflection {
};
struct is_char_Reflection {
};
struct compile_string_Reflection {
};
struct is_compile_string_Reflection {
};
struct is_string_Reflection {
};
struct char_t_impl_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct error_handler_Reflection {
};
struct basic_format_parse_context_Reflection {
    static constexpr auto format_str_ = "basic_string_view<Char>";
    static constexpr auto next_arg_id_ = "int";
};
struct compile_parse_context_Reflection {
    static constexpr auto num_args_ = "int";
    static constexpr auto types_ = "const type *";
};
struct buffer_Reflection {
    static constexpr auto ptr_ = "T *";
    static constexpr auto size_ = "size_t";
    static constexpr auto capacity_ = "size_t";
};
struct buffer_traits_Reflection {
};
struct fixed_buffer_traits_Reflection {
    static constexpr auto count_ = "size_t";
    static constexpr auto limit_ = "size_t";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto data_ = "T[buffer_size]";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "T *";
    static constexpr auto data_ = "T[buffer_size]";
};
struct counting_buffer_Reflection {
    static constexpr auto data_ = "T[buffer_size]";
    static constexpr auto count_ = "size_t";
};
struct formatter_Reflection {
};
struct appender_Reflection {
};
struct view_Reflection {
};
struct named_arg_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto value = "const T &";
};
struct named_arg_info_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto id = "int";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)]";
    static constexpr auto named_args_ = "named_arg_info<Char>[NUM_NAMED_ARGS]";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[NUM_ARGS != 0 ? NUM_ARGS : +1]";
};
struct is_named_arg_Reflection {
};
struct is_statically_named_arg_Reflection {
};
struct is_named_arg_Reflection {
};
struct unformattable_Reflection {
};
struct unformattable_char_Reflection {
};
struct unformattable_pointer_Reflection {
};
struct string_value_Reflection {
    static constexpr auto data = "const Char *";
    static constexpr auto size = "size_t";
};
struct named_arg_value_Reflection {
    static constexpr auto data = "const named_arg_info<Char> *";
    static constexpr auto size = "size_t";
};
struct custom_value_Reflection {
    static constexpr auto value = "void *";
    static constexpr auto format = "void (*)(void *, parse_context &, Context &)";
};
struct value_Reflection {
    static constexpr auto  = "union fmt::detail::value::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1261:3)";
};
struct _Reflection {
    static constexpr auto no_value = "monostate";
    static constexpr auto int_value = "int";
    static constexpr auto uint_value = "unsigned int";
    static constexpr auto long_long_value = "long long";
    static constexpr auto ulong_long_value = "unsigned long long";
    static constexpr auto int128_value = "int128_opt";
    static constexpr auto uint128_value = "uint128_opt";
    static constexpr auto bool_value = "_Bool";
    static constexpr auto char_value = "char_type";
    static constexpr auto float_value = "float";
    static constexpr auto double_value = "double";
    static constexpr auto long_double_value = "long double";
    static constexpr auto pointer = "const void *";
    static constexpr auto string = "string_value<char_type>";
    static constexpr auto custom = "custom_value<Context>";
    static constexpr auto named_args = "named_arg_value<char_type>";
};
struct format_as_result_Reflection {
};
struct has_format_as_Reflection {
};
struct arg_mapper_Reflection {
};
struct formattable_Reflection {
};
struct is_output_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct locale_ref_Reflection {
    static constexpr auto locale_ = "const void *";
};
struct basic_format_arg_Reflection {
    static constexpr auto value_ = "detail::value<Context>";
    static constexpr auto type_ = "detail::type";
};
struct handle_Reflection {
    static constexpr auto custom_ = "detail::custom_value<Context>";
};
struct basic_format_context_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto args_ = "basic_format_args<basic_format_context<OutputIt, Char> >";
    static constexpr auto loc_ = "detail::locale_ref";
};
struct format_arg_store_Reflection {
    static constexpr auto data_ = "int";
};
struct basic_format_args_Reflection {
    static constexpr auto desc_ = "unsigned long long";
    static constexpr auto  = "union fmt::basic_format_args::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1902:3)";
};
struct _Reflection {
    static constexpr auto values_ = "const detail::value<Context> *";
    static constexpr auto args_ = "const format_arg *";
};
struct fill_t_Reflection {
    static constexpr auto data_ = "Char[max_size]";
    static constexpr auto size_ = "unsigned char";
};
struct format_specs_Reflection {
    static constexpr auto width = "int";
    static constexpr auto precision = "int";
    static constexpr auto type = "presentation_type";
    static constexpr auto align = "align_t";
    static constexpr auto sign = "sign_t";
    static constexpr auto alt = "_Bool";
    static constexpr auto localized = "_Bool";
    static constexpr auto fill = "detail::fill_t<Char>";
};
struct arg_ref_Reflection {
    static constexpr auto kind = "arg_id_kind";
    static constexpr auto val = "union value";
};
struct value_Reflection {
    static constexpr auto index = "int";
    static constexpr auto name = "basic_string_view<Char>";
};
struct dynamic_format_specs_Reflection {
    static constexpr auto width_ref = "arg_ref<Char>";
    static constexpr auto precision_ref = "arg_ref<Char>";
};
struct dynamic_spec_id_handler_Reflection {
    static constexpr auto ctx = "basic_format_parse_context<Char> &";
    static constexpr auto ref = "arg_ref<Char> &";
};
struct _Reflection {
    static constexpr auto current_state = "state";
};
struct _Reflection {
    static constexpr auto begin = "const Char *&";
    static constexpr auto specs = "dynamic_format_specs<Char> &";
    static constexpr auto arg_type = "type";
};
struct id_adapter_Reflection {
    static constexpr auto handler = "Handler &";
    static constexpr auto arg_id = "int";
};
struct writer_Reflection {
    static constexpr auto handler_ = "Handler &";
};
struct strip_named_arg_Reflection {
};
struct strip_named_arg_Reflection {
};
struct format_string_checker_Reflection {
    static constexpr auto types_ = "type[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
    static constexpr auto context_ = "parse_context_type";
    static constexpr auto parse_funcs_ = "parse_func[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
};
struct vformat_args_Reflection {
};
struct vformat_args_Reflection {
};
struct runtime_format_string_Reflection {
    static constexpr auto str = "basic_string_view<Char>";
};
struct basic_format_string_Reflection {
    static constexpr auto str_ = "basic_string_view<Char>";
};
struct format_to_n_result_Reflection {
    static constexpr auto out = "OutputIt";
    static constexpr auto size = "size_t";
};
struct __uintr_frame_Reflection {
    static constexpr auto rip = "unsigned long long";
    static constexpr auto rflags = "unsigned long long";
    static constexpr auto rsp = "unsigned long long";
};
struct __mm_loadh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadh_pi_v2f32";
};
struct __mm_loadl_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadl_pi_v2f32";
};
struct __mm_load_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __mm_load1_ps_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_store_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_load1_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __loadu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __loadu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __loadu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_load_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadl_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_store_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __mm_loadl_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __storeu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __storeu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __storeu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_storel_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __mm_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __mm256_broadcast_sd_struct_Reflection {
    static constexpr auto __d = "double";
};
struct __mm256_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __loadu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __storeu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __mm_load_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __mm_store_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __loadu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __storeu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __loadu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __storeu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __loadu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __storeu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __tile1024i_str_Reflection {
    static constexpr auto row = "const unsigned short";
    static constexpr auto col = "const unsigned short";
    static constexpr auto tile = "_tile1024i";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __mm_store_sbh_struct_Reflection {
    static constexpr auto __u = "__bf16";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct string_literal_Reflection {
};
struct uint128_fallback_Reflection {
    static constexpr auto lo_ = "int";
    static constexpr auto hi_ = "int";
};
struct _Reflection {
    static constexpr auto  = "F";
};
struct count_code_points_Reflection {
    static constexpr auto count = "size_t *";
};
struct _Reflection {
    static constexpr auto  = "const char *";
    static constexpr auto  = "size_t &";
    static constexpr auto  = "size_t &";
};
struct is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_locale_Reflection {
};
struct basic_memory_buffer_Reflection {
    static constexpr auto store_ = "T[SIZE]";
    static constexpr auto alloc_ = "Allocator";
};
struct is_contiguous_Reflection {
};
struct format_error_Reflection {
};
struct loc_value_Reflection {
    static constexpr auto value_ = "int";
};
struct format_facet_Reflection {
    static constexpr auto separator_ = "int";
    static constexpr auto grouping_ = "int";
    static constexpr auto decimal_point_ = "int";
};
struct _Reflection {
};
struct thousands_sep_result_Reflection {
    static constexpr auto grouping = "int";
    static constexpr auto thousands_sep = "Char";
};
struct format_decimal_result_Reflection {
    static constexpr auto begin = "Iterator";
    static constexpr auto end = "Iterator";
};
struct utf8_to_utf16_Reflection {
    static constexpr auto buffer_ = "int";
};
struct to_utf8_Reflection {
    static constexpr auto buffer_ = "Buffer";
};
struct decimal_fp_Reflection {
    static constexpr auto significand = "int";
    static constexpr auto exponent = "int";
};
struct basic_fp_Reflection {
    static constexpr auto f = "F";
    static constexpr auto e = "int";
};
struct _Reflection {
};
struct find_escape_result_Reflection {
    static constexpr auto begin = "const Char *";
    static constexpr auto end = "const Char *";
    static constexpr auto cp = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct write_int_data_Reflection {
    static constexpr auto size = "size_t";
    static constexpr auto padding = "size_t";
};
struct _Reflection {
};
struct digit_grouping_Reflection {
    static constexpr auto grouping_ = "int";
    static constexpr auto thousands_sep_ = "int";
};
struct next_state_Reflection {
    static constexpr auto group = "int";
    static constexpr auto pos = "int";
};
struct write_int_arg_Reflection {
    static constexpr auto abs_value = "UInt";
    static constexpr auto prefix = "unsigned int";
};
struct loc_writer_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto sep = "int";
    static constexpr auto grouping = "int";
    static constexpr auto decimal_point = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct counting_iterator_Reflection {
    static constexpr auto count_ = "size_t";
};
struct value_type_Reflection {
};
struct _Reflection {
};
struct float_specs_Reflection {
    static constexpr auto precision = "int";
    static constexpr auto format = "float_format";
    static constexpr auto sign = "sign_t";
    static constexpr auto upper = "_Bool";
    static constexpr auto locale = "_Bool";
    static constexpr auto binary32 = "_Bool";
    static constexpr auto showpoint = "_Bool";
};
struct big_decimal_fp_Reflection {
    static constexpr auto significand = "const char *";
    static constexpr auto significand_size = "int";
    static constexpr auto exponent = "int";
};
struct fallback_digit_grouping_Reflection {
};
struct has_isfinite_Reflection {
};
struct bigint_Reflection {
    static constexpr auto bigits_ = "int";
    static constexpr auto exp_ = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct default_arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto args = "int";
    static constexpr auto loc = "locale_ref";
};
struct arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto locale = "locale_ref";
};
struct width_checker_Reflection {
};
struct precision_checker_Reflection {
};
struct udl_arg_Reflection {
    static constexpr auto str = "const Char *";
};
struct format_int_Reflection {
    static constexpr auto buffer_ = "char[0]";
    static constexpr auto str_ = "char *";
};
struct bytes_Reflection {
    static constexpr auto data_ = "string_view";
};
struct group_digits_view_Reflection {
    static constexpr auto value = "T";
};
struct nested_view_Reflection {
    static constexpr auto fmt = "const int *";
    static constexpr auto value = "const T *";
};
struct nested_formatter_Reflection {
    static constexpr auto width_ = "int";
    static constexpr auto fill_ = "detail::fill_t<char>";
    static constexpr auto align_ = "align_t";
    static constexpr auto formatter_ = "int";
};
struct join_view_Reflection {
    static constexpr auto begin = "It";
    static constexpr auto end = "Sentinel";
    static constexpr auto sep = "basic_string_view<Char>";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
    static constexpr auto divisor = "int";
    static constexpr auto shift_amount = "int";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct _Reflection {
    static constexpr auto  = "class fmt::detail::utf8_to_utf16 *";
};
struct singleton_Reflection {
    static constexpr auto upper = "unsigned char";
    static constexpr auto lower_count = "unsigned char";
};
struct is_convertible_to_basic_format_string_Reflection {
};
struct is_convertible_to_any_format_string_Reflection {
};
struct spdlog_ex_Reflection {
    static constexpr auto msg_ = "int";
};
struct source_loc_Reflection {
    static constexpr auto filename = "const char *";
    static constexpr auto line = "int";
    static constexpr auto funcname = "const char *";
};
struct file_event_handlers_Reflection {
    static constexpr auto before_open = "std::function<void (const int &)>";
    static constexpr auto after_open = "std::function<void (const int &, int *)>";
    static constexpr auto before_close = "std::function<void (const int &, int *)>";
    static constexpr auto after_close = "std::function<void (const int &)>";
};
struct condition_variable_any_Reflection {
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __mut_ = "shared_ptr<mutex>";
};
struct __unlock_guard_Reflection {
    static constexpr auto __lock_ = "_Lock &";
};
struct __thread_struct_Reflection {
    static constexpr auto __p_ = "__thread_struct_imp *";
};
struct __thread_specific_ptr_Reflection {
    static constexpr auto __key_ = "__libcpp_tls_key";
};
struct hash_Reflection {
};
struct thread_Reflection {
    static constexpr auto __t_ = "__libcpp_thread_t";
};
struct periodic_worker_Reflection {
    static constexpr auto active_ = "_Bool";
    static constexpr auto worker_thread_ = "std::thread";
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto cv_ = "std::condition_variable";
};
struct registry_Reflection {
    static constexpr auto logger_map_mutex_ = "std::mutex";
    static constexpr auto flusher_mutex_ = "std::mutex";
    static constexpr auto tp_mutex_ = "std::recursive_mutex";
    static constexpr auto log_levels_ = "int";
    static constexpr auto formatter_ = "int";
    static constexpr auto global_log_level_ = "spdlog::level::level_enum";
    static constexpr auto flush_level_ = "level::level_enum";
    static constexpr auto err_handler_ = "err_handler";
    static constexpr auto tp_ = "std::shared_ptr<thread_pool>";
    static constexpr auto periodic_flusher_ = "int";
    static constexpr auto default_logger_ = "std::shared_ptr<logger>";
    static constexpr auto automatic_registration_ = "_Bool";
    static constexpr auto backtrace_n_messages_ = "size_t";
};
struct circular_q_Reflection {
    static constexpr auto max_items_ = "size_t";
    static constexpr auto head_ = "int";
    static constexpr auto tail_ = "int";
    static constexpr auto overrun_counter_ = "size_t";
    static constexpr auto v_ = "int";
};
struct log_msg_Reflection {
    static constexpr auto logger_name = "string_view_t";
    static constexpr auto level = "level::level_enum";
    static constexpr auto time = "log_clock::time_point";
    static constexpr auto thread_id = "size_t";
    static constexpr auto color_range_start = "size_t";
    static constexpr auto color_range_end = "size_t";
    static constexpr auto source = "source_loc";
    static constexpr auto payload = "string_view_t";
};
struct log_msg_buffer_Reflection {
    static constexpr auto buffer = "int";
};
struct backtracer_Reflection {
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto enabled_ = "std::atomic<_Bool>";
    static constexpr auto messages_ = "circular_q<log_msg_buffer>";
};
struct logger_Reflection {
    static constexpr auto name_ = "int";
    static constexpr auto sinks_ = "int";
    static constexpr auto level_ = "spdlog::level_t";
    static constexpr auto flush_level_ = "spdlog::level_t";
    static constexpr auto custom_err_handler_ = "err_handler";
    static constexpr auto tracer_ = "details::backtracer";
};
struct formatter_Reflection {
};
struct padding_info_Reflection {
    static constexpr auto width_ = "size_t";
    static constexpr auto side_ = "pad_side";
    static constexpr auto truncate_ = "_Bool";
    static constexpr auto enabled_ = "_Bool";
};
struct flag_formatter_Reflection {
    static constexpr auto padinfo_ = "padding_info";
};
struct custom_flag_formatter_Reflection {
};
struct pattern_formatter_Reflection {
    static constexpr auto pattern_ = "int";
    static constexpr auto eol_ = "int";
    static constexpr auto pattern_time_type_ = "pattern_time_type";
    static constexpr auto need_localtime_ = "_Bool";
    static constexpr auto cached_tm_ = "int";
    static constexpr auto last_log_secs_ = "std::chrono::seconds";
    static constexpr auto formatters_ = "int";
    static constexpr auto custom_handlers_ = "int";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_node_base_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_node_types_Reflection {
};
struct __make_tree_node_types_Reflection {
};
struct __tree_end_node_Reflection {
    static constexpr auto __left_ = "pointer";
};
struct __tree_node_base_Reflection {
    static constexpr auto __right_ = "pointer";
    static constexpr auto __parent_ = "__parent_pointer";
    static constexpr auto __is_black_ = "_Bool";
};
struct __tree_node_Reflection {
    static constexpr auto __value_ = "__node_value_type";
};
struct __tree_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __tree_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_Reflection {
    static constexpr auto __begin_node_ = "__iter_pointer";
    static constexpr auto __end_node_ = "__end_node_t";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __value_comp_ = "value_compare";
};
struct _DetachedTreeCache_Reflection {
    static constexpr auto __t_ = "__tree<_Tp, _Compare, _Allocator> *";
    static constexpr auto __cache_root_ = "__node_pointer";
    static constexpr auto __cache_elem_ = "__node_pointer";
};
struct __map_value_compare_Reflection {
};
struct __map_value_compare_Reflection {
    static constexpr auto __comp_ = "_Compare";
};
struct __map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __extract_key_value_types_Reflection {
};
struct __map_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct __map_const_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct map_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct multimap_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct mdc_Reflection {
};
struct scoped_padder_Reflection {
    static constexpr auto padinfo_ = "const padding_info &";
    static constexpr auto dest_ = "int &";
    static constexpr auto remaining_pad_ = "long";
    static constexpr auto spaces_ = "string_view_t";
};
struct null_scoped_padder_Reflection {
};
struct name_formatter_Reflection {
};
struct level_formatter_Reflection {
};
struct short_level_formatter_Reflection {
};
struct a_formatter_Reflection {
};
struct A_formatter_Reflection {
};
struct b_formatter_Reflection {
};
struct B_formatter_Reflection {
};
struct c_formatter_Reflection {
};
struct C_formatter_Reflection {
};
struct D_formatter_Reflection {
};
struct Y_formatter_Reflection {
};
struct m_formatter_Reflection {
};
struct d_formatter_Reflection {
};
struct H_formatter_Reflection {
};
struct I_formatter_Reflection {
};
struct M_formatter_Reflection {
};
struct S_formatter_Reflection {
};
struct e_formatter_Reflection {
};
struct f_formatter_Reflection {
};
struct F_formatter_Reflection {
};
struct E_formatter_Reflection {
};
struct p_formatter_Reflection {
};
struct r_formatter_Reflection {
};
struct R_formatter_Reflection {
};
struct T_formatter_Reflection {
};
struct z_formatter_Reflection {
    static constexpr auto last_update_ = "log_clock::time_point";
    static constexpr auto offset_minutes_ = "int";
};
struct t_formatter_Reflection {
};
struct pid_formatter_Reflection {
};
struct v_formatter_Reflection {
};
struct ch_formatter_Reflection {
    static constexpr auto ch_ = "char";
};
struct aggregate_formatter_Reflection {
    static constexpr auto str_ = "int";
};
struct color_start_formatter_Reflection {
};
struct color_stop_formatter_Reflection {
};
struct source_location_formatter_Reflection {
};
struct source_filename_formatter_Reflection {
};
struct short_filename_formatter_Reflection {
};
struct source_linenum_formatter_Reflection {
};
struct source_funcname_formatter_Reflection {
};
struct elapsed_formatter_Reflection {
    static constexpr auto last_message_time_ = "log_clock::time_point";
};
struct mdc_formatter_Reflection {
};
struct full_formatter_Reflection {
    static constexpr auto cache_timestamp_ = "std::chrono::seconds";
    static constexpr auto cached_datetime_ = "int";
    static constexpr auto mdc_formatter_ = "mdc_formatter<null_scoped_padder>";
};
struct sink_Reflection {
    static constexpr auto level_ = "level_t";
};
struct console_mutex_Reflection {
};
struct console_nullmutex_Reflection {
};
struct wincolor_sink_Reflection {
    static constexpr auto out_handle_ = "void *";
    static constexpr auto mutex_ = "mutex_t &";
    static constexpr auto should_do_colors_ = "_Bool";
    static constexpr auto formatter_ = "int";
    static constexpr auto colors_ = "std::array<int, level::n_levels>";
};
struct wincolor_stdout_sink_Reflection {
};
struct wincolor_stderr_sink_Reflection {
};
struct synchronous_factory_Reflection {
};
struct file_helper_Reflection {
    static constexpr auto open_tries_ = "const int";
    static constexpr auto open_interval_ = "const unsigned int";
    static constexpr auto fd_ = "int *";
    static constexpr auto filename_ = "int";
    static constexpr auto event_handlers_ = "file_event_handlers";
};
struct base_sink_Reflection {
    static constexpr auto formatter_ = "int";
    static constexpr auto mutex_ = "Mutex";
};
struct basic_file_sink_Reflection {
    static constexpr auto file_helper_ = "details::file_helper";
};
struct __iom_t1_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t2_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t3_Reflection {
    static constexpr auto __base_ = "int";
};
struct __iom_t4_Reflection {
    static constexpr auto __fill_ = "_CharT";
};
struct __iom_t5_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t6_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t7_Reflection {
    static constexpr auto __mon_ = "_MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t8_Reflection {
    static constexpr auto __mon_ = "const _MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t9_Reflection {
    static constexpr auto __tm_ = "int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __iom_t10_Reflection {
    static constexpr auto __tm_ = "const int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __quoted_output_proxy_Reflection {
    static constexpr auto __first_ = "const _CharT *";
    static constexpr auto __last_ = "const _CharT *";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __quoted_proxy_Reflection {
    static constexpr auto __string_ = "basic_string<_CharT, _Traits, _Allocator> &";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct _NullSentinel_Reflection {
};
struct __is_pathable_string_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_iter_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct path_Reflection {
    static constexpr auto __pn_ = "string_type";
};
struct basic_filebuf_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __file_ = "int *";
    static constexpr auto __cv_ = "const codecvt<char_type, char, state_type> *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __st_last_ = "state_type";
    static constexpr auto __om_ = "class ios_base::openmode";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ifstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_ofstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_fstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct file_status_Reflection {
    static constexpr auto __ft_ = "file_type";
    static constexpr auto __prms_ = "perms";
};
struct space_info_Reflection {
    static constexpr auto capacity = "int";
    static constexpr auto free = "int";
    static constexpr auto available = "int";
};
struct directory_entry_Reflection {
    static constexpr auto __p_ = "_Path";
    static constexpr auto __data_ = "__cached_data";
};
struct __cached_data_Reflection {
    static constexpr auto __size_ = "int";
    static constexpr auto __nlink_ = "int";
    static constexpr auto __write_time_ = "file_time_type";
    static constexpr auto __sym_perms_ = "perms";
    static constexpr auto __non_sym_perms_ = "perms";
    static constexpr auto __type_ = "file_type";
    static constexpr auto __cache_type_ = "_CacheType";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct __dir_element_proxy_Reflection {
    static constexpr auto __elem_ = "directory_entry";
};
struct directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__dir_stream>";
};
struct iterator_Reflection {
    static constexpr auto __stashed_elem_ = "path";
    static constexpr auto __path_ptr_ = "const path *";
    static constexpr auto __entry_ = "class path::__string_view";
    static constexpr auto __state_ = "_ParserState";
};
struct recursive_directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__shared_imp>";
    static constexpr auto __rec_ = "_Bool";
};
struct formatbuf_Reflection {
    static constexpr auto buffer_ = "buffer<char_type> &";
};
struct file_access_tag_Reflection {
};
struct file_access_Reflection {
};
struct streamed_view_Reflection {
    static constexpr auto value = "const T &";
};
struct basic_ostream_formatter_Reflection {
};
struct Logger_Reflection {
};
struct Event_Reflection {
    static constexpr auto Handled = "_Bool";
};
struct EventDispatcher_Reflection {
    static constexpr auto m_Event = "Event &";
};
struct WindowProperties_Reflection {
    static constexpr auto Title = "int";
    static constexpr auto Width = "unsigned int";
    static constexpr auto Height = "unsigned int";
};
struct Window_Reflection {
};
struct WindowResizeEvent_Reflection {
    static constexpr auto m_Width = "unsigned int";
    static constexpr auto m_Height = "unsigned int";
};
struct WindowCloseEvent_Reflection {
};
struct AppTickEvent_Reflection {
};
struct AppUpdateEvent_Reflection {
};
struct AppRenderEvent_Reflection {
};
struct Layer_Reflection {
    static constexpr auto m_DebugName = "int";
};
struct LayerStack_Reflection {
    static constexpr auto m_Layers = "int";
    static constexpr auto m_LayerInsertIndex = "unsigned int";
};
struct MouseMovedEvent_Reflection {
    static constexpr auto m_MouseX = "float";
    static constexpr auto m_MouseY = "float";
};
struct MouseScrolledEvent_Reflection {
    static constexpr auto m_XOffset = "float";
    static constexpr auto m_YOffset = "float";
};
struct MouseButtonEvent_Reflection {
    static constexpr auto m_Button = "int";
};
struct MouseButtonPressedEvent_Reflection {
};
struct MouseButtonReleasedEvent_Reflection {
};
struct KeyEvent_Reflection {
    static constexpr auto m_KeyCode = "int";
};
struct KeyPressedEvent_Reflection {
    static constexpr auto m_RepeatCount = "int";
};
struct KeyReleasedEvent_Reflection {
};
struct KeyTypedEvent_Reflection {
};
struct ImGuiLayer_Reflection {
};
struct RenderLayer_Reflection {
    static constexpr auto m_SceneHovered = "_Bool";
    static constexpr auto m_SavedX = "double";
    static constexpr auto m_SavedY = "double";
    static constexpr auto m_CursorLocked = "_Bool";
};
struct Component_Reflection {
    static constexpr auto gameObject = "std::weak_ptr<GameObject>";
};
struct GameObject_Reflection {
    static constexpr auto enabled = "_Bool";
    static constexpr auto components = "int";
    static constexpr auto children = "int";
    static constexpr auto parent = "std::weak_ptr<GameObject>";
    static constexpr auto name = "int";
    static constexpr auto transform = "std::shared_ptr<Transform>";
    static constexpr auto scene = "std::weak_ptr<Scene>";
};
struct GameLogicLayer_Reflection {
    static constexpr auto deltaTime = "float";
    static constexpr auto lastTime = "std::chrono::high_resolution_clock::time_point";
};
struct Application_Reflection {
    static constexpr auto m_Running = "_Bool";
    static constexpr auto m_Window = "int";
    static constexpr auto m_ImGuiLayer = "ImGuiLayer *";
    static constexpr auto m_RenderLayer = "RenderLayer *";
    static constexpr auto m_GameLogicLayer = "GameLogicLayer *";
    static constexpr auto m_LayerStack = "LayerStack";
};
struct is_int_Reflection {
};
struct is_int_Reflection {
};
struct is_int_Reflection {
};
struct is_aligned_Reflection {
};
struct storage_Reflection {
};
struct type_Reflection {
    static constexpr auto data = "T[L]";
};
struct storage_Reflection {
};
struct type_Reflection {
    static constexpr auto data = "T[L]";
};
struct storage_Reflection {
};
struct type_Reflection {
    static constexpr auto data = "T[4]";
};
struct genTypeTrait_Reflection {
};
struct init_gentype_Reflection {
};
struct init_gentype_Reflection {
};
struct init_gentype_Reflection {
};
struct vec_Reflection {
    static constexpr auto  = "union glm::vec<2, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec2.hpp:72:4)";
    static constexpr auto  = "union glm::vec<2, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec2.hpp:73:4)";
};
struct _Reflection {
    static constexpr auto x = "T";
    static constexpr auto r = "T";
    static constexpr auto s = "T";
};
struct _Reflection {
    static constexpr auto y = "T";
    static constexpr auto g = "T";
    static constexpr auto t = "T";
};
struct compute_equal_Reflection {
};
struct vec_Reflection {
    static constexpr auto  = "union glm::vec<3, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec3.hpp:77:4)";
    static constexpr auto  = "union glm::vec<3, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec3.hpp:78:4)";
    static constexpr auto  = "union glm::vec<3, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec3.hpp:79:4)";
};
struct _Reflection {
    static constexpr auto x = "T";
    static constexpr auto r = "T";
    static constexpr auto s = "T";
};
struct _Reflection {
    static constexpr auto y = "T";
    static constexpr auto g = "T";
    static constexpr auto t = "T";
};
struct _Reflection {
    static constexpr auto z = "T";
    static constexpr auto b = "T";
    static constexpr auto p = "T";
};
struct functor1_Reflection {
};
struct functor2_Reflection {
};
struct functor2_vec_sca_Reflection {
};
struct functor2_vec_int_Reflection {
};
struct functor2_vec_int_Reflection {
};
struct functor2_vec_int_Reflection {
};
struct functor2_vec_int_Reflection {
};
struct functor2_vec_int_Reflection {
};
struct compute_vec_add_Reflection {
};
struct compute_vec_sub_Reflection {
};
struct compute_vec_mul_Reflection {
};
struct compute_vec_div_Reflection {
};
struct compute_vec_mod_Reflection {
};
struct compute_splat_Reflection {
};
struct compute_vec_and_Reflection {
};
struct compute_vec_or_Reflection {
};
struct compute_vec_xor_Reflection {
};
struct compute_vec_shift_left_Reflection {
};
struct compute_vec_shift_right_Reflection {
};
struct compute_vec_equal_Reflection {
};
struct compute_vec_nequal_Reflection {
};
struct compute_vec_bitwise_not_Reflection {
};
struct compute_vec_add_Reflection {
};
struct compute_vec_sub_Reflection {
};
struct compute_vec_mul_Reflection {
};
struct compute_vec_div_Reflection {
};
struct compute_vec_mod_Reflection {
};
struct compute_vec_and_Reflection {
};
struct compute_vec_or_Reflection {
};
struct compute_vec_xor_Reflection {
};
struct compute_vec_shift_left_Reflection {
};
struct compute_vec_shift_right_Reflection {
};
struct compute_vec_equal_Reflection {
};
struct compute_vec_nequal_Reflection {
};
struct compute_vec_bitwise_not_Reflection {
};
struct vec_Reflection {
    static constexpr auto  = "union glm::vec<4, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec4.hpp:73:4)";
    static constexpr auto  = "union glm::vec<4, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec4.hpp:74:4)";
    static constexpr auto  = "union glm::vec<4, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec4.hpp:75:4)";
    static constexpr auto  = "union glm::vec<4, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/type_vec4.hpp:76:4)";
};
struct _Reflection {
    static constexpr auto x = "T";
    static constexpr auto r = "T";
    static constexpr auto s = "T";
};
struct _Reflection {
    static constexpr auto y = "T";
    static constexpr auto g = "T";
    static constexpr auto t = "T";
};
struct _Reflection {
    static constexpr auto z = "T";
    static constexpr auto b = "T";
    static constexpr auto p = "T";
};
struct _Reflection {
    static constexpr auto w = "T";
    static constexpr auto a = "T";
    static constexpr auto q = "T";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[2]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[2]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[2]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[3]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[3]";
};
struct compute_abs_Reflection {
};
struct compute_abs_Reflection {
};
struct compute_abs_Reflection {
};
struct vec_Reflection {
    static constexpr auto  = "union glm::vec<1, type-parameter-0-0, Q>::(anonymous at vendor/glm/glm/./ext/../detail/.././ext/../detail/../detail/type_vec1.hpp:66:4)";
};
struct _Reflection {
    static constexpr auto x = "T";
    static constexpr auto r = "T";
    static constexpr auto s = "T";
};
struct TMin_Reflection {
};
struct TMax_Reflection {
};
struct TAbs_Reflection {
};
struct TRound_Reflection {
};
struct TTrunc_Reflection {
};
struct TFmod_Reflection {
};
struct compute_abs_vector_Reflection {
};
struct compute_mix_vector_Reflection {
};
struct compute_mix_vector_Reflection {
};
struct compute_mix_scalar_Reflection {
};
struct compute_mix_scalar_Reflection {
};
struct compute_mix_Reflection {
};
struct compute_mix_Reflection {
};
struct compute_sign_Reflection {
};
struct compute_sign_Reflection {
};
struct compute_floor_Reflection {
};
struct compute_ceil_Reflection {
};
struct compute_fract_Reflection {
};
struct compute_trunc_Reflection {
};
struct compute_round_Reflection {
};
struct compute_mod_Reflection {
};
struct compute_fma_Reflection {
};
struct compute_min_vector_Reflection {
};
struct compute_max_vector_Reflection {
};
struct compute_clamp_vector_Reflection {
};
struct compute_step_vector_Reflection {
};
struct compute_smoothstep_vector_Reflection {
};
struct convert_vec3_to_vec4W0_Reflection {
};
struct convert_vec3_to_vec4WZ_Reflection {
};
struct convert_vec3_to_vec4W1_Reflection {
};
struct convert_vec4_to_vec3_Reflection {
};
struct convert_splat_Reflection {
};
struct _Reflection {
    static constexpr auto in = "float";
    static constexpr auto out = "int";
};
struct _Reflection {
    static constexpr auto in = "float";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "int";
    static constexpr auto out = "float";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "float";
};
struct mul3x3_Reflection {
};
struct mul3x3_Reflection {
};
struct mat_Reflection {
    static constexpr auto value = "col_type[3]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[4]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[4]";
};
struct mat_Reflection {
    static constexpr auto value = "col_type[4]";
};
struct compute_log2_Reflection {
};
struct compute_sqrt_Reflection {
};
struct compute_inversesqrt_Reflection {
};
struct compute_inversesqrt_Reflection {
};
struct compute_length_Reflection {
};
struct compute_distance_Reflection {
};
struct compute_dot_Reflection {
};
struct compute_dot_Reflection {
};
struct compute_dot_Reflection {
};
struct compute_dot_Reflection {
};
struct compute_dot_Reflection {
};
struct compute_cross_Reflection {
};
struct compute_normalize_Reflection {
};
struct compute_faceforward_Reflection {
};
struct compute_reflect_Reflection {
};
struct compute_refract_Reflection {
};
struct mul4x4_Reflection {
};
struct mul4x4_Reflection {
};
struct mul4x4_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct outerProduct_trait_Reflection {
};
struct compute_matrixCompMult_Reflection {
};
struct compute_matrixCompMult_type_Reflection {
};
struct compute_outerProduct_Reflection {
};
struct compute_outerProduct_type_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_Reflection {
};
struct compute_transpose_type_Reflection {
};
struct compute_determinant_Reflection {
};
struct compute_determinant_Reflection {
};
struct compute_determinant_Reflection {
};
struct compute_determinant_Reflection {
};
struct compute_determinant_type_Reflection {
};
struct compute_inverse_Reflection {
};
struct compute_inverse_Reflection {
};
struct inv3x3_Reflection {
};
struct inv3x3_Reflection {
};
struct inv3x3_Reflection {
};
struct compute_inverse_Reflection {
};
struct compute_inverse_Reflection {
};
struct uif32_Reflection {
    static constexpr auto f = "float";
    static constexpr auto i = "unsigned int";
};
struct _Reflection {
    static constexpr auto in = "unsigned short[2]";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "unsigned short[2]";
};
struct _Reflection {
    static constexpr auto in = "short[2]";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "short[2]";
};
struct _Reflection {
    static constexpr auto in = "unsigned char[4]";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "unsigned char[4]";
};
struct _Reflection {
    static constexpr auto in = "signed char[4]";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "signed char[4]";
};
struct _Reflection {
    static constexpr auto in = "uint[2]";
    static constexpr auto out = "double";
};
struct _Reflection {
    static constexpr auto in = "double";
    static constexpr auto out = "uint[2]";
};
struct _Reflection {
    static constexpr auto in = "short[2]";
    static constexpr auto out = "uint";
};
struct _Reflection {
    static constexpr auto in = "uint";
    static constexpr auto out = "short[2]";
};
struct compute_bitfieldReverseStep_Reflection {
};
struct compute_bitfieldReverseStep_Reflection {
};
struct compute_bitfieldBitCountStep_Reflection {
};
struct compute_bitfieldBitCountStep_Reflection {
};
struct compute_findLSB_Reflection {
};
struct compute_findMSB_step_vec_Reflection {
};
struct compute_findMSB_step_vec_Reflection {
};
struct compute_findMSB_vec_Reflection {
};
struct Input_Reflection {
};
struct WindowsInput_Reflection {
};
struct EditorCamera_Reflection {
    static constexpr auto Position = "glm::vec3";
    static constexpr auto Front = "glm::vec3";
    static constexpr auto Up = "glm::vec3";
    static constexpr auto Right = "glm::vec3";
    static constexpr auto WorldUp = "glm::vec3";
    static constexpr auto Yaw = "float";
    static constexpr auto Pitch = "float";
    static constexpr auto MovementSpeed = "float";
    static constexpr auto ShiftSpeed = "float";
    static constexpr auto Speed = "float";
    static constexpr auto MouseSensitivity = "float";
    static constexpr auto Zoom = "float";
};
struct Light_Reflection {
    static constexpr auto type = "LightType";
    static constexpr auto intensity = "float";
    static constexpr auto color = "glm::vec3";
    static constexpr auto innerCutOff = "float";
    static constexpr auto outerCutOff = "float";
};
struct LightManager_Reflection {
    static constexpr auto lights = "int";
    static constexpr auto maxLights = "int";
    static constexpr auto mainLight = "std::shared_ptr<Light>";
};
struct gladGLversionStruct_Reflection {
    static constexpr auto major = "int";
    static constexpr auto minor = "int";
};
struct Shader_Reflection {
    static constexpr auto ID = "unsigned int";
    static constexpr auto vertexPath = "int";
    static constexpr auto fragmentPath = "int";
    static constexpr auto geometryPath = "int";
    static constexpr auto fragmentID = "GLuint";
    static constexpr auto vertexID = "GLuint";
    static constexpr auto geometryID = "GLuint";
};
struct _Reflection {
    static constexpr auto read = "int (*)(void *, char *, int)";
    static constexpr auto skip = "void (*)(void *, int)";
    static constexpr auto eof = "int (*)(void *)";
};
struct aiVector3t_Reflection {
    static constexpr auto x = "TReal";
    static constexpr auto y = "TReal";
    static constexpr auto z = "TReal";
};
struct aiVector2t_Reflection {
    static constexpr auto x = "TReal";
    static constexpr auto y = "TReal";
};
struct aiColor4t_Reflection {
    static constexpr auto r = "TReal";
    static constexpr auto g = "TReal";
    static constexpr auto b = "TReal";
    static constexpr auto a = "TReal";
};
struct aiMatrix3x3t_Reflection {
    static constexpr auto a1 = "TReal";
    static constexpr auto a2 = "TReal";
    static constexpr auto a3 = "TReal";
    static constexpr auto b1 = "TReal";
    static constexpr auto b2 = "TReal";
    static constexpr auto b3 = "TReal";
    static constexpr auto c1 = "TReal";
    static constexpr auto c2 = "TReal";
    static constexpr auto c3 = "TReal";
};
struct aiMatrix4x4t_Reflection {
    static constexpr auto a1 = "TReal";
    static constexpr auto a2 = "TReal";
    static constexpr auto a3 = "TReal";
    static constexpr auto a4 = "TReal";
    static constexpr auto b1 = "TReal";
    static constexpr auto b2 = "TReal";
    static constexpr auto b3 = "TReal";
    static constexpr auto b4 = "TReal";
    static constexpr auto c1 = "TReal";
    static constexpr auto c2 = "TReal";
    static constexpr auto c3 = "TReal";
    static constexpr auto c4 = "TReal";
    static constexpr auto d1 = "TReal";
    static constexpr auto d2 = "TReal";
    static constexpr auto d3 = "TReal";
    static constexpr auto d4 = "TReal";
};
struct aiQuaterniont_Reflection {
    static constexpr auto w = "TReal";
    static constexpr auto x = "TReal";
    static constexpr auto y = "TReal";
    static constexpr auto z = "TReal";
};
struct AllocateFromAssimpHeap_Reflection {
};
struct aiPlane_Reflection {
    static constexpr auto a = "ai_real";
    static constexpr auto b = "ai_real";
    static constexpr auto c = "ai_real";
    static constexpr auto d = "ai_real";
};
struct aiRay_Reflection {
    static constexpr auto pos = "aiVector3D";
    static constexpr auto dir = "aiVector3D";
};
struct aiColor3D_Reflection {
    static constexpr auto r = "ai_real";
    static constexpr auto g = "ai_real";
    static constexpr auto b = "ai_real";
};
struct aiString_Reflection {
    static constexpr auto length = "size_t";
    static constexpr auto data = "char[1024]";
};
struct aiMemoryInfo_Reflection {
    static constexpr auto textures = "unsigned int";
    static constexpr auto materials = "unsigned int";
    static constexpr auto meshes = "unsigned int";
    static constexpr auto nodes = "unsigned int";
    static constexpr auto animations = "unsigned int";
    static constexpr auto cameras = "unsigned int";
    static constexpr auto lights = "unsigned int";
    static constexpr auto total = "unsigned int";
};
struct Importer_Reflection {
    static constexpr auto pimpl = "ImporterPimpl *";
};
struct aiTexel_Reflection {
    static constexpr auto b = "unsigned char";
    static constexpr auto g = "unsigned char";
    static constexpr auto r = "unsigned char";
    static constexpr auto a = "unsigned char";
};
struct aiTexture_Reflection {
    static constexpr auto mWidth = "unsigned int";
    static constexpr auto mHeight = "unsigned int";
    static constexpr auto achFormatHint = "char[9]";
    static constexpr auto pcData = "aiTexel *";
    static constexpr auto mFilename = "aiString";
};
struct aiFace_Reflection {
    static constexpr auto mNumIndices = "unsigned int";
    static constexpr auto mIndices = "unsigned int *";
};
struct aiVertexWeight_Reflection {
    static constexpr auto mVertexId = "unsigned int";
    static constexpr auto mWeight = "float";
};
struct aiBone_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mNumWeights = "unsigned int";
    static constexpr auto mWeights = "aiVertexWeight *";
    static constexpr auto mOffsetMatrix = "aiMatrix4x4";
};
struct aiAnimMesh_Reflection {
    static constexpr auto mVertices = "aiVector3D *";
    static constexpr auto mNormals = "aiVector3D *";
    static constexpr auto mTangents = "aiVector3D *";
    static constexpr auto mBitangents = "aiVector3D *";
    static constexpr auto mColors = "aiColor4D *[8]";
    static constexpr auto mTextureCoords = "aiVector3D *[8]";
    static constexpr auto mNumVertices = "unsigned int";
    static constexpr auto mWeight = "float";
};
struct aiMesh_Reflection {
    static constexpr auto mPrimitiveTypes = "unsigned int";
    static constexpr auto mNumVertices = "unsigned int";
    static constexpr auto mNumFaces = "unsigned int";
    static constexpr auto mVertices = "aiVector3D *";
    static constexpr auto mNormals = "aiVector3D *";
    static constexpr auto mTangents = "aiVector3D *";
    static constexpr auto mBitangents = "aiVector3D *";
    static constexpr auto mColors = "aiColor4D *[8]";
    static constexpr auto mTextureCoords = "aiVector3D *[8]";
    static constexpr auto mNumUVComponents = "unsigned int[8]";
    static constexpr auto mFaces = "aiFace *";
    static constexpr auto mNumBones = "unsigned int";
    static constexpr auto mBones = "aiBone **";
    static constexpr auto mMaterialIndex = "unsigned int";
    static constexpr auto mName = "aiString";
    static constexpr auto mNumAnimMeshes = "unsigned int";
    static constexpr auto mAnimMeshes = "aiAnimMesh **";
    static constexpr auto mMethod = "unsigned int";
};
struct aiLight_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mType = "aiLightSourceType";
    static constexpr auto mPosition = "aiVector3D";
    static constexpr auto mDirection = "aiVector3D";
    static constexpr auto mUp = "aiVector3D";
    static constexpr auto mAttenuationConstant = "float";
    static constexpr auto mAttenuationLinear = "float";
    static constexpr auto mAttenuationQuadratic = "float";
    static constexpr auto mColorDiffuse = "aiColor3D";
    static constexpr auto mColorSpecular = "aiColor3D";
    static constexpr auto mColorAmbient = "aiColor3D";
    static constexpr auto mAngleInnerCone = "float";
    static constexpr auto mAngleOuterCone = "float";
    static constexpr auto mSize = "aiVector2D";
};
struct aiCamera_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mPosition = "aiVector3D";
    static constexpr auto mUp = "aiVector3D";
    static constexpr auto mLookAt = "aiVector3D";
    static constexpr auto mHorizontalFOV = "float";
    static constexpr auto mClipPlaneNear = "float";
    static constexpr auto mClipPlaneFar = "float";
    static constexpr auto mAspect = "float";
};
struct aiUVTransform_Reflection {
    static constexpr auto mTranslation = "aiVector2D";
    static constexpr auto mScaling = "aiVector2D";
    static constexpr auto mRotation = "ai_real";
};
struct aiMaterialProperty_Reflection {
    static constexpr auto mKey = "aiString";
    static constexpr auto mSemantic = "unsigned int";
    static constexpr auto mIndex = "unsigned int";
    static constexpr auto mDataLength = "unsigned int";
    static constexpr auto mType = "aiPropertyTypeInfo";
    static constexpr auto mData = "char *";
};
struct aiMaterial_Reflection {
    static constexpr auto mProperties = "aiMaterialProperty **";
    static constexpr auto mNumProperties = "unsigned int";
    static constexpr auto mNumAllocated = "unsigned int";
};
struct aiVectorKey_Reflection {
    static constexpr auto mTime = "double";
    static constexpr auto mValue = "aiVector3D";
};
struct aiQuatKey_Reflection {
    static constexpr auto mTime = "double";
    static constexpr auto mValue = "aiQuaternion";
};
struct aiMeshKey_Reflection {
    static constexpr auto mTime = "double";
    static constexpr auto mValue = "unsigned int";
};
struct aiMeshMorphKey_Reflection {
    static constexpr auto mTime = "double";
    static constexpr auto mValues = "unsigned int *";
    static constexpr auto mWeights = "double *";
    static constexpr auto mNumValuesAndWeights = "unsigned int";
};
struct aiNodeAnim_Reflection {
    static constexpr auto mNodeName = "aiString";
    static constexpr auto mNumPositionKeys = "unsigned int";
    static constexpr auto mPositionKeys = "aiVectorKey *";
    static constexpr auto mNumRotationKeys = "unsigned int";
    static constexpr auto mRotationKeys = "aiQuatKey *";
    static constexpr auto mNumScalingKeys = "unsigned int";
    static constexpr auto mScalingKeys = "aiVectorKey *";
    static constexpr auto mPreState = "aiAnimBehaviour";
    static constexpr auto mPostState = "aiAnimBehaviour";
};
struct aiMeshAnim_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mNumKeys = "unsigned int";
    static constexpr auto mKeys = "aiMeshKey *";
};
struct aiMeshMorphAnim_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mNumKeys = "unsigned int";
    static constexpr auto mKeys = "aiMeshMorphKey *";
};
struct aiAnimation_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mDuration = "double";
    static constexpr auto mTicksPerSecond = "double";
    static constexpr auto mNumChannels = "unsigned int";
    static constexpr auto mChannels = "aiNodeAnim **";
    static constexpr auto mNumMeshChannels = "unsigned int";
    static constexpr auto mMeshChannels = "aiMeshAnim **";
    static constexpr auto mNumMorphMeshChannels = "unsigned int";
    static constexpr auto mMorphMeshChannels = "aiMeshMorphAnim **";
};
struct Interpolator_Reflection {
};
struct Interpolator_Reflection {
};
struct Interpolator_Reflection {
};
struct Interpolator_Reflection {
};
struct Interpolator_Reflection {
};
struct Interpolator_Reflection {
};
struct aiMetadataEntry_Reflection {
    static constexpr auto mType = "aiMetadataType";
    static constexpr auto mData = "void *";
};
struct aiMetadata_Reflection {
    static constexpr auto mNumProperties = "unsigned int";
    static constexpr auto mKeys = "aiString *";
    static constexpr auto mValues = "aiMetadataEntry *";
};
struct aiNode_Reflection {
    static constexpr auto mName = "aiString";
    static constexpr auto mTransformation = "aiMatrix4x4";
    static constexpr auto mParent = "aiNode *";
    static constexpr auto mNumChildren = "unsigned int";
    static constexpr auto mChildren = "aiNode **";
    static constexpr auto mNumMeshes = "unsigned int";
    static constexpr auto mMeshes = "unsigned int *";
    static constexpr auto mMetaData = "aiMetadata *";
};
struct aiScene_Reflection {
    static constexpr auto mFlags = "unsigned int";
    static constexpr auto mRootNode = "aiNode *";
    static constexpr auto mNumMeshes = "unsigned int";
    static constexpr auto mMeshes = "aiMesh **";
    static constexpr auto mNumMaterials = "unsigned int";
    static constexpr auto mMaterials = "aiMaterial **";
    static constexpr auto mNumAnimations = "unsigned int";
    static constexpr auto mAnimations = "aiAnimation **";
    static constexpr auto mNumTextures = "unsigned int";
    static constexpr auto mTextures = "aiTexture **";
    static constexpr auto mNumLights = "unsigned int";
    static constexpr auto mLights = "aiLight **";
    static constexpr auto mNumCameras = "unsigned int";
    static constexpr auto mCameras = "aiCamera **";
    static constexpr auto mMetaData = "aiMetadata *";
    static constexpr auto mPrivate = "void *";
};
struct GLFWvidmode_Reflection {
    static constexpr auto width = "int";
    static constexpr auto height = "int";
    static constexpr auto redBits = "int";
    static constexpr auto greenBits = "int";
    static constexpr auto blueBits = "int";
    static constexpr auto refreshRate = "int";
};
struct GLFWgammaramp_Reflection {
    static constexpr auto red = "unsigned short *";
    static constexpr auto green = "unsigned short *";
    static constexpr auto blue = "unsigned short *";
    static constexpr auto size = "unsigned int";
};
struct GLFWimage_Reflection {
    static constexpr auto width = "int";
    static constexpr auto height = "int";
    static constexpr auto pixels = "unsigned char *";
};
struct GLFWgamepadstate_Reflection {
    static constexpr auto buttons = "unsigned char[15]";
    static constexpr auto axes = "float[6]";
};
struct GLFWallocator_Reflection {
    static constexpr auto allocate = "GLFWallocatefun";
    static constexpr auto reallocate = "GLFWreallocatefun";
    static constexpr auto deallocate = "GLFWdeallocatefun";
    static constexpr auto user = "void *";
};
struct Texture_Reflection {
    static constexpr auto id = "unsigned int";
    static constexpr auto type = "int";
    static constexpr auto path = "int";
};
struct Material_Reflection {
    static constexpr auto AlbedoTexture = "std::shared_ptr<Texture>";
    static constexpr auto AlbedoColor = "glm::vec4";
    static constexpr auto MetallicTexture = "std::shared_ptr<Texture>";
    static constexpr auto Metallic = "float";
    static constexpr auto RoughnessTexture = "std::shared_ptr<Texture>";
    static constexpr auto Roughness = "float";
    static constexpr auto NormalTexture = "std::shared_ptr<Texture>";
    static constexpr auto shader = "std::shared_ptr<Shader>";
};
struct LightData_Reflection {
    static constexpr auto position = "glm::vec4";
    static constexpr auto direction = "glm::vec4";
    static constexpr auto lightColor = "glm::vec4";
    static constexpr auto projection = "glm::mat4";
    static constexpr auto view = "glm::mat4";
};
struct Vertex_Reflection {
    static constexpr auto Position = "glm::vec3";
    static constexpr auto Normal = "glm::vec3";
    static constexpr auto TexCoords = "glm::vec2";
    static constexpr auto Tangent = "glm::vec3";
    static constexpr auto Bitangent = "glm::vec3";
    static constexpr auto m_BoneIDs = "int[4]";
    static constexpr auto m_Weights = "float[4]";
};
struct Mesh_Reflection {
    static constexpr auto vertices = "int";
    static constexpr auto indices = "int";
    static constexpr auto VAO = "unsigned int";
    static constexpr auto SSBO = "unsigned int";
    static constexpr auto VBO = "unsigned int";
    static constexpr auto EBO = "unsigned int";
    static constexpr auto SHADOW_WIDTH = "const unsigned int";
    static constexpr auto SHADOW_HEIGHT = "const unsigned int";
    static constexpr auto depthMap = "unsigned int";
};
struct Renderer_Reflection {
    static constexpr auto mesh = "std::shared_ptr<Mesh>";
    static constexpr auto material = "std::shared_ptr<Material>";
    static constexpr auto modelMatrix = "glm::mat4";
    static constexpr auto viewMatrix = "glm::mat4";
    static constexpr auto projectionMatrix = "glm::mat4";
    static constexpr auto transform = "std::shared_ptr<Transform>";
};
struct RenderManager_Reflection {
    static constexpr auto shaderToRenderer = "int";
    static constexpr auto renderers = "int";
    static constexpr auto depthCubeMaps = "int";
    static constexpr auto additionalDepthFBOs = "int";
    static constexpr auto DirectionalShadowShader = "std::shared_ptr<Shader>";
    static constexpr auto AdditionalShadowShader = "std::shared_ptr<Shader>";
    static constexpr auto depthMapFBO = "unsigned int";
    static constexpr auto depthMap = "unsigned int";
    static constexpr auto MAIN_SHADOW_WIDTH = "const unsigned int";
    static constexpr auto MAIN_SHADOW_HEIGHT = "const unsigned int";
    static constexpr auto ADDITIONAL_SHADOW_WIDTH = "const unsigned int";
    static constexpr auto ADDITIONAL_SHADOW_HEIGHT = "const unsigned int";
    static constexpr auto lightManager = "std::shared_ptr<LightManager>";
    static constexpr auto camera = "std::shared_ptr<EditorCamera>";
    static constexpr auto mainLightView = "glm::mat4";
    static constexpr auto mainLightProj = "glm::mat4";
    static constexpr auto pointLights = "int";
    static constexpr auto screenShader = "std::shared_ptr<Shader>";
    static constexpr auto quadVertices = "float[24]";
    static constexpr auto framebuffer = "unsigned int";
    static constexpr auto textureColorbuffer = "unsigned int";
    static constexpr auto rbo = "unsigned int";
    static constexpr auto quadVAO = "unsigned int";
    static constexpr auto quadVBO = "unsigned int";
    static constexpr auto skyboxVAO = "unsigned int";
    static constexpr auto skyboxVBO = "unsigned int";
    static constexpr auto skyboxTexture = "unsigned int";
    static constexpr auto hdrTexture = "unsigned int";
    static constexpr auto irradianceMap = "unsigned int";
    static constexpr auto prefilterMap = "unsigned int";
    static constexpr auto brdfLUTTexture = "unsigned int";
    static constexpr auto irradianceShader = "std::shared_ptr<Shader>";
    static constexpr auto skyboxShader = "std::shared_ptr<Shader>";
    static constexpr auto skyboxMappingShader = "std::shared_ptr<Shader>";
    static constexpr auto preFilterShader = "std::shared_ptr<Shader>";
    static constexpr auto brdfShader = "std::shared_ptr<Shader>";
    static constexpr auto skyboxLocation = "int";
    static constexpr auto m_Width = "int";
    static constexpr auto m_Height = "int";
    static constexpr auto skyboxVertices = "float[108]";
};
struct Scene_Reflection {
    static constexpr auto camera = "std::shared_ptr<EditorCamera>";
    static constexpr auto lightManager = "std::shared_ptr<LightManager>";
    static constexpr auto renderManager = "int";
    static constexpr auto gameObjects = "int";
    static constexpr auto gameObjectsToDelete = "int";
};
struct SceneManager_Reflection {
    static constexpr auto currentScene = "std::shared_ptr<Scene>";
};
struct fpos_Reflection {
    static constexpr auto __st_ = "_StateT";
    static constexpr auto __off_ = "streamoff";
};
struct enable_if_Reflection {
};
struct enable_if_Reflection {
};
struct integral_constant_Reflection {
};
struct remove_cv_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct __equal_tag_Reflection {
};
struct __plus_tag_Reflection {
};
struct __totally_ordered_less_tag_Reflection {
};
struct __equal_to_Reflection {
};
struct __less_Reflection {
};
struct __less_Reflection {
};
struct __debug_less_Reflection {
    static constexpr auto __comp_ = "_Compare &";
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct is_floating_point_Reflection {
};
struct is_arithmetic_Reflection {
};
struct is_signed_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct is_convertible_Reflection {
};
struct is_function_Reflection {
};
struct is_reference_Reflection {
};
struct is_lvalue_reference_Reflection {
};
struct is_rvalue_reference_Reflection {
};
struct remove_all_extents_Reflection {
};
struct is_destructible_Reflection {
};
struct is_nothrow_destructible_Reflection {
};
struct is_same_Reflection {
};
struct __libcpp_is_referenceable_Reflection {
};
struct add_lvalue_reference_Reflection {
};
struct add_rvalue_reference_Reflection {
};
struct is_constructible_Reflection {
};
struct is_copy_constructible_Reflection {
};
struct is_move_constructible_Reflection {
};
struct is_default_constructible_Reflection {
};
struct _IfImpl_Reflection {
};
struct _IfImpl_Reflection {
};
struct conditional_Reflection {
};
struct conditional_Reflection {
};
struct is_void_Reflection {
};
struct remove_reference_Reflection {
};
struct add_pointer_Reflection {
};
struct is_array_Reflection {
};
struct remove_extent_Reflection {
};
struct decay_Reflection {
};
struct __type_identity_Reflection {
};
struct __empty_Reflection {
};
struct common_type_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct is_class_Reflection {
};
struct is_enum_Reflection {
};
struct is_union_Reflection {
};
struct extent_Reflection {
};
struct is_nothrow_assignable_Reflection {
};
struct is_nothrow_copy_assignable_Reflection {
};
struct is_nothrow_move_assignable_Reflection {
};
struct is_nothrow_constructible_Reflection {
};
struct is_nothrow_copy_constructible_Reflection {
};
struct is_nothrow_move_constructible_Reflection {
};
struct is_nothrow_default_constructible_Reflection {
};
struct is_assignable_Reflection {
};
struct is_copy_assignable_Reflection {
};
struct is_move_assignable_Reflection {
};
struct is_swappable_with_Reflection {
};
struct is_swappable_Reflection {
};
struct is_nothrow_swappable_with_Reflection {
};
struct is_nothrow_swappable_Reflection {
};
struct is_object_Reflection {
};
struct __nat_Reflection {
};
struct __type_list_Reflection {
};
struct __find_first_Reflection {
};
struct __find_first_Reflection {
};
struct make_signed_Reflection {
};
struct _OrImpl_Reflection {
};
struct _OrImpl_Reflection {
};
struct disjunction_Reflection {
};
struct remove_const_Reflection {
};
struct input_iterator_tag_Reflection {
};
struct output_iterator_tag_Reflection {
};
struct forward_iterator_tag_Reflection {
};
struct bidirectional_iterator_tag_Reflection {
};
struct random_access_iterator_tag_Reflection {
};
struct __iter_traits_cache_Reflection {
};
struct __iter_concept_concept_test_Reflection {
};
struct __iter_concept_category_test_Reflection {
};
struct __iter_concept_random_fallback_Reflection {
};
struct __test_iter_concept_Reflection {
};
struct __iter_concept_cache_Reflection {
};
struct __has_iterator_typedefs_Reflection {
};
struct __has_iterator_category_Reflection {
};
struct __has_iterator_concept_Reflection {
};
struct __iterator_traits_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __is_callable_Reflection {
};
struct initializer_list_Reflection {
    static constexpr auto __begin_ = "const _Ep *";
    static constexpr auto __size_ = "size_t";
};
struct __is_identity_Reflection {
};
struct __identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct is_base_of_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct is_member_pointer_Reflection {
};
struct is_member_object_pointer_Reflection {
};
struct is_member_function_pointer_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __invokable_r_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __invoke_of_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct is_invocable_Reflection {
};
struct is_invocable_r_Reflection {
};
struct is_nothrow_invocable_Reflection {
};
struct is_nothrow_invocable_r_Reflection {
};
struct invoke_result_Reflection {
};
struct __has_specialization_Reflection {
};
struct __has_specialization_Reflection {
};
struct __all_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct __has_pointer_Reflection {
};
struct __has_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __has_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __has_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_impl_Reflection {
};
struct pointer_traits_Reflection {
};
struct pointer_traits_Reflection {
};
struct __nat_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasArrow_Reflection {
};
struct _HasArrow_Reflection {
};
struct _IsFancyPointer_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct add_const_Reflection {
};
struct add_cv_Reflection {
};
struct add_volatile_Reflection {
};
struct __align_type_Reflection {
};
struct __struct_double_Reflection {
    static constexpr auto __lx = "long double";
};
struct __struct_double4_Reflection {
    static constexpr auto __lx = "double[4]";
};
struct __fallback_overaligned_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_max_align_Reflection {
};
struct __select_align_Reflection {
};
struct __find_max_align_Reflection {
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __align = "_Aligner";
    static constexpr auto __data = "unsigned char[(_Len + _Align - 1) / _Align * _Align]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1 - 1) / 1 * 1]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2 - 1) / 2 * 2]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4 - 1) / 4 * 4]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8 - 1) / 8 * 8]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 16 - 1) / 16 * 16]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 32 - 1) / 32 * 32]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 64 - 1) / 64 * 64]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 128 - 1) / 128 * 128]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 256 - 1) / 256 * 256]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 512 - 1) / 512 * 512]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1024 - 1) / 1024 * 1024]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2048 - 1) / 2048 * 2048]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4096 - 1) / 4096 * 4096]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8192 - 1) / 8192 * 8192]";
};
struct __static_max_Reflection {
};
struct __static_max_Reflection {
};
struct aligned_union_Reflection {
};
struct alignment_of_Reflection {
};
struct has_virtual_destructor_Reflection {
};
struct is_abstract_Reflection {
};
struct is_null_pointer_Reflection {
};
struct is_fundamental_Reflection {
};
struct is_compound_Reflection {
};
struct is_const_Reflection {
};
struct is_empty_Reflection {
};
struct is_literal_type_Reflection {
};
struct is_pod_Reflection {
};
struct is_pointer_Reflection {
};
struct is_polymorphic_Reflection {
};
struct is_scalar_Reflection {
};
struct is_standard_layout_Reflection {
};
struct is_trivial_Reflection {
};
struct is_trivially_assignable_Reflection {
};
struct is_trivially_copy_assignable_Reflection {
};
struct is_trivially_move_assignable_Reflection {
};
struct is_trivially_constructible_Reflection {
};
struct is_trivially_copy_constructible_Reflection {
};
struct is_trivially_move_constructible_Reflection {
};
struct is_trivially_default_constructible_Reflection {
};
struct is_trivially_copyable_Reflection {
};
struct is_trivially_destructible_Reflection {
};
struct is_unsigned_Reflection {
};
struct is_volatile_Reflection {
};
struct make_unsigned_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct remove_pointer_Reflection {
};
struct remove_volatile_Reflection {
};
struct result_of_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct underlying_type_Reflection {
};
struct __libcpp_is_final_Reflection {
};
struct is_final_Reflection {
};
struct has_unique_object_representations_Reflection {
};
struct is_aggregate_Reflection {
};
struct _Not_Reflection {
};
struct negation_Reflection {
};
struct _FirstPaddingByte_Reflection {
    static constexpr auto __v_ = "_Tp";
    static constexpr auto __first_padding_byte_ = "char";
};
struct __is_always_bitcastable_Reflection {
};
struct __is_equality_comparable_Reflection {
};
struct __libcpp_is_trivially_equality_comparable_impl_Reflection {
};
struct __is_less_than_comparable_Reflection {
};
struct __find_segment_Reflection {
    static constexpr auto __value_ = "const _Tp &";
};
struct __unary_function_keep_layout_base_Reflection {
};
struct __integer_sequence_Reflection {
};
struct integer_sequence_Reflection {
};
struct __tuple_indices_Reflection {
};
struct __make_tuple_indices_Reflection {
};
struct __tuple_types_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_size_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_sfinae_base_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct tuple_element_Reflection {
};
struct __check_tuple_constructor_fail_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __libcpp_is_trivially_relocatable_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_ref_decay_Reflection {
};
struct piecewise_construct_t_Reflection {
};
struct __non_trivially_copyable_base_Reflection {
};
struct pair_Reflection {
    static constexpr auto first = "_T1";
    static constexpr auto second = "_T2";
};
struct _CheckArgs_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct __get_pair_Reflection {
};
struct __get_pair_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct _PairT_Reflection {
    static constexpr auto first = "size_t";
    static constexpr auto second = "size_t";
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct _Reflection {
    static constexpr auto __t = "long double";
    static constexpr auto __s = "struct (unnamed struct at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__functional\hash.h:476:7)";
};
struct _Reflection {
    static constexpr auto __a = "size_t";
    static constexpr auto __b = "size_t";
};
struct __enum_hash_Reflection {
};
struct __enum_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __bounded_iter_Reflection {
    static constexpr auto __current_ = "_Iterator";
    static constexpr auto __begin_ = "_Iterator";
    static constexpr auto __end_ = "_Iterator";
};
struct __sfinae_underlying_type_Reflection {
};
struct __sfinae_underlying_type_Reflection {
};
struct iterator_Reflection {
};
struct reverse_iterator_Reflection {
    static constexpr auto __t_ = "_Iter";
    static constexpr auto current = "_Iter";
};
struct __unwrap_iter_impl_Reflection {
};
struct __wrap_iter_Reflection {
    static constexpr auto __i_ = "iterator_type";
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct pointer_traits_Reflection {
};
struct __pointer_Reflection {
};
struct __pointer_Reflection {
};
struct __has_const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __has_void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __has_const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __has_size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __has_alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __has_propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __has_propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __has_propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __has_is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __has_rebind_other_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct allocator_traits_Reflection {
};
struct __check_valid_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_cpp17_move_insertable_Reflection {
};
struct __is_cpp17_copy_insertable_Reflection {
};
struct __allocation_result_Reflection {
    static constexpr auto ptr = "_Pointer";
    static constexpr auto count = "size_t";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __noexcept_move_assign_container_Reflection {
};
struct memory_resource_Reflection {
};
struct __exception_guard_exceptions_Reflection {
    static constexpr auto __rollback_ = "_Rollback";
    static constexpr auto __completed_ = "_Bool";
};
struct __exception_guard_noexceptions_Reflection {
    static constexpr auto __completed_ = "_Bool";
};
struct __has_allocator_type_Reflection {
};
struct __uses_allocator_Reflection {
};
struct __uses_allocator_Reflection {
};
struct uses_allocator_Reflection {
};
struct allocator_arg_t_Reflection {
};
struct __uses_alloc_ctor_imp_Reflection {
};
struct __uses_alloc_ctor_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_t_Reflection {
};
struct __ignore_type_Reflection {
};
struct _Lazy_Reflection {
};
struct __promote_Reflection {
};
struct __tuple_leaf_Reflection {
    static constexpr auto __value_ = "_Hp";
};
struct __tuple_leaf_Reflection {
};
struct __all_default_constructible_Reflection {
};
struct __tuple_impl_Reflection {
};
struct tuple_Reflection {
    static constexpr auto __base_ = "_BaseT";
};
struct _IsThisTuple_Reflection {
};
struct _EnableUTypesCtor_Reflection {
};
struct _EnableCtorFromUTypesTuple_Reflection {
};
struct _CtorPredicateFromPair_Reflection {
};
struct _EnableCtorFromPair_Reflection {
};
struct _NothrowConstructibleFromPair_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _AssignPredicateFromPair_Reflection {
};
struct _EnableAssignFromPair_Reflection {
};
struct _NothrowAssignFromPair_Reflection {
};
struct tuple_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_cat_type_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_Reflection {
};
struct __tuple_cat_Reflection {
};
struct uses_allocator_Reflection {
};
struct bad_cast_Reflection {
};
struct bad_typeid_Reflection {
};
struct exception_ptr_Reflection {
    static constexpr auto __ptr1_ = "void *";
    static constexpr auto __ptr2_ = "void *";
};
struct nested_exception_Reflection {
    static constexpr auto __ptr_ = "exception_ptr";
};
struct __nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __can_dynamic_cast_Reflection {
};
struct __save_flags_Reflection {
    static constexpr auto __stream_ = "__stream_type &";
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __fill_ = "_CharT";
};
struct in_place_t_Reflection {
};
struct in_place_type_t_Reflection {
};
struct in_place_index_t_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct polymorphic_allocator_Reflection {
    static constexpr auto __res_ = "memory_resource *";
};
struct _ClassicAlgPolicy_Reflection {
};
struct _IterOps_Reflection {
};
struct char_traits_Reflection {
};
struct __char_traits_base_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct __is_allocator_Reflection {
};
struct logic_error_Reflection {
};
struct runtime_error_Reflection {
};
struct domain_error_Reflection {
};
struct invalid_argument_Reflection {
};
struct length_error_Reflection {
};
struct out_of_range_Reflection {
};
struct range_error_Reflection {
};
struct overflow_error_Reflection {
};
struct underflow_error_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto __data_ = "const value_type *";
    static constexpr auto __size_ = "size_type";
};
struct __assume_valid_Reflection {
};
struct __string_view_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __can_lower_copy_assignment_to_memmove_Reflection {
};
struct __can_lower_move_assignment_to_memmove_Reflection {
};
struct __can_rewrap_Reflection {
};
struct __copy_impl_Reflection {
};
struct _CopySegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __copy_backward_impl_Reflection {
};
struct nullopt_t_Reflection {
};
struct __secret_tag_Reflection {
};
struct __optional_construct_from_invoke_tag_Reflection {
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_storage_base_Reflection {
};
struct __optional_storage_base_Reflection {
    static constexpr auto __value_ = "int *";
};
struct __optional_copy_base_Reflection {
};
struct __optional_copy_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __is_std_optional_Reflection {
};
struct __is_std_optional_Reflection {
};
struct optional_Reflection {
};
struct _CheckOptionalArgsConstructor_Reflection {
};
struct _CheckOptionalLikeConstructor_Reflection {
};
struct __cxx_atomic_base_impl_Reflection {
    static constexpr auto __a_value = "_Atomic(_Tp)";
};
struct __cxx_atomic_impl_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_lcm_Reflection {
};
struct __static_abs_Reflection {
};
struct __static_sign_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_div_Reflection {
};
struct ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __ratio_multiply_Reflection {
};
struct __ratio_divide_Reflection {
};
struct __ratio_add_Reflection {
};
struct __ratio_subtract_Reflection {
};
struct ratio_equal_Reflection {
};
struct ratio_not_equal_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct ratio_less_Reflection {
};
struct ratio_less_equal_Reflection {
};
struct ratio_greater_Reflection {
};
struct ratio_greater_equal_Reflection {
};
struct __ratio_gcd_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct common_type_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct treat_as_floating_point_Reflection {
};
struct duration_values_Reflection {
};
struct duration_Reflection {
    static constexpr auto __rep_ = "rep";
};
struct __no_overflow_Reflection {
};
struct __mul_Reflection {
};
struct __mul_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_lt_Reflection {
};
struct __duration_lt_Reflection {
};
struct time_point_Reflection {
    static constexpr auto __d_ = "duration";
};
struct common_type_Reflection {
};
struct steady_clock_Reflection {
};
struct system_clock_Reflection {
};
struct __spinning_backoff_policy_Reflection {
};
struct __atomic_waitable_traits_Reflection {
};
struct __atomic_waitable_Reflection {
};
struct __atomic_wait_poll_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_wait_backoff_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_compare_unequal_to_Reflection {
    static constexpr auto __val_ = "_Tp";
};
struct __libcpp_is_always_lock_free_Reflection {
};
struct __atomic_base_Reflection {
    static constexpr auto __a_ = "int";
};
struct __atomic_base_Reflection {
};
struct __binary_function_keep_layout_base_Reflection {
};
struct plus_Reflection {
};
struct plus_Reflection {
};
struct minus_Reflection {
};
struct minus_Reflection {
};
struct multiplies_Reflection {
};
struct multiplies_Reflection {
};
struct divides_Reflection {
};
struct divides_Reflection {
};
struct modulus_Reflection {
};
struct modulus_Reflection {
};
struct negate_Reflection {
};
struct negate_Reflection {
};
struct bit_and_Reflection {
};
struct bit_and_Reflection {
};
struct bit_not_Reflection {
};
struct bit_not_Reflection {
};
struct bit_or_Reflection {
};
struct bit_or_Reflection {
};
struct bit_xor_Reflection {
};
struct bit_xor_Reflection {
};
struct equal_to_Reflection {
};
struct equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct less_Reflection {
};
struct less_Reflection {
};
struct less_equal_Reflection {
};
struct less_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_Reflection {
};
struct greater_Reflection {
};
struct logical_and_Reflection {
};
struct logical_and_Reflection {
};
struct logical_not_Reflection {
};
struct logical_not_Reflection {
};
struct logical_or_Reflection {
};
struct logical_or_Reflection {
};
struct atomic_Reflection {
};
struct atomic_Reflection {
};
struct atomic_flag_Reflection {
    static constexpr auto __a_ = "int";
};
struct back_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct front_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
    static constexpr auto iter = "int";
};
struct istream_iterator_Reflection {
    static constexpr auto __in_stream_ = "istream_type *";
    static constexpr auto __value_ = "_Tp";
};
struct istreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __proxy_Reflection {
    static constexpr auto __keep_ = "char_type";
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct move_iterator_Reflection {
    static constexpr auto __current_ = "_Iter";
};
struct ostream_iterator_Reflection {
    static constexpr auto __out_stream_ = "ostream_type *";
    static constexpr auto __delim_ = "const char_type *";
};
struct ostreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __dependent_type_Reflection {
};
struct monostate_Reflection {
};
struct hash_Reflection {
};
struct __farray_Reflection {
    static constexpr auto __buf_ = "_Tp[_Size]";
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_Reflection {
};
struct __valueless_t_Reflection {
};
struct __traits_Reflection {
};
struct __union_Reflection {
};
struct __base_Reflection {
};
struct __variant_Reflection {
};
struct __base_Reflection {
};
struct __dispatcher_Reflection {
};
struct __variant_Reflection {
};
struct __value_visitor_Reflection {
    static constexpr auto __visitor = "_Visitor &&";
};
struct __alt_Reflection {
    static constexpr auto __value = "__value_type";
};
struct __union_Reflection {
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_TriviallyAvailable, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Available, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Unavailable, _Index + 1, _Types...>";
};
struct __base_Reflection {
    static constexpr auto __data = "__union<_DestructibleTrait, 0, _Types...>";
    static constexpr auto __index = "int";
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __ctor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __impl_Reflection {
};
struct __no_narrowing_check_Reflection {
};
struct __narrowing_check_Reflection {
};
struct __overload_Reflection {
};
struct __all_overloads_Reflection {
};
struct __make_overloads_imp_Reflection {
};
struct variant_Reflection {
    static constexpr auto __impl_ = "__variant_detail::__impl<_Types...>";
};
struct __convert_to_bool_Reflection {
};
struct __has_result_type_Reflection {
};
struct __derives_from_unary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __derives_from_binary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct reference_wrapper_Reflection {
    static constexpr auto __f_ = "type *";
};
struct __allocation_guard_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __n_ = "_Size";
    static constexpr auto __ptr_ = "_Pointer";
};
struct __allocator_destructor_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __s_ = "size_type";
};
struct __move_impl_Reflection {
};
struct _MoveSegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __always_false_Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _AllocatorDestroyRangeReverse_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __first_ = "_Iter &";
    static constexpr auto __last_ = "_Iter &";
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __has_array_cookie_Reflection {
};
struct __private_constructor_tag_Reflection {
};
struct default_delete_Reflection {
};
struct default_delete_Reflection {
};
struct _EnableIfConvertible_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
};
struct __unique_ptr_array_bounds_stateless_Reflection {
};
struct __unique_ptr_array_bounds_stored_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
    static constexpr auto __checker_ = "_BoundsChecker";
};
struct _CheckArrayPointerConversion_Reflection {
};
struct _CheckArrayPointerConversion_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct bad_weak_ptr_Reflection {
};
struct __shared_count_Reflection {
    static constexpr auto __shared_owners_ = "long";
};
struct __shared_weak_count_Reflection {
    static constexpr auto __shared_weak_owners_ = "long";
};
struct __shared_ptr_pointer_Reflection {
    static constexpr auto __ptr_ = "_Tp";
    static constexpr auto __deleter_ = "_Dp";
    static constexpr auto __alloc_ = "_Alloc";
};
struct __for_overwrite_tag_Reflection {
};
struct __shared_ptr_emplace_Reflection {
    static constexpr auto __storage_ = "_Storage";
};
struct _Storage_Reflection {
    static constexpr auto __buffer_ = "char[sizeof(_Data)]";
};
struct _Data_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __elem_ = "int";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __compatible_with_Reflection {
};
struct __raw_pointer_compatible_with_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __well_formed_deleter_Reflection {
};
struct __shared_ptr_deleter_ctor_reqs_Reflection {
};
struct shared_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct __nullptr_sfinae_tag_Reflection {
};
struct __shared_ptr_default_allocator_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __sp_aligned_storage_Reflection {
    static constexpr auto __storage = "char[_Alignment]";
};
struct __unbounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __count_ = "size_t";
    static constexpr auto  = "union std::__unbounded_array_control_block<type-parameter-0-0[], type-parameter-0-1>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:952:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct __bounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto  = "union std::__bounded_array_control_block<type-parameter-0-0[_Np], type-parameter-0-2>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:1030:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[_Count]";
};
struct weak_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct enable_shared_from_this_Reflection {
    static constexpr auto __weak_this_ = "weak_ptr<_Tp>";
};
struct hash_Reflection {
};
struct __sp_mut_Reflection {
    static constexpr auto __lx_ = "void *";
};
struct raw_storage_iterator_Reflection {
    static constexpr auto __x_ = "_OutputIterator";
};
struct __temporary_buffer_deleter_Reflection {
    static constexpr auto __count_ = "ptrdiff_t";
};
struct __move_backward_impl_Reflection {
};
struct __destruct_n_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct __invert_Reflection {
    static constexpr auto __p_ = "_Predicate";
};
struct _ConstTimeDistance_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct _Reflection {
};
struct __aliasing_iterator_wrapper_Reflection {
};
struct __iterator_Reflection {
    static constexpr auto __base_ = "_BaseIter";
};
struct _MinmaxElementLessFunc_Reflection {
    static constexpr auto __comp_ = "_Comp &";
    static constexpr auto __proj_ = "_Proj &";
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct _ProjectedPred_Reflection {
    static constexpr auto __pred = "_Pred &";
    static constexpr auto __proj = "_Proj &";
};
struct __set_intersection_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_symmetric_difference_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_union_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_urng_Reflection {
};
struct __log2_Reflection {
};
struct __independent_bits_engine_Reflection {
    static constexpr auto __e_ = "_Engine &";
    static constexpr auto __w_ = "size_t";
    static constexpr auto __w0_ = "size_t";
    static constexpr auto __n_ = "size_t";
    static constexpr auto __n0_ = "size_t";
    static constexpr auto __y0_ = "_Working_result_type";
    static constexpr auto __y1_ = "_Working_result_type";
    static constexpr auto __mask0_ = "_Engine_result_type";
    static constexpr auto __mask1_ = "_Engine_result_type";
};
struct uniform_int_distribution_Reflection {
    static constexpr auto __p_ = "param_type";
};
struct param_type_Reflection {
    static constexpr auto __a_ = "result_type";
    static constexpr auto __b_ = "result_type";
};
struct __libcpp_debug_randomizer_Reflection {
    static constexpr auto __state_ = "int";
    static constexpr auto __inc_ = "int";
};
struct __stable_sort_switch_Reflection {
};
struct __reread_from_input_tag_Reflection {
};
struct __reread_from_output_tag_Reflection {
};
struct __read_from_tmp_value_tag_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __can_be_converted_to_string_view_Reflection {
};
struct __uninitialized_size_tag_Reflection {
};
struct __init_with_sentinel_tag_Reflection {
};
struct __padding_Reflection {
    static constexpr auto __padding_ = "char[_PaddingSize]";
};
struct __padding_Reflection {
};
struct basic_string_Reflection {
    static constexpr auto __rep_ = "__rep";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __long_Reflection {
    static constexpr auto  = "struct std::basic_string::__long::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:902:5)";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __data_ = "pointer";
};
struct _Reflection {
    static constexpr auto __is_long_ = "size_type";
    static constexpr auto __cap_ = "size_type";
};
struct __short_Reflection {
    static constexpr auto  = "struct std::basic_string::__short::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:913:5)";
    static constexpr auto __padding_ = "__padding<sizeof(value_type) - 1>";
    static constexpr auto __data_ = "value_type[__min_cap]";
};
struct _Reflection {
    static constexpr auto __is_long_ = "unsigned char";
    static constexpr auto __size_ = "unsigned char";
};
struct __rep_Reflection {
    static constexpr auto __s = "__short";
    static constexpr auto __l = "__long";
};
struct __string_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __lconv_storage_Reflection {
    static constexpr auto __lc_ = "int";
    static constexpr auto __decimal_point_ = "int";
    static constexpr auto __thousands_sep_ = "int";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __int_curr_symbol_ = "int";
    static constexpr auto __currency_symbol_ = "int";
    static constexpr auto __mon_decimal_point_ = "int";
    static constexpr auto __mon_thousands_sep_ = "int";
    static constexpr auto __mon_grouping_ = "int";
    static constexpr auto __positive_sign_ = "int";
    static constexpr auto __negative_sign_ = "int";
};
struct locale_t_Reflection {
    static constexpr auto __locale_str_ = "const char *";
    static constexpr auto __lc_ = "__lconv_storage *";
};
struct once_flag_Reflection {
    static constexpr auto __state_ = "_State_type";
};
struct __call_once_param_Reflection {
    static constexpr auto __f_ = "_Fp &";
};
struct __uninitialized_tag_Reflection {
};
struct __no_destroy_Reflection {
    static constexpr auto __obj_ = "char[sizeof(_Tp)]";
};
struct locale_Reflection {
    static constexpr auto __locale_ = "__imp *";
};
struct facet_Reflection {
};
struct id_Reflection {
    static constexpr auto __flag_ = "once_flag";
    static constexpr auto __id_ = "int";
};
struct collate_Reflection {
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_base_Reflection {
};
struct ctype_Reflection {
};
struct ctype_Reflection {
    static constexpr auto __tab_ = "const mask *";
    static constexpr auto __del_ = "_Bool";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_base_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_byname_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_byname_Reflection {
};
struct numpunct_byname_Reflection {
};
struct error_category_Reflection {
};
struct __do_message_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct error_condition_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct is_error_code_enum_Reflection {
};
struct error_code_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct system_error_Reflection {
    static constexpr auto __ec_ = "error_code";
};
struct ios_base_Reflection {
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __precision_ = "streamsize";
    static constexpr auto __width_ = "streamsize";
    static constexpr auto __rdstate_ = "iostate";
    static constexpr auto __exceptions_ = "iostate";
    static constexpr auto __rdbuf_ = "void *";
    static constexpr auto __loc_ = "void *";
    static constexpr auto __fn_ = "event_callback *";
    static constexpr auto __index_ = "int *";
    static constexpr auto __event_size_ = "size_t";
    static constexpr auto __event_cap_ = "size_t";
    static constexpr auto __iarray_ = "long *";
    static constexpr auto __iarray_size_ = "size_t";
    static constexpr auto __iarray_cap_ = "size_t";
    static constexpr auto __parray_ = "void **";
    static constexpr auto __parray_size_ = "size_t";
    static constexpr auto __parray_cap_ = "size_t";
};
struct is_error_code_enum_Reflection {
};
struct failure_Reflection {
};
struct Init_Reflection {
};
struct _FillHelper_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
    static constexpr auto __set_ = "_Bool";
};
struct _SentinelValueFill_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
};
struct basic_ios_Reflection {
    static constexpr auto __tie_ = "basic_ostream<char_type, traits_type> *";
    static constexpr auto __fill_ = "_FillType";
};
struct mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_mutex_t";
};
struct defer_lock_t_Reflection {
};
struct try_to_lock_t_Reflection {
};
struct adopt_lock_t_Reflection {
};
struct unique_lock_Reflection {
    static constexpr auto __m_ = "mutex_type *";
    static constexpr auto __owns_ = "_Bool";
};
struct condition_variable_Reflection {
    static constexpr auto __cv_ = "__libcpp_condvar_t";
};
struct lock_guard_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct __thread_id_Reflection {
    static constexpr auto __id_ = "__libcpp_thread_id";
};
struct recursive_mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_recursive_mutex_t";
};
struct timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __locked_ = "_Bool";
};
struct recursive_timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __count_ = "size_t";
    static constexpr auto __id_ = "__thread_id";
};
struct scoped_lock_Reflection {
};
struct scoped_lock_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct scoped_lock_Reflection {
    static constexpr auto __t_ = "_MutexTuple";
};
struct __has_storage_type_Reflection {
};
struct __bit_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_reference_Reflection {
};
struct __bit_const_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_array_Reflection {
    static constexpr auto __size_ = "difference_type";
    static constexpr auto __word_ = "__storage_type[4]";
};
struct __bit_iterator_Reflection {
    static constexpr auto __seg_ = "int";
    static constexpr auto __ctz_ = "unsigned int";
};
struct __has_storage_type_Reflection {
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type[_N_words]";
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type";
};
struct __bitset_Reflection {
};
struct bitset_Reflection {
};
struct hash_Reflection {
};
struct basic_streambuf_Reflection {
    static constexpr auto __loc_ = "locale";
    static constexpr auto __binp_ = "char_type *";
    static constexpr auto __ninp_ = "char_type *";
    static constexpr auto __einp_ = "char_type *";
    static constexpr auto __bout_ = "char_type *";
    static constexpr auto __nout_ = "char_type *";
    static constexpr auto __eout_ = "char_type *";
};
struct __num_get_base_Reflection {
};
struct __num_get_Reflection {
};
struct num_get_Reflection {
};
struct __num_put_base_Reflection {
};
struct __num_put_Reflection {
};
struct num_put_Reflection {
};
struct time_base_Reflection {
};
struct __time_get_c_storage_Reflection {
};
struct time_get_Reflection {
};
struct __time_get_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct __time_get_storage_Reflection {
    static constexpr auto __weeks_ = "string_type[14]";
    static constexpr auto __months_ = "string_type[24]";
    static constexpr auto __am_pm_ = "string_type[2]";
    static constexpr auto __c_ = "string_type";
    static constexpr auto __r_ = "string_type";
    static constexpr auto __x_ = "string_type";
    static constexpr auto __X_ = "string_type";
};
struct time_get_byname_Reflection {
};
struct __time_put_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct time_put_Reflection {
};
struct time_put_byname_Reflection {
};
struct money_base_Reflection {
};
struct pattern_Reflection {
    static constexpr auto field = "char[4]";
};
struct moneypunct_Reflection {
};
struct moneypunct_byname_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __curr_symbol_ = "string_type";
    static constexpr auto __positive_sign_ = "string_type";
    static constexpr auto __negative_sign_ = "string_type";
    static constexpr auto __frac_digits_ = "int";
    static constexpr auto __pos_format_ = "pattern";
    static constexpr auto __neg_format_ = "pattern";
};
struct __money_get_Reflection {
};
struct money_get_Reflection {
};
struct __money_put_Reflection {
};
struct money_put_Reflection {
};
struct messages_base_Reflection {
};
struct messages_Reflection {
};
struct messages_byname_Reflection {
};
struct wstring_convert_Reflection {
    static constexpr auto __byte_err_string_ = "byte_string";
    static constexpr auto __wide_err_string_ = "wide_string";
    static constexpr auto __cvtptr_ = "_Codecvt *";
    static constexpr auto __cvtstate_ = "state_type";
    static constexpr auto __cvtcount_ = "size_t";
};
struct wbuffer_convert_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __bufptr_ = "int *";
    static constexpr auto __cv_ = "_Codecvt *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ostream_Reflection {
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
    static constexpr auto __os_ = "basic_ostream<_CharT, _Traits> &";
};
struct __is_ostreamable_Reflection {
};
struct __is_ostreamable_Reflection {
};
struct basic_istream_Reflection {
    static constexpr auto __gc_ = "streamsize";
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
};
struct __is_istreamable_Reflection {
};
struct __is_istreamable_Reflection {
};
struct basic_iostream_Reflection {
};
struct array_Reflection {
    static constexpr auto __elems_ = "_Tp[_Size]";
};
struct array_Reflection {
    static constexpr auto __elems_ = "int[sizeof(_ArrayInStructT)]";
};
struct _ArrayInStructT_Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct __temp_value_Reflection {
    static constexpr auto  = "union std::__temp_value::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\temp_value.h:31:3)";
    static constexpr auto __a = "_Alloc &";
};
struct _Reflection {
    static constexpr auto __v = "_Tp";
};
struct __split_buffer_Reflection {
    static constexpr auto __first_ = "int";
    static constexpr auto __begin_ = "int";
    static constexpr auto __end_ = "int";
    static constexpr auto __end_cap_ = "int";
    static constexpr auto __alloc_ = "allocator_type";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "const int";
    static constexpr auto __dest_ = "int *";
};
struct __container_traits_Reflection {
};
struct __deque_block_size_Reflection {
};
struct __deque_iterator_Reflection {
    static constexpr auto __m_iter_ = "__map_iterator";
    static constexpr auto __ptr_ = "pointer";
};
struct deque_Reflection {
    static constexpr auto __map_ = "int";
    static constexpr auto __start_ = "size_type";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __deque_block_range_Reflection {
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __end_ = "const pointer";
};
struct __deque_range_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "int";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __end_ = "const pointer";
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __base_ = "deque<_Tp, _Allocator> *const";
};
struct __container_traits_Reflection {
};
struct binary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct is_bind_expression_Reflection {
};
struct is_placeholder_Reflection {
};
struct __ph_Reflection {
};
struct is_placeholder_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_Reflection {
    static constexpr auto __f_ = "int";
    static constexpr auto __bound_args_ = "_Td";
};
struct is_bind_expression_Reflection {
};
struct __bind_r_Reflection {
};
struct is_bind_expression_Reflection {
};
struct __mem_fn_Reflection {
    static constexpr auto __f_ = "type";
};
struct unary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct __builtin_new_allocator_Reflection {
};
struct __builtin_new_deleter_Reflection {
    static constexpr auto __size_ = "size_t";
    static constexpr auto __align_ = "size_t";
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct bad_function_call_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __alloc_func_Reflection {
    static constexpr auto __func_ = "_Fp";
    static constexpr auto __alloc_ = "_Ap";
};
struct __default_alloc_func_Reflection {
    static constexpr auto __f_ = "_Fp";
};
struct __base_Reflection {
};
struct __func_Reflection {
    static constexpr auto __f_ = "__alloc_func<_Fp, _Alloc, _Rp (_ArgTypes...)>";
};
struct __value_func_Reflection {
    static constexpr auto __buf_ = "int";
    static constexpr auto __f_ = "__func *";
};
struct __policy_storage_Reflection {
    static constexpr auto __small = "char[16]";
    static constexpr auto __large = "void *";
};
struct __use_small_storage_Reflection {
};
struct __policy_Reflection {
    static constexpr auto __clone = "void *(*const)(const void *)";
    static constexpr auto __destroy = "void (*const)(void *)";
    static constexpr auto __is_null = "const _Bool";
    static constexpr auto __type_info = "const int *const";
};
struct __policy_invoker_Reflection {
    static constexpr auto __call_ = "__Call";
};
struct __policy_func_Reflection {
    static constexpr auto __buf_ = "__policy_storage";
    static constexpr auto __invoker_ = "__invoker";
    static constexpr auto __policy_ = "const __policy *";
};
struct function_Reflection {
    static constexpr auto __f_ = "__func";
};
struct __callable_Reflection {
};
struct __extract_key_fail_tag_Reflection {
};
struct __extract_key_self_tag_Reflection {
};
struct __extract_key_first_tag_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __hash_node_base_Reflection {
    static constexpr auto __next_ = "__next_pointer";
};
struct __hash_node_Reflection {
    static constexpr auto __hash_ = "size_t";
    static constexpr auto  = "union std::__hash_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__hash_table:124:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __hash_key_value_types_Reflection {
};
struct __hash_key_value_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_node_types_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __make_hash_node_types_Reflection {
};
struct __hash_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_const_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __hash_const_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __bucket_list_deallocator_Reflection {
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __hash_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __enforce_unordered_container_requirements_Reflection {
};
struct __hash_table_Reflection {
    static constexpr auto __bucket_list_ = "__bucket_list";
    static constexpr auto __first_node_ = "__first_node";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __hasher_ = "hasher";
    static constexpr auto __max_load_factor_ = "float";
    static constexpr auto __key_eq_ = "key_equal";
};
struct __basic_node_handle_Reflection {
    static constexpr auto __ptr_ = "__node_pointer_type";
    static constexpr auto __alloc_ = "optional<allocator_type>";
};
struct __set_node_handle_specifics_Reflection {
};
struct __map_node_handle_specifics_Reflection {
};
struct __insert_return_type_Reflection {
    static constexpr auto position = "_Iterator";
    static constexpr auto inserted = "_Bool";
    static constexpr auto node = "_NodeType";
};
struct __unordered_map_hasher_Reflection {
};
struct __unordered_map_hasher_Reflection {
    static constexpr auto __hash_ = "_Hash";
};
struct __unordered_map_equal_Reflection {
};
struct __unordered_map_equal_Reflection {
    static constexpr auto __pred_ = "_Pred";
};
struct __hash_map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __hash_value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __hash_map_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct __hash_map_const_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct unordered_map_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multimap_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct to_chars_result_Reflection {
    static constexpr auto ptr = "char *";
    static constexpr auto ec = "errc";
};
struct __traits_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "pointer";
    static constexpr auto __end_ = "pointer";
    static constexpr auto __cap_ = "pointer";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Tp, _Alloc> &";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __v_ = "vector<_Tp, _Alloc> &";
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __new_end_ = "const const_pointer";
};
struct __has_storage_type_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "__storage_pointer";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __cap_ = "size_type";
    static constexpr auto __alloc_ = "__storage_allocator";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Bool, type-parameter-0-0> &";
};
struct hash_Reflection {
};
struct __container_traits_Reflection {
};
struct _BMSkipTable_Reflection {
    static constexpr auto __default_value_ = "const value_type";
    static constexpr auto __table_ = "int";
};
struct _BMSkipTable_Reflection {
    static constexpr auto __table_ = "std::array<value_type, 256>";
};
struct boyer_moore_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
    static constexpr auto __suffix_ = "shared_ptr<difference_type[]>";
};
struct boyer_moore_horspool_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
};
struct default_searcher_Reflection {
    static constexpr auto __first_ = "_ForwardIterator";
    static constexpr auto __last_ = "_ForwardIterator";
    static constexpr auto __pred_ = "_BinaryPredicate";
};
struct __not_fn_op_Reflection {
};
struct __not_fn_t_Reflection {
};
struct queue_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct priority_queue_Reflection {
    static constexpr auto c = "container_type";
    static constexpr auto comp = "value_compare";
};
struct uses_allocator_Reflection {
};
struct stack_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct _FilesystemClock_Reflection {
};
struct __forward_list_node_value_type_Reflection {
};
struct __forward_node_traits_Reflection {
};
struct __forward_begin_node_Reflection {
    static constexpr auto __next_ = "pointer";
};
struct __forward_list_node_Reflection {
    static constexpr auto  = "union std::__forward_list_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\forward_list:328:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __forward_list_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_base_Reflection {
    static constexpr auto __before_begin_ = "__begin_node";
    static constexpr auto __alloc_ = "__node_allocator";
};
struct forward_list_Reflection {
};
struct __container_traits_Reflection {
};
struct basic_stringbuf_Reflection {
    static constexpr auto __str_ = "string_type";
    static constexpr auto __hm_ = "char_type *";
    static constexpr auto __mode_ = "class ios_base::openmode";
};
struct basic_istringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_ostringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_stringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct unordered_set_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multiset_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct null_mutex_Reflection {
};
struct null_atomic_int_Reflection {
    static constexpr auto value = "int";
};
struct type_identity_Reflection {
};
struct is_contiguous_Reflection {
};
struct monostate_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto data_ = "const Char *";
    static constexpr auto size_ = "size_t";
};
struct is_char_Reflection {
};
struct is_char_Reflection {
};
struct compile_string_Reflection {
};
struct is_compile_string_Reflection {
};
struct is_string_Reflection {
};
struct char_t_impl_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct error_handler_Reflection {
};
struct basic_format_parse_context_Reflection {
    static constexpr auto format_str_ = "basic_string_view<Char>";
    static constexpr auto next_arg_id_ = "int";
};
struct compile_parse_context_Reflection {
    static constexpr auto num_args_ = "int";
    static constexpr auto types_ = "const type *";
};
struct buffer_Reflection {
    static constexpr auto ptr_ = "T *";
    static constexpr auto size_ = "size_t";
    static constexpr auto capacity_ = "size_t";
};
struct buffer_traits_Reflection {
};
struct fixed_buffer_traits_Reflection {
    static constexpr auto count_ = "size_t";
    static constexpr auto limit_ = "size_t";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto data_ = "T[buffer_size]";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "T *";
    static constexpr auto data_ = "T[buffer_size]";
};
struct counting_buffer_Reflection {
    static constexpr auto data_ = "T[buffer_size]";
    static constexpr auto count_ = "size_t";
};
struct formatter_Reflection {
};
struct appender_Reflection {
};
struct view_Reflection {
};
struct named_arg_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto value = "const T &";
};
struct named_arg_info_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto id = "int";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)]";
    static constexpr auto named_args_ = "named_arg_info<Char>[NUM_NAMED_ARGS]";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[NUM_ARGS != 0 ? NUM_ARGS : +1]";
};
struct is_named_arg_Reflection {
};
struct is_statically_named_arg_Reflection {
};
struct is_named_arg_Reflection {
};
struct unformattable_Reflection {
};
struct unformattable_char_Reflection {
};
struct unformattable_pointer_Reflection {
};
struct string_value_Reflection {
    static constexpr auto data = "const Char *";
    static constexpr auto size = "size_t";
};
struct named_arg_value_Reflection {
    static constexpr auto data = "const named_arg_info<Char> *";
    static constexpr auto size = "size_t";
};
struct custom_value_Reflection {
    static constexpr auto value = "void *";
    static constexpr auto format = "void (*)(void *, parse_context &, Context &)";
};
struct value_Reflection {
    static constexpr auto  = "union fmt::detail::value::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1261:3)";
};
struct _Reflection {
    static constexpr auto no_value = "monostate";
    static constexpr auto int_value = "int";
    static constexpr auto uint_value = "unsigned int";
    static constexpr auto long_long_value = "long long";
    static constexpr auto ulong_long_value = "unsigned long long";
    static constexpr auto int128_value = "int128_opt";
    static constexpr auto uint128_value = "uint128_opt";
    static constexpr auto bool_value = "_Bool";
    static constexpr auto char_value = "char_type";
    static constexpr auto float_value = "float";
    static constexpr auto double_value = "double";
    static constexpr auto long_double_value = "long double";
    static constexpr auto pointer = "const void *";
    static constexpr auto string = "string_value<char_type>";
    static constexpr auto custom = "custom_value<Context>";
    static constexpr auto named_args = "named_arg_value<char_type>";
};
struct format_as_result_Reflection {
};
struct has_format_as_Reflection {
};
struct arg_mapper_Reflection {
};
struct formattable_Reflection {
};
struct is_output_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct locale_ref_Reflection {
    static constexpr auto locale_ = "const void *";
};
struct basic_format_arg_Reflection {
    static constexpr auto value_ = "detail::value<Context>";
    static constexpr auto type_ = "detail::type";
};
struct handle_Reflection {
    static constexpr auto custom_ = "detail::custom_value<Context>";
};
struct basic_format_context_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto args_ = "basic_format_args<basic_format_context<OutputIt, Char> >";
    static constexpr auto loc_ = "detail::locale_ref";
};
struct format_arg_store_Reflection {
    static constexpr auto data_ = "int";
};
struct basic_format_args_Reflection {
    static constexpr auto desc_ = "unsigned long long";
    static constexpr auto  = "union fmt::basic_format_args::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1902:3)";
};
struct _Reflection {
    static constexpr auto values_ = "const detail::value<Context> *";
    static constexpr auto args_ = "const format_arg *";
};
struct fill_t_Reflection {
    static constexpr auto data_ = "Char[max_size]";
    static constexpr auto size_ = "unsigned char";
};
struct format_specs_Reflection {
    static constexpr auto width = "int";
    static constexpr auto precision = "int";
    static constexpr auto type = "presentation_type";
    static constexpr auto align = "align_t";
    static constexpr auto sign = "sign_t";
    static constexpr auto alt = "_Bool";
    static constexpr auto localized = "_Bool";
    static constexpr auto fill = "detail::fill_t<Char>";
};
struct arg_ref_Reflection {
    static constexpr auto kind = "arg_id_kind";
    static constexpr auto val = "union value";
};
struct value_Reflection {
    static constexpr auto index = "int";
    static constexpr auto name = "basic_string_view<Char>";
};
struct dynamic_format_specs_Reflection {
    static constexpr auto width_ref = "arg_ref<Char>";
    static constexpr auto precision_ref = "arg_ref<Char>";
};
struct dynamic_spec_id_handler_Reflection {
    static constexpr auto ctx = "basic_format_parse_context<Char> &";
    static constexpr auto ref = "arg_ref<Char> &";
};
struct _Reflection {
    static constexpr auto current_state = "state";
};
struct _Reflection {
    static constexpr auto begin = "const Char *&";
    static constexpr auto specs = "dynamic_format_specs<Char> &";
    static constexpr auto arg_type = "type";
};
struct id_adapter_Reflection {
    static constexpr auto handler = "Handler &";
    static constexpr auto arg_id = "int";
};
struct writer_Reflection {
    static constexpr auto handler_ = "Handler &";
};
struct strip_named_arg_Reflection {
};
struct strip_named_arg_Reflection {
};
struct format_string_checker_Reflection {
    static constexpr auto types_ = "type[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
    static constexpr auto context_ = "parse_context_type";
    static constexpr auto parse_funcs_ = "parse_func[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
};
struct vformat_args_Reflection {
};
struct vformat_args_Reflection {
};
struct runtime_format_string_Reflection {
    static constexpr auto str = "basic_string_view<Char>";
};
struct basic_format_string_Reflection {
    static constexpr auto str_ = "basic_string_view<Char>";
};
struct format_to_n_result_Reflection {
    static constexpr auto out = "OutputIt";
    static constexpr auto size = "size_t";
};
struct __uintr_frame_Reflection {
    static constexpr auto rip = "unsigned long long";
    static constexpr auto rflags = "unsigned long long";
    static constexpr auto rsp = "unsigned long long";
};
struct __mm_loadh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadh_pi_v2f32";
};
struct __mm_loadl_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadl_pi_v2f32";
};
struct __mm_load_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __mm_load1_ps_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_store_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_load1_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __loadu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __loadu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __loadu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_load_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadl_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_store_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __mm_loadl_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __storeu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __storeu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __storeu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_storel_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __mm_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __mm256_broadcast_sd_struct_Reflection {
    static constexpr auto __d = "double";
};
struct __mm256_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __loadu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __storeu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __mm_load_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __mm_store_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __loadu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __storeu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __loadu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __storeu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __loadu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __storeu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __tile1024i_str_Reflection {
    static constexpr auto row = "const unsigned short";
    static constexpr auto col = "const unsigned short";
    static constexpr auto tile = "_tile1024i";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __mm_store_sbh_struct_Reflection {
    static constexpr auto __u = "__bf16";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct string_literal_Reflection {
};
struct uint128_fallback_Reflection {
    static constexpr auto lo_ = "int";
    static constexpr auto hi_ = "int";
};
struct _Reflection {
    static constexpr auto  = "F";
};
struct count_code_points_Reflection {
    static constexpr auto count = "size_t *";
};
struct _Reflection {
    static constexpr auto  = "const char *";
    static constexpr auto  = "size_t &";
    static constexpr auto  = "size_t &";
};
struct is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_locale_Reflection {
};
struct basic_memory_buffer_Reflection {
    static constexpr auto store_ = "T[SIZE]";
    static constexpr auto alloc_ = "Allocator";
};
struct is_contiguous_Reflection {
};
struct format_error_Reflection {
};
struct loc_value_Reflection {
    static constexpr auto value_ = "int";
};
struct format_facet_Reflection {
    static constexpr auto separator_ = "int";
    static constexpr auto grouping_ = "int";
    static constexpr auto decimal_point_ = "int";
};
struct _Reflection {
};
struct thousands_sep_result_Reflection {
    static constexpr auto grouping = "int";
    static constexpr auto thousands_sep = "Char";
};
struct format_decimal_result_Reflection {
    static constexpr auto begin = "Iterator";
    static constexpr auto end = "Iterator";
};
struct utf8_to_utf16_Reflection {
    static constexpr auto buffer_ = "int";
};
struct to_utf8_Reflection {
    static constexpr auto buffer_ = "Buffer";
};
struct decimal_fp_Reflection {
    static constexpr auto significand = "int";
    static constexpr auto exponent = "int";
};
struct basic_fp_Reflection {
    static constexpr auto f = "F";
    static constexpr auto e = "int";
};
struct _Reflection {
};
struct find_escape_result_Reflection {
    static constexpr auto begin = "const Char *";
    static constexpr auto end = "const Char *";
    static constexpr auto cp = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct write_int_data_Reflection {
    static constexpr auto size = "size_t";
    static constexpr auto padding = "size_t";
};
struct _Reflection {
};
struct digit_grouping_Reflection {
    static constexpr auto grouping_ = "int";
    static constexpr auto thousands_sep_ = "int";
};
struct next_state_Reflection {
    static constexpr auto group = "int";
    static constexpr auto pos = "int";
};
struct write_int_arg_Reflection {
    static constexpr auto abs_value = "UInt";
    static constexpr auto prefix = "unsigned int";
};
struct loc_writer_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto sep = "int";
    static constexpr auto grouping = "int";
    static constexpr auto decimal_point = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct counting_iterator_Reflection {
    static constexpr auto count_ = "size_t";
};
struct value_type_Reflection {
};
struct _Reflection {
};
struct float_specs_Reflection {
    static constexpr auto precision = "int";
    static constexpr auto format = "float_format";
    static constexpr auto sign = "sign_t";
    static constexpr auto upper = "_Bool";
    static constexpr auto locale = "_Bool";
    static constexpr auto binary32 = "_Bool";
    static constexpr auto showpoint = "_Bool";
};
struct big_decimal_fp_Reflection {
    static constexpr auto significand = "const char *";
    static constexpr auto significand_size = "int";
    static constexpr auto exponent = "int";
};
struct fallback_digit_grouping_Reflection {
};
struct has_isfinite_Reflection {
};
struct bigint_Reflection {
    static constexpr auto bigits_ = "int";
    static constexpr auto exp_ = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct default_arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto args = "int";
    static constexpr auto loc = "locale_ref";
};
struct arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto locale = "locale_ref";
};
struct width_checker_Reflection {
};
struct precision_checker_Reflection {
};
struct udl_arg_Reflection {
    static constexpr auto str = "const Char *";
};
struct format_int_Reflection {
    static constexpr auto buffer_ = "char[0]";
    static constexpr auto str_ = "char *";
};
struct bytes_Reflection {
    static constexpr auto data_ = "string_view";
};
struct group_digits_view_Reflection {
    static constexpr auto value = "T";
};
struct nested_view_Reflection {
    static constexpr auto fmt = "const int *";
    static constexpr auto value = "const T *";
};
struct nested_formatter_Reflection {
    static constexpr auto width_ = "int";
    static constexpr auto fill_ = "detail::fill_t<char>";
    static constexpr auto align_ = "align_t";
    static constexpr auto formatter_ = "int";
};
struct join_view_Reflection {
    static constexpr auto begin = "It";
    static constexpr auto end = "Sentinel";
    static constexpr auto sep = "basic_string_view<Char>";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
    static constexpr auto divisor = "int";
    static constexpr auto shift_amount = "int";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct _Reflection {
    static constexpr auto  = "class fmt::detail::utf8_to_utf16 *";
};
struct singleton_Reflection {
    static constexpr auto upper = "unsigned char";
    static constexpr auto lower_count = "unsigned char";
};
struct is_convertible_to_basic_format_string_Reflection {
};
struct is_convertible_to_any_format_string_Reflection {
};
struct spdlog_ex_Reflection {
    static constexpr auto msg_ = "int";
};
struct source_loc_Reflection {
    static constexpr auto filename = "const char *";
    static constexpr auto line = "int";
    static constexpr auto funcname = "const char *";
};
struct file_event_handlers_Reflection {
    static constexpr auto before_open = "std::function<void (const int &)>";
    static constexpr auto after_open = "std::function<void (const int &, int *)>";
    static constexpr auto before_close = "std::function<void (const int &, int *)>";
    static constexpr auto after_close = "std::function<void (const int &)>";
};
struct condition_variable_any_Reflection {
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __mut_ = "shared_ptr<mutex>";
};
struct __unlock_guard_Reflection {
    static constexpr auto __lock_ = "_Lock &";
};
struct __thread_struct_Reflection {
    static constexpr auto __p_ = "__thread_struct_imp *";
};
struct __thread_specific_ptr_Reflection {
    static constexpr auto __key_ = "__libcpp_tls_key";
};
struct hash_Reflection {
};
struct thread_Reflection {
    static constexpr auto __t_ = "__libcpp_thread_t";
};
struct periodic_worker_Reflection {
    static constexpr auto active_ = "_Bool";
    static constexpr auto worker_thread_ = "std::thread";
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto cv_ = "std::condition_variable";
};
struct registry_Reflection {
    static constexpr auto logger_map_mutex_ = "std::mutex";
    static constexpr auto flusher_mutex_ = "std::mutex";
    static constexpr auto tp_mutex_ = "std::recursive_mutex";
    static constexpr auto log_levels_ = "int";
    static constexpr auto formatter_ = "int";
    static constexpr auto global_log_level_ = "spdlog::level::level_enum";
    static constexpr auto flush_level_ = "level::level_enum";
    static constexpr auto err_handler_ = "err_handler";
    static constexpr auto tp_ = "std::shared_ptr<thread_pool>";
    static constexpr auto periodic_flusher_ = "int";
    static constexpr auto default_logger_ = "std::shared_ptr<logger>";
    static constexpr auto automatic_registration_ = "_Bool";
    static constexpr auto backtrace_n_messages_ = "size_t";
};
struct circular_q_Reflection {
    static constexpr auto max_items_ = "size_t";
    static constexpr auto head_ = "int";
    static constexpr auto tail_ = "int";
    static constexpr auto overrun_counter_ = "size_t";
    static constexpr auto v_ = "int";
};
struct log_msg_Reflection {
    static constexpr auto logger_name = "string_view_t";
    static constexpr auto level = "level::level_enum";
    static constexpr auto time = "log_clock::time_point";
    static constexpr auto thread_id = "size_t";
    static constexpr auto color_range_start = "size_t";
    static constexpr auto color_range_end = "size_t";
    static constexpr auto source = "source_loc";
    static constexpr auto payload = "string_view_t";
};
struct log_msg_buffer_Reflection {
    static constexpr auto buffer = "int";
};
struct backtracer_Reflection {
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto enabled_ = "std::atomic<_Bool>";
    static constexpr auto messages_ = "circular_q<log_msg_buffer>";
};
struct logger_Reflection {
    static constexpr auto name_ = "int";
    static constexpr auto sinks_ = "int";
    static constexpr auto level_ = "spdlog::level_t";
    static constexpr auto flush_level_ = "spdlog::level_t";
    static constexpr auto custom_err_handler_ = "err_handler";
    static constexpr auto tracer_ = "details::backtracer";
};
struct formatter_Reflection {
};
struct padding_info_Reflection {
    static constexpr auto width_ = "size_t";
    static constexpr auto side_ = "pad_side";
    static constexpr auto truncate_ = "_Bool";
    static constexpr auto enabled_ = "_Bool";
};
struct flag_formatter_Reflection {
    static constexpr auto padinfo_ = "padding_info";
};
struct custom_flag_formatter_Reflection {
};
struct pattern_formatter_Reflection {
    static constexpr auto pattern_ = "int";
    static constexpr auto eol_ = "int";
    static constexpr auto pattern_time_type_ = "pattern_time_type";
    static constexpr auto need_localtime_ = "_Bool";
    static constexpr auto cached_tm_ = "int";
    static constexpr auto last_log_secs_ = "std::chrono::seconds";
    static constexpr auto formatters_ = "int";
    static constexpr auto custom_handlers_ = "int";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_node_base_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_node_types_Reflection {
};
struct __make_tree_node_types_Reflection {
};
struct __tree_end_node_Reflection {
    static constexpr auto __left_ = "pointer";
};
struct __tree_node_base_Reflection {
    static constexpr auto __right_ = "pointer";
    static constexpr auto __parent_ = "__parent_pointer";
    static constexpr auto __is_black_ = "_Bool";
};
struct __tree_node_Reflection {
    static constexpr auto __value_ = "__node_value_type";
};
struct __tree_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __tree_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_Reflection {
    static constexpr auto __begin_node_ = "__iter_pointer";
    static constexpr auto __end_node_ = "__end_node_t";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __value_comp_ = "value_compare";
};
struct _DetachedTreeCache_Reflection {
    static constexpr auto __t_ = "__tree<_Tp, _Compare, _Allocator> *";
    static constexpr auto __cache_root_ = "__node_pointer";
    static constexpr auto __cache_elem_ = "__node_pointer";
};
struct __map_value_compare_Reflection {
};
struct __map_value_compare_Reflection {
    static constexpr auto __comp_ = "_Compare";
};
struct __map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __extract_key_value_types_Reflection {
};
struct __map_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct __map_const_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct map_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct multimap_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct mdc_Reflection {
};
struct scoped_padder_Reflection {
    static constexpr auto padinfo_ = "const padding_info &";
    static constexpr auto dest_ = "int &";
    static constexpr auto remaining_pad_ = "long";
    static constexpr auto spaces_ = "string_view_t";
};
struct null_scoped_padder_Reflection {
};
struct name_formatter_Reflection {
};
struct level_formatter_Reflection {
};
struct short_level_formatter_Reflection {
};
struct a_formatter_Reflection {
};
struct A_formatter_Reflection {
};
struct b_formatter_Reflection {
};
struct B_formatter_Reflection {
};
struct c_formatter_Reflection {
};
struct C_formatter_Reflection {
};
struct D_formatter_Reflection {
};
struct Y_formatter_Reflection {
};
struct m_formatter_Reflection {
};
struct d_formatter_Reflection {
};
struct H_formatter_Reflection {
};
struct I_formatter_Reflection {
};
struct M_formatter_Reflection {
};
struct S_formatter_Reflection {
};
struct e_formatter_Reflection {
};
struct f_formatter_Reflection {
};
struct F_formatter_Reflection {
};
struct E_formatter_Reflection {
};
struct p_formatter_Reflection {
};
struct r_formatter_Reflection {
};
struct R_formatter_Reflection {
};
struct T_formatter_Reflection {
};
struct z_formatter_Reflection {
    static constexpr auto last_update_ = "log_clock::time_point";
    static constexpr auto offset_minutes_ = "int";
};
struct t_formatter_Reflection {
};
struct pid_formatter_Reflection {
};
struct v_formatter_Reflection {
};
struct ch_formatter_Reflection {
    static constexpr auto ch_ = "char";
};
struct aggregate_formatter_Reflection {
    static constexpr auto str_ = "int";
};
struct color_start_formatter_Reflection {
};
struct color_stop_formatter_Reflection {
};
struct source_location_formatter_Reflection {
};
struct source_filename_formatter_Reflection {
};
struct short_filename_formatter_Reflection {
};
struct source_linenum_formatter_Reflection {
};
struct source_funcname_formatter_Reflection {
};
struct elapsed_formatter_Reflection {
    static constexpr auto last_message_time_ = "log_clock::time_point";
};
struct mdc_formatter_Reflection {
};
struct full_formatter_Reflection {
    static constexpr auto cache_timestamp_ = "std::chrono::seconds";
    static constexpr auto cached_datetime_ = "int";
    static constexpr auto mdc_formatter_ = "mdc_formatter<null_scoped_padder>";
};
struct sink_Reflection {
    static constexpr auto level_ = "level_t";
};
struct console_mutex_Reflection {
};
struct console_nullmutex_Reflection {
};
struct wincolor_sink_Reflection {
    static constexpr auto out_handle_ = "void *";
    static constexpr auto mutex_ = "mutex_t &";
    static constexpr auto should_do_colors_ = "_Bool";
    static constexpr auto formatter_ = "int";
    static constexpr auto colors_ = "std::array<int, level::n_levels>";
};
struct wincolor_stdout_sink_Reflection {
};
struct wincolor_stderr_sink_Reflection {
};
struct synchronous_factory_Reflection {
};
struct file_helper_Reflection {
    static constexpr auto open_tries_ = "const int";
    static constexpr auto open_interval_ = "const unsigned int";
    static constexpr auto fd_ = "int *";
    static constexpr auto filename_ = "int";
    static constexpr auto event_handlers_ = "file_event_handlers";
};
struct base_sink_Reflection {
    static constexpr auto formatter_ = "int";
    static constexpr auto mutex_ = "Mutex";
};
struct basic_file_sink_Reflection {
    static constexpr auto file_helper_ = "details::file_helper";
};
struct __iom_t1_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t2_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t3_Reflection {
    static constexpr auto __base_ = "int";
};
struct __iom_t4_Reflection {
    static constexpr auto __fill_ = "_CharT";
};
struct __iom_t5_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t6_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t7_Reflection {
    static constexpr auto __mon_ = "_MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t8_Reflection {
    static constexpr auto __mon_ = "const _MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t9_Reflection {
    static constexpr auto __tm_ = "int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __iom_t10_Reflection {
    static constexpr auto __tm_ = "const int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __quoted_output_proxy_Reflection {
    static constexpr auto __first_ = "const _CharT *";
    static constexpr auto __last_ = "const _CharT *";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __quoted_proxy_Reflection {
    static constexpr auto __string_ = "basic_string<_CharT, _Traits, _Allocator> &";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct _NullSentinel_Reflection {
};
struct __is_pathable_string_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_iter_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct path_Reflection {
    static constexpr auto __pn_ = "string_type";
};
struct basic_filebuf_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __file_ = "int *";
    static constexpr auto __cv_ = "const codecvt<char_type, char, state_type> *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __st_last_ = "state_type";
    static constexpr auto __om_ = "class ios_base::openmode";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ifstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_ofstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_fstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct file_status_Reflection {
    static constexpr auto __ft_ = "file_type";
    static constexpr auto __prms_ = "perms";
};
struct space_info_Reflection {
    static constexpr auto capacity = "int";
    static constexpr auto free = "int";
    static constexpr auto available = "int";
};
struct directory_entry_Reflection {
    static constexpr auto __p_ = "_Path";
    static constexpr auto __data_ = "__cached_data";
};
struct __cached_data_Reflection {
    static constexpr auto __size_ = "int";
    static constexpr auto __nlink_ = "int";
    static constexpr auto __write_time_ = "file_time_type";
    static constexpr auto __sym_perms_ = "perms";
    static constexpr auto __non_sym_perms_ = "perms";
    static constexpr auto __type_ = "file_type";
    static constexpr auto __cache_type_ = "_CacheType";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct __dir_element_proxy_Reflection {
    static constexpr auto __elem_ = "directory_entry";
};
struct directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__dir_stream>";
};
struct iterator_Reflection {
    static constexpr auto __stashed_elem_ = "path";
    static constexpr auto __path_ptr_ = "const path *";
    static constexpr auto __entry_ = "class path::__string_view";
    static constexpr auto __state_ = "_ParserState";
};
struct recursive_directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__shared_imp>";
    static constexpr auto __rec_ = "_Bool";
};
struct formatbuf_Reflection {
    static constexpr auto buffer_ = "buffer<char_type> &";
};
struct file_access_tag_Reflection {
};
struct file_access_Reflection {
};
struct streamed_view_Reflection {
    static constexpr auto value = "const T &";
};
struct basic_ostream_formatter_Reflection {
};
struct Logger_Reflection {
};
struct RenderContext_Reflection {
};
struct OpenGLContext_Reflection {
    static constexpr auto m_WindowHandle = "GLFWwindow *";
};
struct Input_Reflection {
};
struct WindowsInput_Reflection {
};
struct fpos_Reflection {
    static constexpr auto __st_ = "_StateT";
    static constexpr auto __off_ = "streamoff";
};
struct enable_if_Reflection {
};
struct enable_if_Reflection {
};
struct integral_constant_Reflection {
};
struct remove_cv_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct __equal_tag_Reflection {
};
struct __plus_tag_Reflection {
};
struct __totally_ordered_less_tag_Reflection {
};
struct __equal_to_Reflection {
};
struct __less_Reflection {
};
struct __less_Reflection {
};
struct __debug_less_Reflection {
    static constexpr auto __comp_ = "_Compare &";
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct is_floating_point_Reflection {
};
struct is_arithmetic_Reflection {
};
struct is_signed_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct is_convertible_Reflection {
};
struct is_function_Reflection {
};
struct is_reference_Reflection {
};
struct is_lvalue_reference_Reflection {
};
struct is_rvalue_reference_Reflection {
};
struct remove_all_extents_Reflection {
};
struct is_destructible_Reflection {
};
struct is_nothrow_destructible_Reflection {
};
struct is_same_Reflection {
};
struct __libcpp_is_referenceable_Reflection {
};
struct add_lvalue_reference_Reflection {
};
struct add_rvalue_reference_Reflection {
};
struct is_constructible_Reflection {
};
struct is_copy_constructible_Reflection {
};
struct is_move_constructible_Reflection {
};
struct is_default_constructible_Reflection {
};
struct _IfImpl_Reflection {
};
struct _IfImpl_Reflection {
};
struct conditional_Reflection {
};
struct conditional_Reflection {
};
struct is_void_Reflection {
};
struct remove_reference_Reflection {
};
struct add_pointer_Reflection {
};
struct is_array_Reflection {
};
struct remove_extent_Reflection {
};
struct decay_Reflection {
};
struct __type_identity_Reflection {
};
struct __empty_Reflection {
};
struct common_type_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct is_class_Reflection {
};
struct is_enum_Reflection {
};
struct is_union_Reflection {
};
struct extent_Reflection {
};
struct is_nothrow_assignable_Reflection {
};
struct is_nothrow_copy_assignable_Reflection {
};
struct is_nothrow_move_assignable_Reflection {
};
struct is_nothrow_constructible_Reflection {
};
struct is_nothrow_copy_constructible_Reflection {
};
struct is_nothrow_move_constructible_Reflection {
};
struct is_nothrow_default_constructible_Reflection {
};
struct is_assignable_Reflection {
};
struct is_copy_assignable_Reflection {
};
struct is_move_assignable_Reflection {
};
struct is_swappable_with_Reflection {
};
struct is_swappable_Reflection {
};
struct is_nothrow_swappable_with_Reflection {
};
struct is_nothrow_swappable_Reflection {
};
struct is_object_Reflection {
};
struct __nat_Reflection {
};
struct __type_list_Reflection {
};
struct __find_first_Reflection {
};
struct __find_first_Reflection {
};
struct make_signed_Reflection {
};
struct _OrImpl_Reflection {
};
struct _OrImpl_Reflection {
};
struct disjunction_Reflection {
};
struct remove_const_Reflection {
};
struct input_iterator_tag_Reflection {
};
struct output_iterator_tag_Reflection {
};
struct forward_iterator_tag_Reflection {
};
struct bidirectional_iterator_tag_Reflection {
};
struct random_access_iterator_tag_Reflection {
};
struct __iter_traits_cache_Reflection {
};
struct __iter_concept_concept_test_Reflection {
};
struct __iter_concept_category_test_Reflection {
};
struct __iter_concept_random_fallback_Reflection {
};
struct __test_iter_concept_Reflection {
};
struct __iter_concept_cache_Reflection {
};
struct __has_iterator_typedefs_Reflection {
};
struct __has_iterator_category_Reflection {
};
struct __has_iterator_concept_Reflection {
};
struct __iterator_traits_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __is_callable_Reflection {
};
struct initializer_list_Reflection {
    static constexpr auto __begin_ = "const _Ep *";
    static constexpr auto __size_ = "size_t";
};
struct __is_identity_Reflection {
};
struct __identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct is_base_of_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct is_member_pointer_Reflection {
};
struct is_member_object_pointer_Reflection {
};
struct is_member_function_pointer_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __invokable_r_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __invoke_of_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct is_invocable_Reflection {
};
struct is_invocable_r_Reflection {
};
struct is_nothrow_invocable_Reflection {
};
struct is_nothrow_invocable_r_Reflection {
};
struct invoke_result_Reflection {
};
struct __has_specialization_Reflection {
};
struct __has_specialization_Reflection {
};
struct __all_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct __has_pointer_Reflection {
};
struct __has_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __has_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __has_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_impl_Reflection {
};
struct pointer_traits_Reflection {
};
struct pointer_traits_Reflection {
};
struct __nat_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasArrow_Reflection {
};
struct _HasArrow_Reflection {
};
struct _IsFancyPointer_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct add_const_Reflection {
};
struct add_cv_Reflection {
};
struct add_volatile_Reflection {
};
struct __align_type_Reflection {
};
struct __struct_double_Reflection {
    static constexpr auto __lx = "long double";
};
struct __struct_double4_Reflection {
    static constexpr auto __lx = "double[4]";
};
struct __fallback_overaligned_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_max_align_Reflection {
};
struct __select_align_Reflection {
};
struct __find_max_align_Reflection {
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __align = "_Aligner";
    static constexpr auto __data = "unsigned char[(_Len + _Align - 1) / _Align * _Align]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1 - 1) / 1 * 1]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2 - 1) / 2 * 2]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4 - 1) / 4 * 4]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8 - 1) / 8 * 8]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 16 - 1) / 16 * 16]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 32 - 1) / 32 * 32]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 64 - 1) / 64 * 64]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 128 - 1) / 128 * 128]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 256 - 1) / 256 * 256]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 512 - 1) / 512 * 512]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1024 - 1) / 1024 * 1024]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2048 - 1) / 2048 * 2048]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4096 - 1) / 4096 * 4096]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8192 - 1) / 8192 * 8192]";
};
struct __static_max_Reflection {
};
struct __static_max_Reflection {
};
struct aligned_union_Reflection {
};
struct alignment_of_Reflection {
};
struct has_virtual_destructor_Reflection {
};
struct is_abstract_Reflection {
};
struct is_null_pointer_Reflection {
};
struct is_fundamental_Reflection {
};
struct is_compound_Reflection {
};
struct is_const_Reflection {
};
struct is_empty_Reflection {
};
struct is_literal_type_Reflection {
};
struct is_pod_Reflection {
};
struct is_pointer_Reflection {
};
struct is_polymorphic_Reflection {
};
struct is_scalar_Reflection {
};
struct is_standard_layout_Reflection {
};
struct is_trivial_Reflection {
};
struct is_trivially_assignable_Reflection {
};
struct is_trivially_copy_assignable_Reflection {
};
struct is_trivially_move_assignable_Reflection {
};
struct is_trivially_constructible_Reflection {
};
struct is_trivially_copy_constructible_Reflection {
};
struct is_trivially_move_constructible_Reflection {
};
struct is_trivially_default_constructible_Reflection {
};
struct is_trivially_copyable_Reflection {
};
struct is_trivially_destructible_Reflection {
};
struct is_unsigned_Reflection {
};
struct is_volatile_Reflection {
};
struct make_unsigned_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct remove_pointer_Reflection {
};
struct remove_volatile_Reflection {
};
struct result_of_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct underlying_type_Reflection {
};
struct __libcpp_is_final_Reflection {
};
struct is_final_Reflection {
};
struct has_unique_object_representations_Reflection {
};
struct is_aggregate_Reflection {
};
struct _Not_Reflection {
};
struct negation_Reflection {
};
struct _FirstPaddingByte_Reflection {
    static constexpr auto __v_ = "_Tp";
    static constexpr auto __first_padding_byte_ = "char";
};
struct __is_always_bitcastable_Reflection {
};
struct __is_equality_comparable_Reflection {
};
struct __libcpp_is_trivially_equality_comparable_impl_Reflection {
};
struct __is_less_than_comparable_Reflection {
};
struct __find_segment_Reflection {
    static constexpr auto __value_ = "const _Tp &";
};
struct __unary_function_keep_layout_base_Reflection {
};
struct __integer_sequence_Reflection {
};
struct integer_sequence_Reflection {
};
struct __tuple_indices_Reflection {
};
struct __make_tuple_indices_Reflection {
};
struct __tuple_types_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_size_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_sfinae_base_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct tuple_element_Reflection {
};
struct __check_tuple_constructor_fail_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __libcpp_is_trivially_relocatable_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_ref_decay_Reflection {
};
struct piecewise_construct_t_Reflection {
};
struct __non_trivially_copyable_base_Reflection {
};
struct pair_Reflection {
    static constexpr auto first = "_T1";
    static constexpr auto second = "_T2";
};
struct _CheckArgs_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct __get_pair_Reflection {
};
struct __get_pair_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct _PairT_Reflection {
    static constexpr auto first = "size_t";
    static constexpr auto second = "size_t";
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct _Reflection {
    static constexpr auto __t = "long double";
    static constexpr auto __s = "struct (unnamed struct at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__functional\hash.h:476:7)";
};
struct _Reflection {
    static constexpr auto __a = "size_t";
    static constexpr auto __b = "size_t";
};
struct __enum_hash_Reflection {
};
struct __enum_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __bounded_iter_Reflection {
    static constexpr auto __current_ = "_Iterator";
    static constexpr auto __begin_ = "_Iterator";
    static constexpr auto __end_ = "_Iterator";
};
struct __sfinae_underlying_type_Reflection {
};
struct __sfinae_underlying_type_Reflection {
};
struct iterator_Reflection {
};
struct reverse_iterator_Reflection {
    static constexpr auto __t_ = "_Iter";
    static constexpr auto current = "_Iter";
};
struct __unwrap_iter_impl_Reflection {
};
struct __wrap_iter_Reflection {
    static constexpr auto __i_ = "iterator_type";
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct pointer_traits_Reflection {
};
struct __pointer_Reflection {
};
struct __pointer_Reflection {
};
struct __has_const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __has_void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __has_const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __has_size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __has_alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __has_propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __has_propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __has_propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __has_is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __has_rebind_other_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct allocator_traits_Reflection {
};
struct __check_valid_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_cpp17_move_insertable_Reflection {
};
struct __is_cpp17_copy_insertable_Reflection {
};
struct __allocation_result_Reflection {
    static constexpr auto ptr = "_Pointer";
    static constexpr auto count = "size_t";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __noexcept_move_assign_container_Reflection {
};
struct memory_resource_Reflection {
};
struct __exception_guard_exceptions_Reflection {
    static constexpr auto __rollback_ = "_Rollback";
    static constexpr auto __completed_ = "_Bool";
};
struct __exception_guard_noexceptions_Reflection {
    static constexpr auto __completed_ = "_Bool";
};
struct __has_allocator_type_Reflection {
};
struct __uses_allocator_Reflection {
};
struct __uses_allocator_Reflection {
};
struct uses_allocator_Reflection {
};
struct allocator_arg_t_Reflection {
};
struct __uses_alloc_ctor_imp_Reflection {
};
struct __uses_alloc_ctor_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_t_Reflection {
};
struct __ignore_type_Reflection {
};
struct _Lazy_Reflection {
};
struct __promote_Reflection {
};
struct __tuple_leaf_Reflection {
    static constexpr auto __value_ = "_Hp";
};
struct __tuple_leaf_Reflection {
};
struct __all_default_constructible_Reflection {
};
struct __tuple_impl_Reflection {
};
struct tuple_Reflection {
    static constexpr auto __base_ = "_BaseT";
};
struct _IsThisTuple_Reflection {
};
struct _EnableUTypesCtor_Reflection {
};
struct _EnableCtorFromUTypesTuple_Reflection {
};
struct _CtorPredicateFromPair_Reflection {
};
struct _EnableCtorFromPair_Reflection {
};
struct _NothrowConstructibleFromPair_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _AssignPredicateFromPair_Reflection {
};
struct _EnableAssignFromPair_Reflection {
};
struct _NothrowAssignFromPair_Reflection {
};
struct tuple_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_cat_type_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_Reflection {
};
struct __tuple_cat_Reflection {
};
struct uses_allocator_Reflection {
};
struct bad_cast_Reflection {
};
struct bad_typeid_Reflection {
};
struct exception_ptr_Reflection {
    static constexpr auto __ptr1_ = "void *";
    static constexpr auto __ptr2_ = "void *";
};
struct nested_exception_Reflection {
    static constexpr auto __ptr_ = "exception_ptr";
};
struct __nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __can_dynamic_cast_Reflection {
};
struct __save_flags_Reflection {
    static constexpr auto __stream_ = "__stream_type &";
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __fill_ = "_CharT";
};
struct in_place_t_Reflection {
};
struct in_place_type_t_Reflection {
};
struct in_place_index_t_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct polymorphic_allocator_Reflection {
    static constexpr auto __res_ = "memory_resource *";
};
struct _ClassicAlgPolicy_Reflection {
};
struct _IterOps_Reflection {
};
struct char_traits_Reflection {
};
struct __char_traits_base_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct __is_allocator_Reflection {
};
struct logic_error_Reflection {
};
struct runtime_error_Reflection {
};
struct domain_error_Reflection {
};
struct invalid_argument_Reflection {
};
struct length_error_Reflection {
};
struct out_of_range_Reflection {
};
struct range_error_Reflection {
};
struct overflow_error_Reflection {
};
struct underflow_error_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto __data_ = "const value_type *";
    static constexpr auto __size_ = "size_type";
};
struct __assume_valid_Reflection {
};
struct __string_view_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __can_lower_copy_assignment_to_memmove_Reflection {
};
struct __can_lower_move_assignment_to_memmove_Reflection {
};
struct __can_rewrap_Reflection {
};
struct __copy_impl_Reflection {
};
struct _CopySegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __copy_backward_impl_Reflection {
};
struct nullopt_t_Reflection {
};
struct __secret_tag_Reflection {
};
struct __optional_construct_from_invoke_tag_Reflection {
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_storage_base_Reflection {
};
struct __optional_storage_base_Reflection {
    static constexpr auto __value_ = "int *";
};
struct __optional_copy_base_Reflection {
};
struct __optional_copy_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __is_std_optional_Reflection {
};
struct __is_std_optional_Reflection {
};
struct optional_Reflection {
};
struct _CheckOptionalArgsConstructor_Reflection {
};
struct _CheckOptionalLikeConstructor_Reflection {
};
struct __cxx_atomic_base_impl_Reflection {
    static constexpr auto __a_value = "_Atomic(_Tp)";
};
struct __cxx_atomic_impl_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_lcm_Reflection {
};
struct __static_abs_Reflection {
};
struct __static_sign_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_div_Reflection {
};
struct ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __ratio_multiply_Reflection {
};
struct __ratio_divide_Reflection {
};
struct __ratio_add_Reflection {
};
struct __ratio_subtract_Reflection {
};
struct ratio_equal_Reflection {
};
struct ratio_not_equal_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct ratio_less_Reflection {
};
struct ratio_less_equal_Reflection {
};
struct ratio_greater_Reflection {
};
struct ratio_greater_equal_Reflection {
};
struct __ratio_gcd_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct common_type_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct treat_as_floating_point_Reflection {
};
struct duration_values_Reflection {
};
struct duration_Reflection {
    static constexpr auto __rep_ = "rep";
};
struct __no_overflow_Reflection {
};
struct __mul_Reflection {
};
struct __mul_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_lt_Reflection {
};
struct __duration_lt_Reflection {
};
struct time_point_Reflection {
    static constexpr auto __d_ = "duration";
};
struct common_type_Reflection {
};
struct steady_clock_Reflection {
};
struct system_clock_Reflection {
};
struct __spinning_backoff_policy_Reflection {
};
struct __atomic_waitable_traits_Reflection {
};
struct __atomic_waitable_Reflection {
};
struct __atomic_wait_poll_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_wait_backoff_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_compare_unequal_to_Reflection {
    static constexpr auto __val_ = "_Tp";
};
struct __libcpp_is_always_lock_free_Reflection {
};
struct __atomic_base_Reflection {
    static constexpr auto __a_ = "int";
};
struct __atomic_base_Reflection {
};
struct __binary_function_keep_layout_base_Reflection {
};
struct plus_Reflection {
};
struct plus_Reflection {
};
struct minus_Reflection {
};
struct minus_Reflection {
};
struct multiplies_Reflection {
};
struct multiplies_Reflection {
};
struct divides_Reflection {
};
struct divides_Reflection {
};
struct modulus_Reflection {
};
struct modulus_Reflection {
};
struct negate_Reflection {
};
struct negate_Reflection {
};
struct bit_and_Reflection {
};
struct bit_and_Reflection {
};
struct bit_not_Reflection {
};
struct bit_not_Reflection {
};
struct bit_or_Reflection {
};
struct bit_or_Reflection {
};
struct bit_xor_Reflection {
};
struct bit_xor_Reflection {
};
struct equal_to_Reflection {
};
struct equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct less_Reflection {
};
struct less_Reflection {
};
struct less_equal_Reflection {
};
struct less_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_Reflection {
};
struct greater_Reflection {
};
struct logical_and_Reflection {
};
struct logical_and_Reflection {
};
struct logical_not_Reflection {
};
struct logical_not_Reflection {
};
struct logical_or_Reflection {
};
struct logical_or_Reflection {
};
struct atomic_Reflection {
};
struct atomic_Reflection {
};
struct atomic_flag_Reflection {
    static constexpr auto __a_ = "int";
};
struct back_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct front_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
    static constexpr auto iter = "int";
};
struct istream_iterator_Reflection {
    static constexpr auto __in_stream_ = "istream_type *";
    static constexpr auto __value_ = "_Tp";
};
struct istreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __proxy_Reflection {
    static constexpr auto __keep_ = "char_type";
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct move_iterator_Reflection {
    static constexpr auto __current_ = "_Iter";
};
struct ostream_iterator_Reflection {
    static constexpr auto __out_stream_ = "ostream_type *";
    static constexpr auto __delim_ = "const char_type *";
};
struct ostreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __dependent_type_Reflection {
};
struct monostate_Reflection {
};
struct hash_Reflection {
};
struct __farray_Reflection {
    static constexpr auto __buf_ = "_Tp[_Size]";
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_Reflection {
};
struct __valueless_t_Reflection {
};
struct __traits_Reflection {
};
struct __union_Reflection {
};
struct __base_Reflection {
};
struct __variant_Reflection {
};
struct __base_Reflection {
};
struct __dispatcher_Reflection {
};
struct __variant_Reflection {
};
struct __value_visitor_Reflection {
    static constexpr auto __visitor = "_Visitor &&";
};
struct __alt_Reflection {
    static constexpr auto __value = "__value_type";
};
struct __union_Reflection {
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_TriviallyAvailable, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Available, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Unavailable, _Index + 1, _Types...>";
};
struct __base_Reflection {
    static constexpr auto __data = "__union<_DestructibleTrait, 0, _Types...>";
    static constexpr auto __index = "int";
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __ctor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __impl_Reflection {
};
struct __no_narrowing_check_Reflection {
};
struct __narrowing_check_Reflection {
};
struct __overload_Reflection {
};
struct __all_overloads_Reflection {
};
struct __make_overloads_imp_Reflection {
};
struct variant_Reflection {
    static constexpr auto __impl_ = "__variant_detail::__impl<_Types...>";
};
struct __convert_to_bool_Reflection {
};
struct __has_result_type_Reflection {
};
struct __derives_from_unary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __derives_from_binary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct reference_wrapper_Reflection {
    static constexpr auto __f_ = "type *";
};
struct __allocation_guard_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __n_ = "_Size";
    static constexpr auto __ptr_ = "_Pointer";
};
struct __allocator_destructor_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __s_ = "size_type";
};
struct __move_impl_Reflection {
};
struct _MoveSegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __always_false_Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _AllocatorDestroyRangeReverse_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __first_ = "_Iter &";
    static constexpr auto __last_ = "_Iter &";
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __has_array_cookie_Reflection {
};
struct __private_constructor_tag_Reflection {
};
struct default_delete_Reflection {
};
struct default_delete_Reflection {
};
struct _EnableIfConvertible_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
};
struct __unique_ptr_array_bounds_stateless_Reflection {
};
struct __unique_ptr_array_bounds_stored_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
    static constexpr auto __checker_ = "_BoundsChecker";
};
struct _CheckArrayPointerConversion_Reflection {
};
struct _CheckArrayPointerConversion_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct bad_weak_ptr_Reflection {
};
struct __shared_count_Reflection {
    static constexpr auto __shared_owners_ = "long";
};
struct __shared_weak_count_Reflection {
    static constexpr auto __shared_weak_owners_ = "long";
};
struct __shared_ptr_pointer_Reflection {
    static constexpr auto __ptr_ = "_Tp";
    static constexpr auto __deleter_ = "_Dp";
    static constexpr auto __alloc_ = "_Alloc";
};
struct __for_overwrite_tag_Reflection {
};
struct __shared_ptr_emplace_Reflection {
    static constexpr auto __storage_ = "_Storage";
};
struct _Storage_Reflection {
    static constexpr auto __buffer_ = "char[sizeof(_Data)]";
};
struct _Data_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __elem_ = "int";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __compatible_with_Reflection {
};
struct __raw_pointer_compatible_with_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __well_formed_deleter_Reflection {
};
struct __shared_ptr_deleter_ctor_reqs_Reflection {
};
struct shared_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct __nullptr_sfinae_tag_Reflection {
};
struct __shared_ptr_default_allocator_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __sp_aligned_storage_Reflection {
    static constexpr auto __storage = "char[_Alignment]";
};
struct __unbounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __count_ = "size_t";
    static constexpr auto  = "union std::__unbounded_array_control_block<type-parameter-0-0[], type-parameter-0-1>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:952:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct __bounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto  = "union std::__bounded_array_control_block<type-parameter-0-0[_Np], type-parameter-0-2>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:1030:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[_Count]";
};
struct weak_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct enable_shared_from_this_Reflection {
    static constexpr auto __weak_this_ = "weak_ptr<_Tp>";
};
struct hash_Reflection {
};
struct __sp_mut_Reflection {
    static constexpr auto __lx_ = "void *";
};
struct raw_storage_iterator_Reflection {
    static constexpr auto __x_ = "_OutputIterator";
};
struct __temporary_buffer_deleter_Reflection {
    static constexpr auto __count_ = "ptrdiff_t";
};
struct __move_backward_impl_Reflection {
};
struct __destruct_n_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct __invert_Reflection {
    static constexpr auto __p_ = "_Predicate";
};
struct _ConstTimeDistance_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct _Reflection {
};
struct __aliasing_iterator_wrapper_Reflection {
};
struct __iterator_Reflection {
    static constexpr auto __base_ = "_BaseIter";
};
struct _MinmaxElementLessFunc_Reflection {
    static constexpr auto __comp_ = "_Comp &";
    static constexpr auto __proj_ = "_Proj &";
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct _ProjectedPred_Reflection {
    static constexpr auto __pred = "_Pred &";
    static constexpr auto __proj = "_Proj &";
};
struct __set_intersection_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_symmetric_difference_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_union_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_urng_Reflection {
};
struct __log2_Reflection {
};
struct __independent_bits_engine_Reflection {
    static constexpr auto __e_ = "_Engine &";
    static constexpr auto __w_ = "size_t";
    static constexpr auto __w0_ = "size_t";
    static constexpr auto __n_ = "size_t";
    static constexpr auto __n0_ = "size_t";
    static constexpr auto __y0_ = "_Working_result_type";
    static constexpr auto __y1_ = "_Working_result_type";
    static constexpr auto __mask0_ = "_Engine_result_type";
    static constexpr auto __mask1_ = "_Engine_result_type";
};
struct uniform_int_distribution_Reflection {
    static constexpr auto __p_ = "param_type";
};
struct param_type_Reflection {
    static constexpr auto __a_ = "result_type";
    static constexpr auto __b_ = "result_type";
};
struct __libcpp_debug_randomizer_Reflection {
    static constexpr auto __state_ = "int";
    static constexpr auto __inc_ = "int";
};
struct __stable_sort_switch_Reflection {
};
struct __reread_from_input_tag_Reflection {
};
struct __reread_from_output_tag_Reflection {
};
struct __read_from_tmp_value_tag_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __can_be_converted_to_string_view_Reflection {
};
struct __uninitialized_size_tag_Reflection {
};
struct __init_with_sentinel_tag_Reflection {
};
struct __padding_Reflection {
    static constexpr auto __padding_ = "char[_PaddingSize]";
};
struct __padding_Reflection {
};
struct basic_string_Reflection {
    static constexpr auto __rep_ = "__rep";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __long_Reflection {
    static constexpr auto  = "struct std::basic_string::__long::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:902:5)";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __data_ = "pointer";
};
struct _Reflection {
    static constexpr auto __is_long_ = "size_type";
    static constexpr auto __cap_ = "size_type";
};
struct __short_Reflection {
    static constexpr auto  = "struct std::basic_string::__short::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:913:5)";
    static constexpr auto __padding_ = "__padding<sizeof(value_type) - 1>";
    static constexpr auto __data_ = "value_type[__min_cap]";
};
struct _Reflection {
    static constexpr auto __is_long_ = "unsigned char";
    static constexpr auto __size_ = "unsigned char";
};
struct __rep_Reflection {
    static constexpr auto __s = "__short";
    static constexpr auto __l = "__long";
};
struct __string_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __lconv_storage_Reflection {
    static constexpr auto __lc_ = "int";
    static constexpr auto __decimal_point_ = "int";
    static constexpr auto __thousands_sep_ = "int";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __int_curr_symbol_ = "int";
    static constexpr auto __currency_symbol_ = "int";
    static constexpr auto __mon_decimal_point_ = "int";
    static constexpr auto __mon_thousands_sep_ = "int";
    static constexpr auto __mon_grouping_ = "int";
    static constexpr auto __positive_sign_ = "int";
    static constexpr auto __negative_sign_ = "int";
};
struct locale_t_Reflection {
    static constexpr auto __locale_str_ = "const char *";
    static constexpr auto __lc_ = "__lconv_storage *";
};
struct once_flag_Reflection {
    static constexpr auto __state_ = "_State_type";
};
struct __call_once_param_Reflection {
    static constexpr auto __f_ = "_Fp &";
};
struct __uninitialized_tag_Reflection {
};
struct __no_destroy_Reflection {
    static constexpr auto __obj_ = "char[sizeof(_Tp)]";
};
struct locale_Reflection {
    static constexpr auto __locale_ = "__imp *";
};
struct facet_Reflection {
};
struct id_Reflection {
    static constexpr auto __flag_ = "once_flag";
    static constexpr auto __id_ = "int";
};
struct collate_Reflection {
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_base_Reflection {
};
struct ctype_Reflection {
};
struct ctype_Reflection {
    static constexpr auto __tab_ = "const mask *";
    static constexpr auto __del_ = "_Bool";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_base_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_byname_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_byname_Reflection {
};
struct numpunct_byname_Reflection {
};
struct error_category_Reflection {
};
struct __do_message_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct error_condition_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct is_error_code_enum_Reflection {
};
struct error_code_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct system_error_Reflection {
    static constexpr auto __ec_ = "error_code";
};
struct ios_base_Reflection {
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __precision_ = "streamsize";
    static constexpr auto __width_ = "streamsize";
    static constexpr auto __rdstate_ = "iostate";
    static constexpr auto __exceptions_ = "iostate";
    static constexpr auto __rdbuf_ = "void *";
    static constexpr auto __loc_ = "void *";
    static constexpr auto __fn_ = "event_callback *";
    static constexpr auto __index_ = "int *";
    static constexpr auto __event_size_ = "size_t";
    static constexpr auto __event_cap_ = "size_t";
    static constexpr auto __iarray_ = "long *";
    static constexpr auto __iarray_size_ = "size_t";
    static constexpr auto __iarray_cap_ = "size_t";
    static constexpr auto __parray_ = "void **";
    static constexpr auto __parray_size_ = "size_t";
    static constexpr auto __parray_cap_ = "size_t";
};
struct is_error_code_enum_Reflection {
};
struct failure_Reflection {
};
struct Init_Reflection {
};
struct _FillHelper_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
    static constexpr auto __set_ = "_Bool";
};
struct _SentinelValueFill_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
};
struct basic_ios_Reflection {
    static constexpr auto __tie_ = "basic_ostream<char_type, traits_type> *";
    static constexpr auto __fill_ = "_FillType";
};
struct mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_mutex_t";
};
struct defer_lock_t_Reflection {
};
struct try_to_lock_t_Reflection {
};
struct adopt_lock_t_Reflection {
};
struct unique_lock_Reflection {
    static constexpr auto __m_ = "mutex_type *";
    static constexpr auto __owns_ = "_Bool";
};
struct condition_variable_Reflection {
    static constexpr auto __cv_ = "__libcpp_condvar_t";
};
struct lock_guard_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct __thread_id_Reflection {
    static constexpr auto __id_ = "__libcpp_thread_id";
};
struct recursive_mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_recursive_mutex_t";
};
struct timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __locked_ = "_Bool";
};
struct recursive_timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __count_ = "size_t";
    static constexpr auto __id_ = "__thread_id";
};
struct scoped_lock_Reflection {
};
struct scoped_lock_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct scoped_lock_Reflection {
    static constexpr auto __t_ = "_MutexTuple";
};
struct __has_storage_type_Reflection {
};
struct __bit_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_reference_Reflection {
};
struct __bit_const_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_array_Reflection {
    static constexpr auto __size_ = "difference_type";
    static constexpr auto __word_ = "__storage_type[4]";
};
struct __bit_iterator_Reflection {
    static constexpr auto __seg_ = "int";
    static constexpr auto __ctz_ = "unsigned int";
};
struct __has_storage_type_Reflection {
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type[_N_words]";
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type";
};
struct __bitset_Reflection {
};
struct bitset_Reflection {
};
struct hash_Reflection {
};
struct basic_streambuf_Reflection {
    static constexpr auto __loc_ = "locale";
    static constexpr auto __binp_ = "char_type *";
    static constexpr auto __ninp_ = "char_type *";
    static constexpr auto __einp_ = "char_type *";
    static constexpr auto __bout_ = "char_type *";
    static constexpr auto __nout_ = "char_type *";
    static constexpr auto __eout_ = "char_type *";
};
struct __num_get_base_Reflection {
};
struct __num_get_Reflection {
};
struct num_get_Reflection {
};
struct __num_put_base_Reflection {
};
struct __num_put_Reflection {
};
struct num_put_Reflection {
};
struct time_base_Reflection {
};
struct __time_get_c_storage_Reflection {
};
struct time_get_Reflection {
};
struct __time_get_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct __time_get_storage_Reflection {
    static constexpr auto __weeks_ = "string_type[14]";
    static constexpr auto __months_ = "string_type[24]";
    static constexpr auto __am_pm_ = "string_type[2]";
    static constexpr auto __c_ = "string_type";
    static constexpr auto __r_ = "string_type";
    static constexpr auto __x_ = "string_type";
    static constexpr auto __X_ = "string_type";
};
struct time_get_byname_Reflection {
};
struct __time_put_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct time_put_Reflection {
};
struct time_put_byname_Reflection {
};
struct money_base_Reflection {
};
struct pattern_Reflection {
    static constexpr auto field = "char[4]";
};
struct moneypunct_Reflection {
};
struct moneypunct_byname_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __curr_symbol_ = "string_type";
    static constexpr auto __positive_sign_ = "string_type";
    static constexpr auto __negative_sign_ = "string_type";
    static constexpr auto __frac_digits_ = "int";
    static constexpr auto __pos_format_ = "pattern";
    static constexpr auto __neg_format_ = "pattern";
};
struct __money_get_Reflection {
};
struct money_get_Reflection {
};
struct __money_put_Reflection {
};
struct money_put_Reflection {
};
struct messages_base_Reflection {
};
struct messages_Reflection {
};
struct messages_byname_Reflection {
};
struct wstring_convert_Reflection {
    static constexpr auto __byte_err_string_ = "byte_string";
    static constexpr auto __wide_err_string_ = "wide_string";
    static constexpr auto __cvtptr_ = "_Codecvt *";
    static constexpr auto __cvtstate_ = "state_type";
    static constexpr auto __cvtcount_ = "size_t";
};
struct wbuffer_convert_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __bufptr_ = "int *";
    static constexpr auto __cv_ = "_Codecvt *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ostream_Reflection {
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
    static constexpr auto __os_ = "basic_ostream<_CharT, _Traits> &";
};
struct __is_ostreamable_Reflection {
};
struct __is_ostreamable_Reflection {
};
struct basic_istream_Reflection {
    static constexpr auto __gc_ = "streamsize";
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
};
struct __is_istreamable_Reflection {
};
struct __is_istreamable_Reflection {
};
struct basic_iostream_Reflection {
};
struct array_Reflection {
    static constexpr auto __elems_ = "_Tp[_Size]";
};
struct array_Reflection {
    static constexpr auto __elems_ = "int[sizeof(_ArrayInStructT)]";
};
struct _ArrayInStructT_Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct __temp_value_Reflection {
    static constexpr auto  = "union std::__temp_value::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\temp_value.h:31:3)";
    static constexpr auto __a = "_Alloc &";
};
struct _Reflection {
    static constexpr auto __v = "_Tp";
};
struct __split_buffer_Reflection {
    static constexpr auto __first_ = "int";
    static constexpr auto __begin_ = "int";
    static constexpr auto __end_ = "int";
    static constexpr auto __end_cap_ = "int";
    static constexpr auto __alloc_ = "allocator_type";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "const int";
    static constexpr auto __dest_ = "int *";
};
struct __container_traits_Reflection {
};
struct __deque_block_size_Reflection {
};
struct __deque_iterator_Reflection {
    static constexpr auto __m_iter_ = "__map_iterator";
    static constexpr auto __ptr_ = "pointer";
};
struct deque_Reflection {
    static constexpr auto __map_ = "int";
    static constexpr auto __start_ = "size_type";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __deque_block_range_Reflection {
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __end_ = "const pointer";
};
struct __deque_range_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "int";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __end_ = "const pointer";
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __base_ = "deque<_Tp, _Allocator> *const";
};
struct __container_traits_Reflection {
};
struct binary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct is_bind_expression_Reflection {
};
struct is_placeholder_Reflection {
};
struct __ph_Reflection {
};
struct is_placeholder_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_Reflection {
    static constexpr auto __f_ = "int";
    static constexpr auto __bound_args_ = "_Td";
};
struct is_bind_expression_Reflection {
};
struct __bind_r_Reflection {
};
struct is_bind_expression_Reflection {
};
struct __mem_fn_Reflection {
    static constexpr auto __f_ = "type";
};
struct unary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct __builtin_new_allocator_Reflection {
};
struct __builtin_new_deleter_Reflection {
    static constexpr auto __size_ = "size_t";
    static constexpr auto __align_ = "size_t";
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct bad_function_call_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __alloc_func_Reflection {
    static constexpr auto __func_ = "_Fp";
    static constexpr auto __alloc_ = "_Ap";
};
struct __default_alloc_func_Reflection {
    static constexpr auto __f_ = "_Fp";
};
struct __base_Reflection {
};
struct __func_Reflection {
    static constexpr auto __f_ = "__alloc_func<_Fp, _Alloc, _Rp (_ArgTypes...)>";
};
struct __value_func_Reflection {
    static constexpr auto __buf_ = "int";
    static constexpr auto __f_ = "__func *";
};
struct __policy_storage_Reflection {
    static constexpr auto __small = "char[16]";
    static constexpr auto __large = "void *";
};
struct __use_small_storage_Reflection {
};
struct __policy_Reflection {
    static constexpr auto __clone = "void *(*const)(const void *)";
    static constexpr auto __destroy = "void (*const)(void *)";
    static constexpr auto __is_null = "const _Bool";
    static constexpr auto __type_info = "const int *const";
};
struct __policy_invoker_Reflection {
    static constexpr auto __call_ = "__Call";
};
struct __policy_func_Reflection {
    static constexpr auto __buf_ = "__policy_storage";
    static constexpr auto __invoker_ = "__invoker";
    static constexpr auto __policy_ = "const __policy *";
};
struct function_Reflection {
    static constexpr auto __f_ = "__func";
};
struct __callable_Reflection {
};
struct __extract_key_fail_tag_Reflection {
};
struct __extract_key_self_tag_Reflection {
};
struct __extract_key_first_tag_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __hash_node_base_Reflection {
    static constexpr auto __next_ = "__next_pointer";
};
struct __hash_node_Reflection {
    static constexpr auto __hash_ = "size_t";
    static constexpr auto  = "union std::__hash_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__hash_table:124:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __hash_key_value_types_Reflection {
};
struct __hash_key_value_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_node_types_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __make_hash_node_types_Reflection {
};
struct __hash_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_const_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __hash_const_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __bucket_list_deallocator_Reflection {
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __hash_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __enforce_unordered_container_requirements_Reflection {
};
struct __hash_table_Reflection {
    static constexpr auto __bucket_list_ = "__bucket_list";
    static constexpr auto __first_node_ = "__first_node";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __hasher_ = "hasher";
    static constexpr auto __max_load_factor_ = "float";
    static constexpr auto __key_eq_ = "key_equal";
};
struct __basic_node_handle_Reflection {
    static constexpr auto __ptr_ = "__node_pointer_type";
    static constexpr auto __alloc_ = "optional<allocator_type>";
};
struct __set_node_handle_specifics_Reflection {
};
struct __map_node_handle_specifics_Reflection {
};
struct __insert_return_type_Reflection {
    static constexpr auto position = "_Iterator";
    static constexpr auto inserted = "_Bool";
    static constexpr auto node = "_NodeType";
};
struct __unordered_map_hasher_Reflection {
};
struct __unordered_map_hasher_Reflection {
    static constexpr auto __hash_ = "_Hash";
};
struct __unordered_map_equal_Reflection {
};
struct __unordered_map_equal_Reflection {
    static constexpr auto __pred_ = "_Pred";
};
struct __hash_map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __hash_value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __hash_map_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct __hash_map_const_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct unordered_map_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multimap_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct to_chars_result_Reflection {
    static constexpr auto ptr = "char *";
    static constexpr auto ec = "errc";
};
struct __traits_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "pointer";
    static constexpr auto __end_ = "pointer";
    static constexpr auto __cap_ = "pointer";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Tp, _Alloc> &";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __v_ = "vector<_Tp, _Alloc> &";
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __new_end_ = "const const_pointer";
};
struct __has_storage_type_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "__storage_pointer";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __cap_ = "size_type";
    static constexpr auto __alloc_ = "__storage_allocator";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Bool, type-parameter-0-0> &";
};
struct hash_Reflection {
};
struct __container_traits_Reflection {
};
struct _BMSkipTable_Reflection {
    static constexpr auto __default_value_ = "const value_type";
    static constexpr auto __table_ = "int";
};
struct _BMSkipTable_Reflection {
    static constexpr auto __table_ = "std::array<value_type, 256>";
};
struct boyer_moore_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
    static constexpr auto __suffix_ = "shared_ptr<difference_type[]>";
};
struct boyer_moore_horspool_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
};
struct default_searcher_Reflection {
    static constexpr auto __first_ = "_ForwardIterator";
    static constexpr auto __last_ = "_ForwardIterator";
    static constexpr auto __pred_ = "_BinaryPredicate";
};
struct __not_fn_op_Reflection {
};
struct __not_fn_t_Reflection {
};
struct queue_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct priority_queue_Reflection {
    static constexpr auto c = "container_type";
    static constexpr auto comp = "value_compare";
};
struct uses_allocator_Reflection {
};
struct stack_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct _FilesystemClock_Reflection {
};
struct __forward_list_node_value_type_Reflection {
};
struct __forward_node_traits_Reflection {
};
struct __forward_begin_node_Reflection {
    static constexpr auto __next_ = "pointer";
};
struct __forward_list_node_Reflection {
    static constexpr auto  = "union std::__forward_list_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\forward_list:328:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __forward_list_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_base_Reflection {
    static constexpr auto __before_begin_ = "__begin_node";
    static constexpr auto __alloc_ = "__node_allocator";
};
struct forward_list_Reflection {
};
struct __container_traits_Reflection {
};
struct basic_stringbuf_Reflection {
    static constexpr auto __str_ = "string_type";
    static constexpr auto __hm_ = "char_type *";
    static constexpr auto __mode_ = "class ios_base::openmode";
};
struct basic_istringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_ostringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_stringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct unordered_set_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multiset_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct null_mutex_Reflection {
};
struct null_atomic_int_Reflection {
    static constexpr auto value = "int";
};
struct type_identity_Reflection {
};
struct is_contiguous_Reflection {
};
struct monostate_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto data_ = "const Char *";
    static constexpr auto size_ = "size_t";
};
struct is_char_Reflection {
};
struct is_char_Reflection {
};
struct compile_string_Reflection {
};
struct is_compile_string_Reflection {
};
struct is_string_Reflection {
};
struct char_t_impl_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct error_handler_Reflection {
};
struct basic_format_parse_context_Reflection {
    static constexpr auto format_str_ = "basic_string_view<Char>";
    static constexpr auto next_arg_id_ = "int";
};
struct compile_parse_context_Reflection {
    static constexpr auto num_args_ = "int";
    static constexpr auto types_ = "const type *";
};
struct buffer_Reflection {
    static constexpr auto ptr_ = "T *";
    static constexpr auto size_ = "size_t";
    static constexpr auto capacity_ = "size_t";
};
struct buffer_traits_Reflection {
};
struct fixed_buffer_traits_Reflection {
    static constexpr auto count_ = "size_t";
    static constexpr auto limit_ = "size_t";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto data_ = "T[buffer_size]";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "T *";
    static constexpr auto data_ = "T[buffer_size]";
};
struct counting_buffer_Reflection {
    static constexpr auto data_ = "T[buffer_size]";
    static constexpr auto count_ = "size_t";
};
struct formatter_Reflection {
};
struct appender_Reflection {
};
struct view_Reflection {
};
struct named_arg_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto value = "const T &";
};
struct named_arg_info_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto id = "int";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)]";
    static constexpr auto named_args_ = "named_arg_info<Char>[NUM_NAMED_ARGS]";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[NUM_ARGS != 0 ? NUM_ARGS : +1]";
};
struct is_named_arg_Reflection {
};
struct is_statically_named_arg_Reflection {
};
struct is_named_arg_Reflection {
};
struct unformattable_Reflection {
};
struct unformattable_char_Reflection {
};
struct unformattable_pointer_Reflection {
};
struct string_value_Reflection {
    static constexpr auto data = "const Char *";
    static constexpr auto size = "size_t";
};
struct named_arg_value_Reflection {
    static constexpr auto data = "const named_arg_info<Char> *";
    static constexpr auto size = "size_t";
};
struct custom_value_Reflection {
    static constexpr auto value = "void *";
    static constexpr auto format = "void (*)(void *, parse_context &, Context &)";
};
struct value_Reflection {
    static constexpr auto  = "union fmt::detail::value::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1261:3)";
};
struct _Reflection {
    static constexpr auto no_value = "monostate";
    static constexpr auto int_value = "int";
    static constexpr auto uint_value = "unsigned int";
    static constexpr auto long_long_value = "long long";
    static constexpr auto ulong_long_value = "unsigned long long";
    static constexpr auto int128_value = "int128_opt";
    static constexpr auto uint128_value = "uint128_opt";
    static constexpr auto bool_value = "_Bool";
    static constexpr auto char_value = "char_type";
    static constexpr auto float_value = "float";
    static constexpr auto double_value = "double";
    static constexpr auto long_double_value = "long double";
    static constexpr auto pointer = "const void *";
    static constexpr auto string = "string_value<char_type>";
    static constexpr auto custom = "custom_value<Context>";
    static constexpr auto named_args = "named_arg_value<char_type>";
};
struct format_as_result_Reflection {
};
struct has_format_as_Reflection {
};
struct arg_mapper_Reflection {
};
struct formattable_Reflection {
};
struct is_output_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct locale_ref_Reflection {
    static constexpr auto locale_ = "const void *";
};
struct basic_format_arg_Reflection {
    static constexpr auto value_ = "detail::value<Context>";
    static constexpr auto type_ = "detail::type";
};
struct handle_Reflection {
    static constexpr auto custom_ = "detail::custom_value<Context>";
};
struct basic_format_context_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto args_ = "basic_format_args<basic_format_context<OutputIt, Char> >";
    static constexpr auto loc_ = "detail::locale_ref";
};
struct format_arg_store_Reflection {
    static constexpr auto data_ = "int";
};
struct basic_format_args_Reflection {
    static constexpr auto desc_ = "unsigned long long";
    static constexpr auto  = "union fmt::basic_format_args::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1902:3)";
};
struct _Reflection {
    static constexpr auto values_ = "const detail::value<Context> *";
    static constexpr auto args_ = "const format_arg *";
};
struct fill_t_Reflection {
    static constexpr auto data_ = "Char[max_size]";
    static constexpr auto size_ = "unsigned char";
};
struct format_specs_Reflection {
    static constexpr auto width = "int";
    static constexpr auto precision = "int";
    static constexpr auto type = "presentation_type";
    static constexpr auto align = "align_t";
    static constexpr auto sign = "sign_t";
    static constexpr auto alt = "_Bool";
    static constexpr auto localized = "_Bool";
    static constexpr auto fill = "detail::fill_t<Char>";
};
struct arg_ref_Reflection {
    static constexpr auto kind = "arg_id_kind";
    static constexpr auto val = "union value";
};
struct value_Reflection {
    static constexpr auto index = "int";
    static constexpr auto name = "basic_string_view<Char>";
};
struct dynamic_format_specs_Reflection {
    static constexpr auto width_ref = "arg_ref<Char>";
    static constexpr auto precision_ref = "arg_ref<Char>";
};
struct dynamic_spec_id_handler_Reflection {
    static constexpr auto ctx = "basic_format_parse_context<Char> &";
    static constexpr auto ref = "arg_ref<Char> &";
};
struct _Reflection {
    static constexpr auto current_state = "state";
};
struct _Reflection {
    static constexpr auto begin = "const Char *&";
    static constexpr auto specs = "dynamic_format_specs<Char> &";
    static constexpr auto arg_type = "type";
};
struct id_adapter_Reflection {
    static constexpr auto handler = "Handler &";
    static constexpr auto arg_id = "int";
};
struct writer_Reflection {
    static constexpr auto handler_ = "Handler &";
};
struct strip_named_arg_Reflection {
};
struct strip_named_arg_Reflection {
};
struct format_string_checker_Reflection {
    static constexpr auto types_ = "type[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
    static constexpr auto context_ = "parse_context_type";
    static constexpr auto parse_funcs_ = "parse_func[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
};
struct vformat_args_Reflection {
};
struct vformat_args_Reflection {
};
struct runtime_format_string_Reflection {
    static constexpr auto str = "basic_string_view<Char>";
};
struct basic_format_string_Reflection {
    static constexpr auto str_ = "basic_string_view<Char>";
};
struct format_to_n_result_Reflection {
    static constexpr auto out = "OutputIt";
    static constexpr auto size = "size_t";
};
struct __uintr_frame_Reflection {
    static constexpr auto rip = "unsigned long long";
    static constexpr auto rflags = "unsigned long long";
    static constexpr auto rsp = "unsigned long long";
};
struct __mm_loadh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadh_pi_v2f32";
};
struct __mm_loadl_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadl_pi_v2f32";
};
struct __mm_load_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __mm_load1_ps_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_store_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_load1_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __loadu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __loadu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __loadu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_load_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadl_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_store_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __mm_loadl_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __storeu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __storeu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __storeu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_storel_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __mm_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __mm256_broadcast_sd_struct_Reflection {
    static constexpr auto __d = "double";
};
struct __mm256_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __loadu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __storeu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __mm_load_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __mm_store_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __loadu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __storeu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __loadu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __storeu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __loadu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __storeu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __tile1024i_str_Reflection {
    static constexpr auto row = "const unsigned short";
    static constexpr auto col = "const unsigned short";
    static constexpr auto tile = "_tile1024i";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __mm_store_sbh_struct_Reflection {
    static constexpr auto __u = "__bf16";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct string_literal_Reflection {
};
struct uint128_fallback_Reflection {
    static constexpr auto lo_ = "int";
    static constexpr auto hi_ = "int";
};
struct _Reflection {
    static constexpr auto  = "F";
};
struct count_code_points_Reflection {
    static constexpr auto count = "size_t *";
};
struct _Reflection {
    static constexpr auto  = "const char *";
    static constexpr auto  = "size_t &";
    static constexpr auto  = "size_t &";
};
struct is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_locale_Reflection {
};
struct basic_memory_buffer_Reflection {
    static constexpr auto store_ = "T[SIZE]";
    static constexpr auto alloc_ = "Allocator";
};
struct is_contiguous_Reflection {
};
struct format_error_Reflection {
};
struct loc_value_Reflection {
    static constexpr auto value_ = "int";
};
struct format_facet_Reflection {
    static constexpr auto separator_ = "int";
    static constexpr auto grouping_ = "int";
    static constexpr auto decimal_point_ = "int";
};
struct _Reflection {
};
struct thousands_sep_result_Reflection {
    static constexpr auto grouping = "int";
    static constexpr auto thousands_sep = "Char";
};
struct format_decimal_result_Reflection {
    static constexpr auto begin = "Iterator";
    static constexpr auto end = "Iterator";
};
struct utf8_to_utf16_Reflection {
    static constexpr auto buffer_ = "int";
};
struct to_utf8_Reflection {
    static constexpr auto buffer_ = "Buffer";
};
struct decimal_fp_Reflection {
    static constexpr auto significand = "int";
    static constexpr auto exponent = "int";
};
struct basic_fp_Reflection {
    static constexpr auto f = "F";
    static constexpr auto e = "int";
};
struct _Reflection {
};
struct find_escape_result_Reflection {
    static constexpr auto begin = "const Char *";
    static constexpr auto end = "const Char *";
    static constexpr auto cp = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct write_int_data_Reflection {
    static constexpr auto size = "size_t";
    static constexpr auto padding = "size_t";
};
struct _Reflection {
};
struct digit_grouping_Reflection {
    static constexpr auto grouping_ = "int";
    static constexpr auto thousands_sep_ = "int";
};
struct next_state_Reflection {
    static constexpr auto group = "int";
    static constexpr auto pos = "int";
};
struct write_int_arg_Reflection {
    static constexpr auto abs_value = "UInt";
    static constexpr auto prefix = "unsigned int";
};
struct loc_writer_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto sep = "int";
    static constexpr auto grouping = "int";
    static constexpr auto decimal_point = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct counting_iterator_Reflection {
    static constexpr auto count_ = "size_t";
};
struct value_type_Reflection {
};
struct _Reflection {
};
struct float_specs_Reflection {
    static constexpr auto precision = "int";
    static constexpr auto format = "float_format";
    static constexpr auto sign = "sign_t";
    static constexpr auto upper = "_Bool";
    static constexpr auto locale = "_Bool";
    static constexpr auto binary32 = "_Bool";
    static constexpr auto showpoint = "_Bool";
};
struct big_decimal_fp_Reflection {
    static constexpr auto significand = "const char *";
    static constexpr auto significand_size = "int";
    static constexpr auto exponent = "int";
};
struct fallback_digit_grouping_Reflection {
};
struct has_isfinite_Reflection {
};
struct bigint_Reflection {
    static constexpr auto bigits_ = "int";
    static constexpr auto exp_ = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct default_arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto args = "int";
    static constexpr auto loc = "locale_ref";
};
struct arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto locale = "locale_ref";
};
struct width_checker_Reflection {
};
struct precision_checker_Reflection {
};
struct udl_arg_Reflection {
    static constexpr auto str = "const Char *";
};
struct format_int_Reflection {
    static constexpr auto buffer_ = "char[0]";
    static constexpr auto str_ = "char *";
};
struct bytes_Reflection {
    static constexpr auto data_ = "string_view";
};
struct group_digits_view_Reflection {
    static constexpr auto value = "T";
};
struct nested_view_Reflection {
    static constexpr auto fmt = "const int *";
    static constexpr auto value = "const T *";
};
struct nested_formatter_Reflection {
    static constexpr auto width_ = "int";
    static constexpr auto fill_ = "detail::fill_t<char>";
    static constexpr auto align_ = "align_t";
    static constexpr auto formatter_ = "int";
};
struct join_view_Reflection {
    static constexpr auto begin = "It";
    static constexpr auto end = "Sentinel";
    static constexpr auto sep = "basic_string_view<Char>";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
    static constexpr auto divisor = "int";
    static constexpr auto shift_amount = "int";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct _Reflection {
    static constexpr auto  = "class fmt::detail::utf8_to_utf16 *";
};
struct singleton_Reflection {
    static constexpr auto upper = "unsigned char";
    static constexpr auto lower_count = "unsigned char";
};
struct is_convertible_to_basic_format_string_Reflection {
};
struct is_convertible_to_any_format_string_Reflection {
};
struct spdlog_ex_Reflection {
    static constexpr auto msg_ = "int";
};
struct source_loc_Reflection {
    static constexpr auto filename = "const char *";
    static constexpr auto line = "int";
    static constexpr auto funcname = "const char *";
};
struct file_event_handlers_Reflection {
    static constexpr auto before_open = "std::function<void (const int &)>";
    static constexpr auto after_open = "std::function<void (const int &, int *)>";
    static constexpr auto before_close = "std::function<void (const int &, int *)>";
    static constexpr auto after_close = "std::function<void (const int &)>";
};
struct condition_variable_any_Reflection {
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __mut_ = "shared_ptr<mutex>";
};
struct __unlock_guard_Reflection {
    static constexpr auto __lock_ = "_Lock &";
};
struct __thread_struct_Reflection {
    static constexpr auto __p_ = "__thread_struct_imp *";
};
struct __thread_specific_ptr_Reflection {
    static constexpr auto __key_ = "__libcpp_tls_key";
};
struct hash_Reflection {
};
struct thread_Reflection {
    static constexpr auto __t_ = "__libcpp_thread_t";
};
struct periodic_worker_Reflection {
    static constexpr auto active_ = "_Bool";
    static constexpr auto worker_thread_ = "std::thread";
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto cv_ = "std::condition_variable";
};
struct registry_Reflection {
    static constexpr auto logger_map_mutex_ = "std::mutex";
    static constexpr auto flusher_mutex_ = "std::mutex";
    static constexpr auto tp_mutex_ = "std::recursive_mutex";
    static constexpr auto log_levels_ = "int";
    static constexpr auto formatter_ = "int";
    static constexpr auto global_log_level_ = "spdlog::level::level_enum";
    static constexpr auto flush_level_ = "level::level_enum";
    static constexpr auto err_handler_ = "err_handler";
    static constexpr auto tp_ = "std::shared_ptr<thread_pool>";
    static constexpr auto periodic_flusher_ = "int";
    static constexpr auto default_logger_ = "std::shared_ptr<logger>";
    static constexpr auto automatic_registration_ = "_Bool";
    static constexpr auto backtrace_n_messages_ = "size_t";
};
struct circular_q_Reflection {
    static constexpr auto max_items_ = "size_t";
    static constexpr auto head_ = "int";
    static constexpr auto tail_ = "int";
    static constexpr auto overrun_counter_ = "size_t";
    static constexpr auto v_ = "int";
};
struct log_msg_Reflection {
    static constexpr auto logger_name = "string_view_t";
    static constexpr auto level = "level::level_enum";
    static constexpr auto time = "log_clock::time_point";
    static constexpr auto thread_id = "size_t";
    static constexpr auto color_range_start = "size_t";
    static constexpr auto color_range_end = "size_t";
    static constexpr auto source = "source_loc";
    static constexpr auto payload = "string_view_t";
};
struct log_msg_buffer_Reflection {
    static constexpr auto buffer = "int";
};
struct backtracer_Reflection {
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto enabled_ = "std::atomic<_Bool>";
    static constexpr auto messages_ = "circular_q<log_msg_buffer>";
};
struct logger_Reflection {
    static constexpr auto name_ = "int";
    static constexpr auto sinks_ = "int";
    static constexpr auto level_ = "spdlog::level_t";
    static constexpr auto flush_level_ = "spdlog::level_t";
    static constexpr auto custom_err_handler_ = "err_handler";
    static constexpr auto tracer_ = "details::backtracer";
};
struct formatter_Reflection {
};
struct padding_info_Reflection {
    static constexpr auto width_ = "size_t";
    static constexpr auto side_ = "pad_side";
    static constexpr auto truncate_ = "_Bool";
    static constexpr auto enabled_ = "_Bool";
};
struct flag_formatter_Reflection {
    static constexpr auto padinfo_ = "padding_info";
};
struct custom_flag_formatter_Reflection {
};
struct pattern_formatter_Reflection {
    static constexpr auto pattern_ = "int";
    static constexpr auto eol_ = "int";
    static constexpr auto pattern_time_type_ = "pattern_time_type";
    static constexpr auto need_localtime_ = "_Bool";
    static constexpr auto cached_tm_ = "int";
    static constexpr auto last_log_secs_ = "std::chrono::seconds";
    static constexpr auto formatters_ = "int";
    static constexpr auto custom_handlers_ = "int";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_node_base_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_node_types_Reflection {
};
struct __make_tree_node_types_Reflection {
};
struct __tree_end_node_Reflection {
    static constexpr auto __left_ = "pointer";
};
struct __tree_node_base_Reflection {
    static constexpr auto __right_ = "pointer";
    static constexpr auto __parent_ = "__parent_pointer";
    static constexpr auto __is_black_ = "_Bool";
};
struct __tree_node_Reflection {
    static constexpr auto __value_ = "__node_value_type";
};
struct __tree_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __tree_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_Reflection {
    static constexpr auto __begin_node_ = "__iter_pointer";
    static constexpr auto __end_node_ = "__end_node_t";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __value_comp_ = "value_compare";
};
struct _DetachedTreeCache_Reflection {
    static constexpr auto __t_ = "__tree<_Tp, _Compare, _Allocator> *";
    static constexpr auto __cache_root_ = "__node_pointer";
    static constexpr auto __cache_elem_ = "__node_pointer";
};
struct __map_value_compare_Reflection {
};
struct __map_value_compare_Reflection {
    static constexpr auto __comp_ = "_Compare";
};
struct __map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __extract_key_value_types_Reflection {
};
struct __map_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct __map_const_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct map_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct multimap_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct mdc_Reflection {
};
struct scoped_padder_Reflection {
    static constexpr auto padinfo_ = "const padding_info &";
    static constexpr auto dest_ = "int &";
    static constexpr auto remaining_pad_ = "long";
    static constexpr auto spaces_ = "string_view_t";
};
struct null_scoped_padder_Reflection {
};
struct name_formatter_Reflection {
};
struct level_formatter_Reflection {
};
struct short_level_formatter_Reflection {
};
struct a_formatter_Reflection {
};
struct A_formatter_Reflection {
};
struct b_formatter_Reflection {
};
struct B_formatter_Reflection {
};
struct c_formatter_Reflection {
};
struct C_formatter_Reflection {
};
struct D_formatter_Reflection {
};
struct Y_formatter_Reflection {
};
struct m_formatter_Reflection {
};
struct d_formatter_Reflection {
};
struct H_formatter_Reflection {
};
struct I_formatter_Reflection {
};
struct M_formatter_Reflection {
};
struct S_formatter_Reflection {
};
struct e_formatter_Reflection {
};
struct f_formatter_Reflection {
};
struct F_formatter_Reflection {
};
struct E_formatter_Reflection {
};
struct p_formatter_Reflection {
};
struct r_formatter_Reflection {
};
struct R_formatter_Reflection {
};
struct T_formatter_Reflection {
};
struct z_formatter_Reflection {
    static constexpr auto last_update_ = "log_clock::time_point";
    static constexpr auto offset_minutes_ = "int";
};
struct t_formatter_Reflection {
};
struct pid_formatter_Reflection {
};
struct v_formatter_Reflection {
};
struct ch_formatter_Reflection {
    static constexpr auto ch_ = "char";
};
struct aggregate_formatter_Reflection {
    static constexpr auto str_ = "int";
};
struct color_start_formatter_Reflection {
};
struct color_stop_formatter_Reflection {
};
struct source_location_formatter_Reflection {
};
struct source_filename_formatter_Reflection {
};
struct short_filename_formatter_Reflection {
};
struct source_linenum_formatter_Reflection {
};
struct source_funcname_formatter_Reflection {
};
struct elapsed_formatter_Reflection {
    static constexpr auto last_message_time_ = "log_clock::time_point";
};
struct mdc_formatter_Reflection {
};
struct full_formatter_Reflection {
    static constexpr auto cache_timestamp_ = "std::chrono::seconds";
    static constexpr auto cached_datetime_ = "int";
    static constexpr auto mdc_formatter_ = "mdc_formatter<null_scoped_padder>";
};
struct sink_Reflection {
    static constexpr auto level_ = "level_t";
};
struct console_mutex_Reflection {
};
struct console_nullmutex_Reflection {
};
struct wincolor_sink_Reflection {
    static constexpr auto out_handle_ = "void *";
    static constexpr auto mutex_ = "mutex_t &";
    static constexpr auto should_do_colors_ = "_Bool";
    static constexpr auto formatter_ = "int";
    static constexpr auto colors_ = "std::array<int, level::n_levels>";
};
struct wincolor_stdout_sink_Reflection {
};
struct wincolor_stderr_sink_Reflection {
};
struct synchronous_factory_Reflection {
};
struct file_helper_Reflection {
    static constexpr auto open_tries_ = "const int";
    static constexpr auto open_interval_ = "const unsigned int";
    static constexpr auto fd_ = "int *";
    static constexpr auto filename_ = "int";
    static constexpr auto event_handlers_ = "file_event_handlers";
};
struct base_sink_Reflection {
    static constexpr auto formatter_ = "int";
    static constexpr auto mutex_ = "Mutex";
};
struct basic_file_sink_Reflection {
    static constexpr auto file_helper_ = "details::file_helper";
};
struct __iom_t1_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t2_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t3_Reflection {
    static constexpr auto __base_ = "int";
};
struct __iom_t4_Reflection {
    static constexpr auto __fill_ = "_CharT";
};
struct __iom_t5_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t6_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t7_Reflection {
    static constexpr auto __mon_ = "_MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t8_Reflection {
    static constexpr auto __mon_ = "const _MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t9_Reflection {
    static constexpr auto __tm_ = "int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __iom_t10_Reflection {
    static constexpr auto __tm_ = "const int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __quoted_output_proxy_Reflection {
    static constexpr auto __first_ = "const _CharT *";
    static constexpr auto __last_ = "const _CharT *";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __quoted_proxy_Reflection {
    static constexpr auto __string_ = "basic_string<_CharT, _Traits, _Allocator> &";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct _NullSentinel_Reflection {
};
struct __is_pathable_string_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_iter_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct path_Reflection {
    static constexpr auto __pn_ = "string_type";
};
struct basic_filebuf_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __file_ = "int *";
    static constexpr auto __cv_ = "const codecvt<char_type, char, state_type> *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __st_last_ = "state_type";
    static constexpr auto __om_ = "class ios_base::openmode";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ifstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_ofstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_fstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct file_status_Reflection {
    static constexpr auto __ft_ = "file_type";
    static constexpr auto __prms_ = "perms";
};
struct space_info_Reflection {
    static constexpr auto capacity = "int";
    static constexpr auto free = "int";
    static constexpr auto available = "int";
};
struct directory_entry_Reflection {
    static constexpr auto __p_ = "_Path";
    static constexpr auto __data_ = "__cached_data";
};
struct __cached_data_Reflection {
    static constexpr auto __size_ = "int";
    static constexpr auto __nlink_ = "int";
    static constexpr auto __write_time_ = "file_time_type";
    static constexpr auto __sym_perms_ = "perms";
    static constexpr auto __non_sym_perms_ = "perms";
    static constexpr auto __type_ = "file_type";
    static constexpr auto __cache_type_ = "_CacheType";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct __dir_element_proxy_Reflection {
    static constexpr auto __elem_ = "directory_entry";
};
struct directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__dir_stream>";
};
struct iterator_Reflection {
    static constexpr auto __stashed_elem_ = "path";
    static constexpr auto __path_ptr_ = "const path *";
    static constexpr auto __entry_ = "class path::__string_view";
    static constexpr auto __state_ = "_ParserState";
};
struct recursive_directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__shared_imp>";
    static constexpr auto __rec_ = "_Bool";
};
struct formatbuf_Reflection {
    static constexpr auto buffer_ = "buffer<char_type> &";
};
struct file_access_tag_Reflection {
};
struct file_access_Reflection {
};
struct streamed_view_Reflection {
    static constexpr auto value = "const T &";
};
struct basic_ostream_formatter_Reflection {
};
struct Logger_Reflection {
};
struct Event_Reflection {
    static constexpr auto Handled = "_Bool";
};
struct EventDispatcher_Reflection {
    static constexpr auto m_Event = "Event &";
};
struct WindowProperties_Reflection {
    static constexpr auto Title = "int";
    static constexpr auto Width = "unsigned int";
    static constexpr auto Height = "unsigned int";
};
struct Window_Reflection {
};
struct GLFWvidmode_Reflection {
    static constexpr auto width = "int";
    static constexpr auto height = "int";
    static constexpr auto redBits = "int";
    static constexpr auto greenBits = "int";
    static constexpr auto blueBits = "int";
    static constexpr auto refreshRate = "int";
};
struct GLFWgammaramp_Reflection {
    static constexpr auto red = "unsigned short *";
    static constexpr auto green = "unsigned short *";
    static constexpr auto blue = "unsigned short *";
    static constexpr auto size = "unsigned int";
};
struct GLFWimage_Reflection {
    static constexpr auto width = "int";
    static constexpr auto height = "int";
    static constexpr auto pixels = "unsigned char *";
};
struct GLFWgamepadstate_Reflection {
    static constexpr auto buttons = "unsigned char[15]";
    static constexpr auto axes = "float[6]";
};
struct GLFWallocator_Reflection {
    static constexpr auto allocate = "GLFWallocatefun";
    static constexpr auto reallocate = "GLFWreallocatefun";
    static constexpr auto deallocate = "GLFWdeallocatefun";
    static constexpr auto user = "void *";
};
struct RenderContext_Reflection {
};
struct WindowsWindow_Reflection {
    static constexpr auto m_Window = "GLFWwindow *";
    static constexpr auto m_Context = "RenderContext *";
    static constexpr auto m_Data = "WindowData";
};
struct WindowData_Reflection {
    static constexpr auto Title = "int";
    static constexpr auto Width = "unsigned int";
    static constexpr auto Height = "unsigned int";
    static constexpr auto VSync = "_Bool";
    static constexpr auto EventCallBack = "EventCallBackFn";
};
struct fpos_Reflection {
    static constexpr auto __st_ = "_StateT";
    static constexpr auto __off_ = "streamoff";
};
struct enable_if_Reflection {
};
struct enable_if_Reflection {
};
struct integral_constant_Reflection {
};
struct remove_cv_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct __libcpp_is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct __equal_tag_Reflection {
};
struct __plus_tag_Reflection {
};
struct __totally_ordered_less_tag_Reflection {
};
struct __equal_to_Reflection {
};
struct __less_Reflection {
};
struct __less_Reflection {
};
struct __debug_less_Reflection {
    static constexpr auto __comp_ = "_Compare &";
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct __libcpp_is_floating_point_Reflection {
};
struct is_floating_point_Reflection {
};
struct is_arithmetic_Reflection {
};
struct is_signed_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_signed_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct __libcpp_is_unsigned_integer_Reflection {
};
struct is_convertible_Reflection {
};
struct is_function_Reflection {
};
struct is_reference_Reflection {
};
struct is_lvalue_reference_Reflection {
};
struct is_rvalue_reference_Reflection {
};
struct remove_all_extents_Reflection {
};
struct is_destructible_Reflection {
};
struct is_nothrow_destructible_Reflection {
};
struct is_same_Reflection {
};
struct __libcpp_is_referenceable_Reflection {
};
struct add_lvalue_reference_Reflection {
};
struct add_rvalue_reference_Reflection {
};
struct is_constructible_Reflection {
};
struct is_copy_constructible_Reflection {
};
struct is_move_constructible_Reflection {
};
struct is_default_constructible_Reflection {
};
struct _IfImpl_Reflection {
};
struct _IfImpl_Reflection {
};
struct conditional_Reflection {
};
struct conditional_Reflection {
};
struct is_void_Reflection {
};
struct remove_reference_Reflection {
};
struct add_pointer_Reflection {
};
struct is_array_Reflection {
};
struct remove_extent_Reflection {
};
struct decay_Reflection {
};
struct __type_identity_Reflection {
};
struct __empty_Reflection {
};
struct common_type_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cv_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct __copy_cvref_Reflection {
};
struct is_class_Reflection {
};
struct is_enum_Reflection {
};
struct is_union_Reflection {
};
struct extent_Reflection {
};
struct is_nothrow_assignable_Reflection {
};
struct is_nothrow_copy_assignable_Reflection {
};
struct is_nothrow_move_assignable_Reflection {
};
struct is_nothrow_constructible_Reflection {
};
struct is_nothrow_copy_constructible_Reflection {
};
struct is_nothrow_move_constructible_Reflection {
};
struct is_nothrow_default_constructible_Reflection {
};
struct is_assignable_Reflection {
};
struct is_copy_assignable_Reflection {
};
struct is_move_assignable_Reflection {
};
struct is_swappable_with_Reflection {
};
struct is_swappable_Reflection {
};
struct is_nothrow_swappable_with_Reflection {
};
struct is_nothrow_swappable_Reflection {
};
struct is_object_Reflection {
};
struct __nat_Reflection {
};
struct __type_list_Reflection {
};
struct __find_first_Reflection {
};
struct __find_first_Reflection {
};
struct make_signed_Reflection {
};
struct _OrImpl_Reflection {
};
struct _OrImpl_Reflection {
};
struct disjunction_Reflection {
};
struct remove_const_Reflection {
};
struct input_iterator_tag_Reflection {
};
struct output_iterator_tag_Reflection {
};
struct forward_iterator_tag_Reflection {
};
struct bidirectional_iterator_tag_Reflection {
};
struct random_access_iterator_tag_Reflection {
};
struct __iter_traits_cache_Reflection {
};
struct __iter_concept_concept_test_Reflection {
};
struct __iter_concept_category_test_Reflection {
};
struct __iter_concept_random_fallback_Reflection {
};
struct __test_iter_concept_Reflection {
};
struct __iter_concept_cache_Reflection {
};
struct __has_iterator_typedefs_Reflection {
};
struct __has_iterator_category_Reflection {
};
struct __has_iterator_concept_Reflection {
};
struct __iterator_traits_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_impl_Reflection {
};
struct __iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct iterator_traits_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_category_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __has_iterator_concept_convertible_to_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct __is_callable_Reflection {
};
struct initializer_list_Reflection {
    static constexpr auto __begin_ = "const _Ep *";
    static constexpr auto __size_ = "size_t";
};
struct __is_identity_Reflection {
};
struct __identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct __is_identity_Reflection {
};
struct is_base_of_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct __is_core_convertible_Reflection {
};
struct is_member_pointer_Reflection {
};
struct is_member_object_pointer_Reflection {
};
struct is_member_function_pointer_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_impl_Reflection {
};
struct __is_reference_wrapper_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __member_pointer_class_type_Reflection {
};
struct __invokable_r_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __nothrow_invokable_r_imp_Reflection {
};
struct __invoke_of_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct __invoke_void_return_wrapper_Reflection {
};
struct is_invocable_Reflection {
};
struct is_invocable_r_Reflection {
};
struct is_nothrow_invocable_Reflection {
};
struct is_nothrow_invocable_r_Reflection {
};
struct invoke_result_Reflection {
};
struct __has_specialization_Reflection {
};
struct __has_specialization_Reflection {
};
struct __all_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct conjunction_Reflection {
};
struct __has_pointer_Reflection {
};
struct __has_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __pointer_traits_element_type_Reflection {
};
struct __has_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __pointer_traits_difference_type_Reflection {
};
struct __has_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_rebind_Reflection {
};
struct __pointer_traits_impl_Reflection {
};
struct pointer_traits_Reflection {
};
struct pointer_traits_Reflection {
};
struct __nat_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasToAddress_Reflection {
};
struct _HasArrow_Reflection {
};
struct _HasArrow_Reflection {
};
struct _IsFancyPointer_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __to_address_helper_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __unwrap_iter_impl_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_compute_min_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct __libcpp_numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct numeric_limits_Reflection {
};
struct add_const_Reflection {
};
struct add_cv_Reflection {
};
struct add_volatile_Reflection {
};
struct __align_type_Reflection {
};
struct __struct_double_Reflection {
    static constexpr auto __lx = "long double";
};
struct __struct_double4_Reflection {
    static constexpr auto __lx = "double[4]";
};
struct __fallback_overaligned_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_pod_Reflection {
};
struct __find_max_align_Reflection {
};
struct __select_align_Reflection {
};
struct __find_max_align_Reflection {
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __align = "_Aligner";
    static constexpr auto __data = "unsigned char[(_Len + _Align - 1) / _Align * _Align]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1 - 1) / 1 * 1]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2 - 1) / 2 * 2]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4 - 1) / 4 * 4]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8 - 1) / 8 * 8]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 16 - 1) / 16 * 16]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 32 - 1) / 32 * 32]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 64 - 1) / 64 * 64]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 128 - 1) / 128 * 128]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 256 - 1) / 256 * 256]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 512 - 1) / 512 * 512]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 1024 - 1) / 1024 * 1024]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 2048 - 1) / 2048 * 2048]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 4096 - 1) / 4096 * 4096]";
};
struct aligned_storage_Reflection {
};
struct type_Reflection {
    static constexpr auto __lx = "unsigned char[(_Len + 8192 - 1) / 8192 * 8192]";
};
struct __static_max_Reflection {
};
struct __static_max_Reflection {
};
struct aligned_union_Reflection {
};
struct alignment_of_Reflection {
};
struct has_virtual_destructor_Reflection {
};
struct is_abstract_Reflection {
};
struct is_null_pointer_Reflection {
};
struct is_fundamental_Reflection {
};
struct is_compound_Reflection {
};
struct is_const_Reflection {
};
struct is_empty_Reflection {
};
struct is_literal_type_Reflection {
};
struct is_pod_Reflection {
};
struct is_pointer_Reflection {
};
struct is_polymorphic_Reflection {
};
struct is_scalar_Reflection {
};
struct is_standard_layout_Reflection {
};
struct is_trivial_Reflection {
};
struct is_trivially_assignable_Reflection {
};
struct is_trivially_copy_assignable_Reflection {
};
struct is_trivially_move_assignable_Reflection {
};
struct is_trivially_constructible_Reflection {
};
struct is_trivially_copy_constructible_Reflection {
};
struct is_trivially_move_constructible_Reflection {
};
struct is_trivially_default_constructible_Reflection {
};
struct is_trivially_copyable_Reflection {
};
struct is_trivially_destructible_Reflection {
};
struct is_unsigned_Reflection {
};
struct is_volatile_Reflection {
};
struct make_unsigned_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct rank_Reflection {
};
struct remove_pointer_Reflection {
};
struct remove_volatile_Reflection {
};
struct result_of_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct __underlying_type_impl_Reflection {
};
struct underlying_type_Reflection {
};
struct __libcpp_is_final_Reflection {
};
struct is_final_Reflection {
};
struct has_unique_object_representations_Reflection {
};
struct is_aggregate_Reflection {
};
struct _Not_Reflection {
};
struct negation_Reflection {
};
struct _FirstPaddingByte_Reflection {
    static constexpr auto __v_ = "_Tp";
    static constexpr auto __first_padding_byte_ = "char";
};
struct __is_always_bitcastable_Reflection {
};
struct __is_equality_comparable_Reflection {
};
struct __libcpp_is_trivially_equality_comparable_impl_Reflection {
};
struct __is_less_than_comparable_Reflection {
};
struct __find_segment_Reflection {
    static constexpr auto __value_ = "const _Tp &";
};
struct __unary_function_keep_layout_base_Reflection {
};
struct __integer_sequence_Reflection {
};
struct integer_sequence_Reflection {
};
struct __tuple_indices_Reflection {
};
struct __make_tuple_indices_Reflection {
};
struct __tuple_types_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_size_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_flat_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __make_tuple_types_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_like_ext_Reflection {
};
struct __tuple_sfinae_base_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct __tuple_constructible_Reflection {
};
struct tuple_element_Reflection {
};
struct __check_tuple_constructor_fail_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_ctor_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __sfinae_assign_base_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __is_implicitly_default_constructible_Reflection {
};
struct __libcpp_is_trivially_relocatable_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_reference_Reflection {
};
struct __unwrap_ref_decay_Reflection {
};
struct piecewise_construct_t_Reflection {
};
struct __non_trivially_copyable_base_Reflection {
};
struct pair_Reflection {
    static constexpr auto first = "_T1";
    static constexpr auto second = "_T2";
};
struct _CheckArgs_Reflection {
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct tuple_element_Reflection {
};
struct __get_pair_Reflection {
};
struct __get_pair_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __murmur2_or_cityhash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct __scalar_hash_Reflection {
};
struct _PairT_Reflection {
    static constexpr auto first = "size_t";
    static constexpr auto second = "size_t";
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct _Reflection {
    static constexpr auto __t = "long double";
    static constexpr auto __s = "struct (unnamed struct at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__functional\hash.h:476:7)";
};
struct _Reflection {
    static constexpr auto __a = "size_t";
    static constexpr auto __b = "size_t";
};
struct __enum_hash_Reflection {
};
struct __enum_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __bounded_iter_Reflection {
    static constexpr auto __current_ = "_Iterator";
    static constexpr auto __begin_ = "_Iterator";
    static constexpr auto __end_ = "_Iterator";
};
struct __sfinae_underlying_type_Reflection {
};
struct __sfinae_underlying_type_Reflection {
};
struct iterator_Reflection {
};
struct reverse_iterator_Reflection {
    static constexpr auto __t_ = "_Iter";
    static constexpr auto current = "_Iter";
};
struct __unwrap_iter_impl_Reflection {
};
struct __wrap_iter_Reflection {
    static constexpr auto __i_ = "iterator_type";
};
struct __libcpp_is_contiguous_iterator_Reflection {
};
struct pointer_traits_Reflection {
};
struct __pointer_Reflection {
};
struct __pointer_Reflection {
};
struct __has_const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __const_pointer_Reflection {
};
struct __has_void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __void_pointer_Reflection {
};
struct __has_const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __const_void_pointer_Reflection {
};
struct __has_size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __size_type_Reflection {
};
struct __has_alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __alloc_traits_difference_type_Reflection {
};
struct __has_propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __propagate_on_container_copy_assignment_Reflection {
};
struct __has_propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __propagate_on_container_move_assignment_Reflection {
};
struct __has_propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __propagate_on_container_swap_Reflection {
};
struct __has_is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __is_always_equal_Reflection {
};
struct __has_rebind_other_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __allocator_traits_rebind_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_allocate_hint_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_impl_Reflection {
};
struct __has_construct_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_destroy_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_max_size_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct __has_select_on_container_copy_construction_Reflection {
};
struct allocator_traits_Reflection {
};
struct __check_valid_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_default_allocator_Reflection {
};
struct __is_cpp17_move_insertable_Reflection {
};
struct __is_cpp17_copy_insertable_Reflection {
};
struct __allocation_result_Reflection {
    static constexpr auto ptr = "_Pointer";
    static constexpr auto count = "size_t";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct __non_trivial_if_Reflection {
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __noexcept_move_assign_container_Reflection {
};
struct memory_resource_Reflection {
};
struct __exception_guard_exceptions_Reflection {
    static constexpr auto __rollback_ = "_Rollback";
    static constexpr auto __completed_ = "_Bool";
};
struct __exception_guard_noexceptions_Reflection {
    static constexpr auto __completed_ = "_Bool";
};
struct __has_allocator_type_Reflection {
};
struct __uses_allocator_Reflection {
};
struct __uses_allocator_Reflection {
};
struct uses_allocator_Reflection {
};
struct allocator_arg_t_Reflection {
};
struct __uses_alloc_ctor_imp_Reflection {
};
struct __uses_alloc_ctor_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_checked_Reflection {
};
struct __find_exactly_one_t_Reflection {
};
struct __ignore_type_Reflection {
};
struct _Lazy_Reflection {
};
struct __promote_Reflection {
};
struct __tuple_leaf_Reflection {
    static constexpr auto __value_ = "_Hp";
};
struct __tuple_leaf_Reflection {
};
struct __all_default_constructible_Reflection {
};
struct __tuple_impl_Reflection {
};
struct tuple_Reflection {
    static constexpr auto __base_ = "_BaseT";
};
struct _IsThisTuple_Reflection {
};
struct _EnableUTypesCtor_Reflection {
};
struct _EnableCtorFromUTypesTuple_Reflection {
};
struct _CtorPredicateFromPair_Reflection {
};
struct _EnableCtorFromPair_Reflection {
};
struct _NothrowConstructibleFromPair_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _BothImplicitlyConvertible_Reflection {
};
struct _AssignPredicateFromPair_Reflection {
};
struct _EnableAssignFromPair_Reflection {
};
struct _NothrowAssignFromPair_Reflection {
};
struct tuple_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_equal_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_less_Reflection {
};
struct __tuple_cat_type_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_1_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_imp_Reflection {
};
struct __tuple_cat_return_ref_Reflection {
};
struct __tuple_cat_Reflection {
};
struct uses_allocator_Reflection {
};
struct bad_cast_Reflection {
};
struct bad_typeid_Reflection {
};
struct exception_ptr_Reflection {
    static constexpr auto __ptr1_ = "void *";
    static constexpr auto __ptr2_ = "void *";
};
struct nested_exception_Reflection {
    static constexpr auto __ptr_ = "exception_ptr";
};
struct __nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __throw_with_nested_Reflection {
};
struct __can_dynamic_cast_Reflection {
};
struct __save_flags_Reflection {
    static constexpr auto __stream_ = "__stream_type &";
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __fill_ = "_CharT";
};
struct in_place_t_Reflection {
};
struct in_place_type_t_Reflection {
};
struct in_place_index_t_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_type_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct __is_inplace_index_imp_Reflection {
};
struct polymorphic_allocator_Reflection {
    static constexpr auto __res_ = "memory_resource *";
};
struct _ClassicAlgPolicy_Reflection {
};
struct _IterOps_Reflection {
};
struct char_traits_Reflection {
};
struct __char_traits_base_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct char_traits_Reflection {
};
struct __is_allocator_Reflection {
};
struct logic_error_Reflection {
};
struct runtime_error_Reflection {
};
struct domain_error_Reflection {
};
struct invalid_argument_Reflection {
};
struct length_error_Reflection {
};
struct out_of_range_Reflection {
};
struct range_error_Reflection {
};
struct overflow_error_Reflection {
};
struct underflow_error_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto __data_ = "const value_type *";
    static constexpr auto __size_ = "size_type";
};
struct __assume_valid_Reflection {
};
struct __string_view_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __can_lower_copy_assignment_to_memmove_Reflection {
};
struct __can_lower_move_assignment_to_memmove_Reflection {
};
struct __can_rewrap_Reflection {
};
struct __copy_impl_Reflection {
};
struct _CopySegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __copy_backward_impl_Reflection {
};
struct nullopt_t_Reflection {
};
struct __secret_tag_Reflection {
};
struct __optional_construct_from_invoke_tag_Reflection {
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_destruct_base_Reflection {
    static constexpr auto __engaged_ = "_Bool";
};
struct _Reflection {
    static constexpr auto __null_state_ = "char";
    static constexpr auto __val_ = "int";
};
struct __optional_storage_base_Reflection {
};
struct __optional_storage_base_Reflection {
    static constexpr auto __value_ = "int *";
};
struct __optional_copy_base_Reflection {
};
struct __optional_copy_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_move_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_copy_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __optional_move_assign_base_Reflection {
};
struct __is_std_optional_Reflection {
};
struct __is_std_optional_Reflection {
};
struct optional_Reflection {
};
struct _CheckOptionalArgsConstructor_Reflection {
};
struct _CheckOptionalLikeConstructor_Reflection {
};
struct __cxx_atomic_base_impl_Reflection {
    static constexpr auto __a_value = "_Atomic(_Tp)";
};
struct __cxx_atomic_impl_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_gcd_Reflection {
};
struct __static_lcm_Reflection {
};
struct __static_abs_Reflection {
};
struct __static_sign_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_add_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_sub_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_mul_Reflection {
};
struct __ll_div_Reflection {
};
struct ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __is_ratio_Reflection {
};
struct __ratio_multiply_Reflection {
};
struct __ratio_divide_Reflection {
};
struct __ratio_add_Reflection {
};
struct __ratio_subtract_Reflection {
};
struct ratio_equal_Reflection {
};
struct ratio_not_equal_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less1_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct __ratio_less_Reflection {
};
struct ratio_less_Reflection {
};
struct ratio_less_equal_Reflection {
};
struct ratio_greater_Reflection {
};
struct ratio_greater_equal_Reflection {
};
struct __ratio_gcd_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct __is_duration_Reflection {
};
struct common_type_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct __duration_cast_Reflection {
};
struct treat_as_floating_point_Reflection {
};
struct duration_values_Reflection {
};
struct duration_Reflection {
    static constexpr auto __rep_ = "rep";
};
struct __no_overflow_Reflection {
};
struct __mul_Reflection {
};
struct __mul_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_eq_Reflection {
};
struct __duration_lt_Reflection {
};
struct __duration_lt_Reflection {
};
struct time_point_Reflection {
    static constexpr auto __d_ = "duration";
};
struct common_type_Reflection {
};
struct steady_clock_Reflection {
};
struct system_clock_Reflection {
};
struct __spinning_backoff_policy_Reflection {
};
struct __atomic_waitable_traits_Reflection {
};
struct __atomic_waitable_Reflection {
};
struct __atomic_wait_poll_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_wait_backoff_impl_Reflection {
    static constexpr auto __a_ = "const _AtomicWaitable &";
    static constexpr auto __poll_ = "_Poll";
    static constexpr auto __order_ = "memory_order";
};
struct __atomic_compare_unequal_to_Reflection {
    static constexpr auto __val_ = "_Tp";
};
struct __libcpp_is_always_lock_free_Reflection {
};
struct __atomic_base_Reflection {
    static constexpr auto __a_ = "int";
};
struct __atomic_base_Reflection {
};
struct __binary_function_keep_layout_base_Reflection {
};
struct plus_Reflection {
};
struct plus_Reflection {
};
struct minus_Reflection {
};
struct minus_Reflection {
};
struct multiplies_Reflection {
};
struct multiplies_Reflection {
};
struct divides_Reflection {
};
struct divides_Reflection {
};
struct modulus_Reflection {
};
struct modulus_Reflection {
};
struct negate_Reflection {
};
struct negate_Reflection {
};
struct bit_and_Reflection {
};
struct bit_and_Reflection {
};
struct bit_not_Reflection {
};
struct bit_not_Reflection {
};
struct bit_or_Reflection {
};
struct bit_or_Reflection {
};
struct bit_xor_Reflection {
};
struct bit_xor_Reflection {
};
struct equal_to_Reflection {
};
struct equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct not_equal_to_Reflection {
};
struct less_Reflection {
};
struct less_Reflection {
};
struct less_equal_Reflection {
};
struct less_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_equal_Reflection {
};
struct greater_Reflection {
};
struct greater_Reflection {
};
struct logical_and_Reflection {
};
struct logical_and_Reflection {
};
struct logical_not_Reflection {
};
struct logical_not_Reflection {
};
struct logical_or_Reflection {
};
struct logical_or_Reflection {
};
struct atomic_Reflection {
};
struct atomic_Reflection {
};
struct atomic_flag_Reflection {
    static constexpr auto __a_ = "int";
};
struct back_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct front_insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
};
struct insert_iterator_Reflection {
    static constexpr auto container = "_Container *";
    static constexpr auto iter = "int";
};
struct istream_iterator_Reflection {
    static constexpr auto __in_stream_ = "istream_type *";
    static constexpr auto __value_ = "_Tp";
};
struct istreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __proxy_Reflection {
    static constexpr auto __keep_ = "char_type";
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct move_iterator_Reflection {
    static constexpr auto __current_ = "_Iter";
};
struct ostream_iterator_Reflection {
    static constexpr auto __out_stream_ = "ostream_type *";
    static constexpr auto __delim_ = "const char_type *";
};
struct ostreambuf_iterator_Reflection {
    static constexpr auto __sbuf_ = "streambuf_type *";
};
struct __dependent_type_Reflection {
};
struct monostate_Reflection {
};
struct hash_Reflection {
};
struct __farray_Reflection {
    static constexpr auto __buf_ = "_Tp[_Size]";
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_size_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct variant_alternative_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_impl_Reflection {
};
struct __find_unambiguous_index_sfinae_Reflection {
};
struct __valueless_t_Reflection {
};
struct __traits_Reflection {
};
struct __union_Reflection {
};
struct __base_Reflection {
};
struct __variant_Reflection {
};
struct __base_Reflection {
};
struct __dispatcher_Reflection {
};
struct __variant_Reflection {
};
struct __value_visitor_Reflection {
    static constexpr auto __visitor = "_Visitor &&";
};
struct __alt_Reflection {
    static constexpr auto __value = "__value_type";
};
struct __union_Reflection {
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_TriviallyAvailable, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Available, _Index + 1, _Types...>";
};
struct __union_Reflection {
    static constexpr auto __dummy = "char";
    static constexpr auto __head = "__alt<_Index, _Tp>";
    static constexpr auto __tail = "__union<_Trait::_Unavailable, _Index + 1, _Types...>";
};
struct __base_Reflection {
    static constexpr auto __data = "__union<_DestructibleTrait, 0, _Types...>";
    static constexpr auto __index = "int";
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __dtor_Reflection {
};
struct __ctor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __move_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __copy_constructor_Reflection {
};
struct __assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __move_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __copy_assignment_Reflection {
};
struct __impl_Reflection {
};
struct __no_narrowing_check_Reflection {
};
struct __narrowing_check_Reflection {
};
struct __overload_Reflection {
};
struct __all_overloads_Reflection {
};
struct __make_overloads_imp_Reflection {
};
struct variant_Reflection {
    static constexpr auto __impl_ = "__variant_detail::__impl<_Types...>";
};
struct __convert_to_bool_Reflection {
};
struct __has_result_type_Reflection {
};
struct __derives_from_unary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __derives_from_binary_function_Reflection {
};
struct __two_Reflection {
    static constexpr auto __lx = "char";
    static constexpr auto __lxx = "char";
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_imp_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct __weak_result_type_Reflection {
};
struct reference_wrapper_Reflection {
    static constexpr auto __f_ = "type *";
};
struct __allocation_guard_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __n_ = "_Size";
    static constexpr auto __ptr_ = "_Pointer";
};
struct __allocator_destructor_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __s_ = "size_type";
};
struct __move_impl_Reflection {
};
struct _MoveSegment_Reflection {
    static constexpr auto __result_ = "_OutIter &";
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __libcpp_is_unbounded_array_Reflection {
};
struct __always_false_Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _AllocatorDestroyRangeReverse_Reflection {
    static constexpr auto __alloc_ = "_Alloc &";
    static constexpr auto __first_ = "_Iter &";
    static constexpr auto __last_ = "_Iter &";
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_copy_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_move_construct_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __allocator_has_trivial_destroy_Reflection {
};
struct __has_array_cookie_Reflection {
};
struct __private_constructor_tag_Reflection {
};
struct default_delete_Reflection {
};
struct default_delete_Reflection {
};
struct _EnableIfConvertible_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __is_default_deleter_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct __unique_ptr_deleter_sfinae_Reflection {
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
};
struct __unique_ptr_array_bounds_stateless_Reflection {
};
struct __unique_ptr_array_bounds_stored_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct unique_ptr_Reflection {
    static constexpr auto __ptr_ = "pointer";
    static constexpr auto __deleter_ = "deleter_type";
    static constexpr auto __checker_ = "_BoundsChecker";
};
struct _CheckArrayPointerConversion_Reflection {
};
struct _CheckArrayPointerConversion_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __unique_if_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct __libcpp_is_bounded_array_Reflection {
};
struct bad_weak_ptr_Reflection {
};
struct __shared_count_Reflection {
    static constexpr auto __shared_owners_ = "long";
};
struct __shared_weak_count_Reflection {
    static constexpr auto __shared_weak_owners_ = "long";
};
struct __shared_ptr_pointer_Reflection {
    static constexpr auto __ptr_ = "_Tp";
    static constexpr auto __deleter_ = "_Dp";
    static constexpr auto __alloc_ = "_Alloc";
};
struct __for_overwrite_tag_Reflection {
};
struct __shared_ptr_emplace_Reflection {
    static constexpr auto __storage_ = "_Storage";
};
struct _Storage_Reflection {
    static constexpr auto __buffer_ = "char[sizeof(_Data)]";
};
struct _Data_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __elem_ = "int";
};
struct allocator_Reflection {
};
struct rebind_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __bounded_convertible_to_unbounded_Reflection {
};
struct __compatible_with_Reflection {
};
struct __raw_pointer_compatible_with_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __is_array_deletable_Reflection {
};
struct __well_formed_deleter_Reflection {
};
struct __shared_ptr_deleter_ctor_reqs_Reflection {
};
struct shared_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct __nullptr_sfinae_tag_Reflection {
};
struct __shared_ptr_default_allocator_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __shared_ptr_default_delete_Reflection {
};
struct __sp_aligned_storage_Reflection {
    static constexpr auto __storage = "char[_Alignment]";
};
struct __unbounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto __count_ = "size_t";
    static constexpr auto  = "union std::__unbounded_array_control_block<type-parameter-0-0[], type-parameter-0-1>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:952:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct __bounded_array_control_block_Reflection {
    static constexpr auto __alloc_ = "_Alloc";
    static constexpr auto  = "union std::__bounded_array_control_block<type-parameter-0-0[_Np], type-parameter-0-2>::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\shared_ptr.h:1030:3)";
};
struct _Reflection {
    static constexpr auto __data_ = "_Tp[_Count]";
};
struct weak_ptr_Reflection {
    static constexpr auto __ptr_ = "element_type *";
    static constexpr auto __cntrl_ = "__shared_weak_count *";
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct owner_less_Reflection {
};
struct enable_shared_from_this_Reflection {
    static constexpr auto __weak_this_ = "weak_ptr<_Tp>";
};
struct hash_Reflection {
};
struct __sp_mut_Reflection {
    static constexpr auto __lx_ = "void *";
};
struct raw_storage_iterator_Reflection {
    static constexpr auto __x_ = "_OutputIterator";
};
struct __temporary_buffer_deleter_Reflection {
    static constexpr auto __count_ = "ptrdiff_t";
};
struct __move_backward_impl_Reflection {
};
struct __destruct_n_Reflection {
    static constexpr auto __size_ = "size_t";
};
struct __invert_Reflection {
    static constexpr auto __p_ = "_Predicate";
};
struct _ConstTimeDistance_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct __get_as_integer_type_impl_Reflection {
};
struct _Reflection {
};
struct __aliasing_iterator_wrapper_Reflection {
};
struct __iterator_Reflection {
    static constexpr auto __base_ = "_BaseIter";
};
struct _MinmaxElementLessFunc_Reflection {
    static constexpr auto __comp_ = "_Comp &";
    static constexpr auto __proj_ = "_Proj &";
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct __is_simple_comparator_Reflection {
};
struct _ProjectedPred_Reflection {
    static constexpr auto __pred = "_Pred &";
    static constexpr auto __proj = "_Proj &";
};
struct __set_intersection_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_symmetric_difference_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __set_union_result_Reflection {
    static constexpr auto __in1_ = "_InIter1";
    static constexpr auto __in2_ = "_InIter2";
    static constexpr auto __out_ = "_OutIter";
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_realtype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_inttype_Reflection {
};
struct __libcpp_random_is_valid_urng_Reflection {
};
struct __log2_Reflection {
};
struct __independent_bits_engine_Reflection {
    static constexpr auto __e_ = "_Engine &";
    static constexpr auto __w_ = "size_t";
    static constexpr auto __w0_ = "size_t";
    static constexpr auto __n_ = "size_t";
    static constexpr auto __n0_ = "size_t";
    static constexpr auto __y0_ = "_Working_result_type";
    static constexpr auto __y1_ = "_Working_result_type";
    static constexpr auto __mask0_ = "_Engine_result_type";
    static constexpr auto __mask1_ = "_Engine_result_type";
};
struct uniform_int_distribution_Reflection {
    static constexpr auto __p_ = "param_type";
};
struct param_type_Reflection {
    static constexpr auto __a_ = "result_type";
    static constexpr auto __b_ = "result_type";
};
struct __libcpp_debug_randomizer_Reflection {
    static constexpr auto __state_ = "int";
    static constexpr auto __inc_ = "int";
};
struct __stable_sort_switch_Reflection {
};
struct __reread_from_input_tag_Reflection {
};
struct __reread_from_output_tag_Reflection {
};
struct __read_from_tmp_value_tag_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __string_is_trivial_iterator_Reflection {
};
struct __can_be_converted_to_string_view_Reflection {
};
struct __uninitialized_size_tag_Reflection {
};
struct __init_with_sentinel_tag_Reflection {
};
struct __padding_Reflection {
    static constexpr auto __padding_ = "char[_PaddingSize]";
};
struct __padding_Reflection {
};
struct basic_string_Reflection {
    static constexpr auto __rep_ = "__rep";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __long_Reflection {
    static constexpr auto  = "struct std::basic_string::__long::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:902:5)";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __data_ = "pointer";
};
struct _Reflection {
    static constexpr auto __is_long_ = "size_type";
    static constexpr auto __cap_ = "size_type";
};
struct __short_Reflection {
    static constexpr auto  = "struct std::basic_string::__short::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\string:913:5)";
    static constexpr auto __padding_ = "__padding<sizeof(value_type) - 1>";
    static constexpr auto __data_ = "value_type[__min_cap]";
};
struct _Reflection {
    static constexpr auto __is_long_ = "unsigned char";
    static constexpr auto __size_ = "unsigned char";
};
struct __rep_Reflection {
    static constexpr auto __s = "__short";
    static constexpr auto __l = "__long";
};
struct __string_hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct hash_Reflection {
};
struct __lconv_storage_Reflection {
    static constexpr auto __lc_ = "int";
    static constexpr auto __decimal_point_ = "int";
    static constexpr auto __thousands_sep_ = "int";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __int_curr_symbol_ = "int";
    static constexpr auto __currency_symbol_ = "int";
    static constexpr auto __mon_decimal_point_ = "int";
    static constexpr auto __mon_thousands_sep_ = "int";
    static constexpr auto __mon_grouping_ = "int";
    static constexpr auto __positive_sign_ = "int";
    static constexpr auto __negative_sign_ = "int";
};
struct locale_t_Reflection {
    static constexpr auto __locale_str_ = "const char *";
    static constexpr auto __lc_ = "__lconv_storage *";
};
struct once_flag_Reflection {
    static constexpr auto __state_ = "_State_type";
};
struct __call_once_param_Reflection {
    static constexpr auto __f_ = "_Fp &";
};
struct __uninitialized_tag_Reflection {
};
struct __no_destroy_Reflection {
    static constexpr auto __obj_ = "char[sizeof(_Tp)]";
};
struct locale_Reflection {
    static constexpr auto __locale_ = "__imp *";
};
struct facet_Reflection {
};
struct id_Reflection {
    static constexpr auto __flag_ = "once_flag";
    static constexpr auto __id_ = "int";
};
struct collate_Reflection {
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct collate_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_base_Reflection {
};
struct ctype_Reflection {
};
struct ctype_Reflection {
    static constexpr auto __tab_ = "const mask *";
    static constexpr auto __del_ = "_Bool";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct ctype_byname_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_base_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
    static constexpr auto __l_ = "locale_t";
};
struct codecvt_Reflection {
};
struct codecvt_Reflection {
};
struct codecvt_byname_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __narrow_to_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct __widen_from_utf8_Reflection {
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
};
struct numpunct_byname_Reflection {
};
struct numpunct_byname_Reflection {
};
struct error_category_Reflection {
};
struct __do_message_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct is_error_condition_enum_Reflection {
};
struct error_condition_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct is_error_code_enum_Reflection {
};
struct error_code_Reflection {
    static constexpr auto __val_ = "int";
    static constexpr auto __cat_ = "const error_category *";
};
struct hash_Reflection {
};
struct system_error_Reflection {
    static constexpr auto __ec_ = "error_code";
};
struct ios_base_Reflection {
    static constexpr auto __fmtflags_ = "fmtflags";
    static constexpr auto __precision_ = "streamsize";
    static constexpr auto __width_ = "streamsize";
    static constexpr auto __rdstate_ = "iostate";
    static constexpr auto __exceptions_ = "iostate";
    static constexpr auto __rdbuf_ = "void *";
    static constexpr auto __loc_ = "void *";
    static constexpr auto __fn_ = "event_callback *";
    static constexpr auto __index_ = "int *";
    static constexpr auto __event_size_ = "size_t";
    static constexpr auto __event_cap_ = "size_t";
    static constexpr auto __iarray_ = "long *";
    static constexpr auto __iarray_size_ = "size_t";
    static constexpr auto __iarray_cap_ = "size_t";
    static constexpr auto __parray_ = "void **";
    static constexpr auto __parray_size_ = "size_t";
    static constexpr auto __parray_cap_ = "size_t";
};
struct is_error_code_enum_Reflection {
};
struct failure_Reflection {
};
struct Init_Reflection {
};
struct _FillHelper_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
    static constexpr auto __set_ = "_Bool";
};
struct _SentinelValueFill_Reflection {
    static constexpr auto __fill_val_ = "typename _Traits::int_type";
};
struct basic_ios_Reflection {
    static constexpr auto __tie_ = "basic_ostream<char_type, traits_type> *";
    static constexpr auto __fill_ = "_FillType";
};
struct mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_mutex_t";
};
struct defer_lock_t_Reflection {
};
struct try_to_lock_t_Reflection {
};
struct adopt_lock_t_Reflection {
};
struct unique_lock_Reflection {
    static constexpr auto __m_ = "mutex_type *";
    static constexpr auto __owns_ = "_Bool";
};
struct condition_variable_Reflection {
    static constexpr auto __cv_ = "__libcpp_condvar_t";
};
struct lock_guard_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct __thread_id_Reflection {
    static constexpr auto __id_ = "__libcpp_thread_id";
};
struct recursive_mutex_Reflection {
    static constexpr auto __m_ = "__libcpp_recursive_mutex_t";
};
struct timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __locked_ = "_Bool";
};
struct recursive_timed_mutex_Reflection {
    static constexpr auto __m_ = "mutex";
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __count_ = "size_t";
    static constexpr auto __id_ = "__thread_id";
};
struct scoped_lock_Reflection {
};
struct scoped_lock_Reflection {
    static constexpr auto __m_ = "mutex_type &";
};
struct scoped_lock_Reflection {
    static constexpr auto __t_ = "_MutexTuple";
};
struct __has_storage_type_Reflection {
};
struct __bit_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_reference_Reflection {
};
struct __bit_const_reference_Reflection {
    static constexpr auto __seg_ = "__storage_pointer";
    static constexpr auto __mask_ = "__storage_type";
};
struct __bit_array_Reflection {
    static constexpr auto __size_ = "difference_type";
    static constexpr auto __word_ = "__storage_type[4]";
};
struct __bit_iterator_Reflection {
    static constexpr auto __seg_ = "int";
    static constexpr auto __ctz_ = "unsigned int";
};
struct __has_storage_type_Reflection {
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type[_N_words]";
};
struct __bitset_Reflection {
    static constexpr auto __first_ = "__storage_type";
};
struct __bitset_Reflection {
};
struct bitset_Reflection {
};
struct hash_Reflection {
};
struct basic_streambuf_Reflection {
    static constexpr auto __loc_ = "locale";
    static constexpr auto __binp_ = "char_type *";
    static constexpr auto __ninp_ = "char_type *";
    static constexpr auto __einp_ = "char_type *";
    static constexpr auto __bout_ = "char_type *";
    static constexpr auto __nout_ = "char_type *";
    static constexpr auto __eout_ = "char_type *";
};
struct __num_get_base_Reflection {
};
struct __num_get_Reflection {
};
struct num_get_Reflection {
};
struct __num_put_base_Reflection {
};
struct __num_put_Reflection {
};
struct num_put_Reflection {
};
struct time_base_Reflection {
};
struct __time_get_c_storage_Reflection {
};
struct time_get_Reflection {
};
struct __time_get_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct __time_get_storage_Reflection {
    static constexpr auto __weeks_ = "string_type[14]";
    static constexpr auto __months_ = "string_type[24]";
    static constexpr auto __am_pm_ = "string_type[2]";
    static constexpr auto __c_ = "string_type";
    static constexpr auto __r_ = "string_type";
    static constexpr auto __x_ = "string_type";
    static constexpr auto __X_ = "string_type";
};
struct time_get_byname_Reflection {
};
struct __time_put_Reflection {
    static constexpr auto __loc_ = "locale_t";
};
struct time_put_Reflection {
};
struct time_put_byname_Reflection {
};
struct money_base_Reflection {
};
struct pattern_Reflection {
    static constexpr auto field = "char[4]";
};
struct moneypunct_Reflection {
};
struct moneypunct_byname_Reflection {
    static constexpr auto __decimal_point_ = "char_type";
    static constexpr auto __thousands_sep_ = "char_type";
    static constexpr auto __grouping_ = "int";
    static constexpr auto __curr_symbol_ = "string_type";
    static constexpr auto __positive_sign_ = "string_type";
    static constexpr auto __negative_sign_ = "string_type";
    static constexpr auto __frac_digits_ = "int";
    static constexpr auto __pos_format_ = "pattern";
    static constexpr auto __neg_format_ = "pattern";
};
struct __money_get_Reflection {
};
struct money_get_Reflection {
};
struct __money_put_Reflection {
};
struct money_put_Reflection {
};
struct messages_base_Reflection {
};
struct messages_Reflection {
};
struct messages_byname_Reflection {
};
struct wstring_convert_Reflection {
    static constexpr auto __byte_err_string_ = "byte_string";
    static constexpr auto __wide_err_string_ = "wide_string";
    static constexpr auto __cvtptr_ = "_Codecvt *";
    static constexpr auto __cvtstate_ = "state_type";
    static constexpr auto __cvtcount_ = "size_t";
};
struct wbuffer_convert_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __bufptr_ = "int *";
    static constexpr auto __cv_ = "_Codecvt *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ostream_Reflection {
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
    static constexpr auto __os_ = "basic_ostream<_CharT, _Traits> &";
};
struct __is_ostreamable_Reflection {
};
struct __is_ostreamable_Reflection {
};
struct basic_istream_Reflection {
    static constexpr auto __gc_ = "streamsize";
};
struct sentry_Reflection {
    static constexpr auto __ok_ = "_Bool";
};
struct __is_istreamable_Reflection {
};
struct __is_istreamable_Reflection {
};
struct basic_iostream_Reflection {
};
struct array_Reflection {
    static constexpr auto __elems_ = "_Tp[_Size]";
};
struct array_Reflection {
    static constexpr auto __elems_ = "int[sizeof(_ArrayInStructT)]";
};
struct _ArrayInStructT_Reflection {
    static constexpr auto __data_ = "_Tp[1]";
};
struct tuple_size_Reflection {
};
struct tuple_element_Reflection {
};
struct __temp_value_Reflection {
    static constexpr auto  = "union std::__temp_value::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__memory\temp_value.h:31:3)";
    static constexpr auto __a = "_Alloc &";
};
struct _Reflection {
    static constexpr auto __v = "_Tp";
};
struct __split_buffer_Reflection {
    static constexpr auto __first_ = "int";
    static constexpr auto __begin_ = "int";
    static constexpr auto __end_ = "int";
    static constexpr auto __end_cap_ = "int";
    static constexpr auto __alloc_ = "allocator_type";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "const int";
    static constexpr auto __dest_ = "int *";
};
struct __container_traits_Reflection {
};
struct __deque_block_size_Reflection {
};
struct __deque_iterator_Reflection {
    static constexpr auto __m_iter_ = "__map_iterator";
    static constexpr auto __ptr_ = "pointer";
};
struct deque_Reflection {
    static constexpr auto __map_ = "int";
    static constexpr auto __start_ = "size_type";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __deque_block_range_Reflection {
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __end_ = "const pointer";
};
struct __deque_range_Reflection {
    static constexpr auto __pos_ = "int";
    static constexpr auto __end_ = "int";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __end_ = "const pointer";
    static constexpr auto __begin_ = "const pointer";
    static constexpr auto __base_ = "deque<_Tp, _Allocator> *const";
};
struct __container_traits_Reflection {
};
struct binary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct is_bind_expression_Reflection {
};
struct is_placeholder_Reflection {
};
struct __ph_Reflection {
};
struct is_placeholder_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return2_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_invokable_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_impl_Reflection {
};
struct __mu_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __is_valid_bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_return_Reflection {
};
struct __bind_Reflection {
    static constexpr auto __f_ = "int";
    static constexpr auto __bound_args_ = "_Td";
};
struct is_bind_expression_Reflection {
};
struct __bind_r_Reflection {
};
struct is_bind_expression_Reflection {
};
struct __mem_fn_Reflection {
    static constexpr auto __f_ = "type";
};
struct unary_negate_Reflection {
    static constexpr auto __pred_ = "_Predicate";
};
struct __builtin_new_allocator_Reflection {
};
struct __builtin_new_deleter_Reflection {
    static constexpr auto __size_ = "size_t";
    static constexpr auto __align_ = "size_t";
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct __strip_signature_Reflection {
};
struct bad_function_call_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_unary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __maybe_derive_from_binary_function_Reflection {
};
struct __alloc_func_Reflection {
    static constexpr auto __func_ = "_Fp";
    static constexpr auto __alloc_ = "_Ap";
};
struct __default_alloc_func_Reflection {
    static constexpr auto __f_ = "_Fp";
};
struct __base_Reflection {
};
struct __func_Reflection {
    static constexpr auto __f_ = "__alloc_func<_Fp, _Alloc, _Rp (_ArgTypes...)>";
};
struct __value_func_Reflection {
    static constexpr auto __buf_ = "int";
    static constexpr auto __f_ = "__func *";
};
struct __policy_storage_Reflection {
    static constexpr auto __small = "char[16]";
    static constexpr auto __large = "void *";
};
struct __use_small_storage_Reflection {
};
struct __policy_Reflection {
    static constexpr auto __clone = "void *(*const)(const void *)";
    static constexpr auto __destroy = "void (*const)(void *)";
    static constexpr auto __is_null = "const _Bool";
    static constexpr auto __type_info = "const int *const";
};
struct __policy_invoker_Reflection {
    static constexpr auto __call_ = "__Call";
};
struct __policy_func_Reflection {
    static constexpr auto __buf_ = "__policy_storage";
    static constexpr auto __invoker_ = "__invoker";
    static constexpr auto __policy_ = "const __policy *";
};
struct function_Reflection {
    static constexpr auto __f_ = "__func";
};
struct __callable_Reflection {
};
struct __extract_key_fail_tag_Reflection {
};
struct __extract_key_self_tag_Reflection {
};
struct __extract_key_first_tag_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __can_extract_map_key_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_imp_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __is_hash_value_type_Reflection {
};
struct __hash_node_base_Reflection {
    static constexpr auto __next_ = "__next_pointer";
};
struct __hash_node_Reflection {
    static constexpr auto __hash_ = "size_t";
    static constexpr auto  = "union std::__hash_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\__hash_table:124:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __hash_key_value_types_Reflection {
};
struct __hash_key_value_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_map_pointer_types_Reflection {
};
struct __hash_node_types_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __hash_node_types_from_iterator_Reflection {
};
struct __make_hash_node_types_Reflection {
};
struct __hash_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_const_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
};
struct __hash_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __hash_const_local_iterator_Reflection {
    static constexpr auto __node_ = "__next_pointer";
    static constexpr auto __bucket_ = "size_t";
    static constexpr auto __bucket_count_ = "size_t";
};
struct __bucket_list_deallocator_Reflection {
    static constexpr auto __size_ = "size_type";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __hash_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __enforce_unordered_container_requirements_Reflection {
};
struct __hash_table_Reflection {
    static constexpr auto __bucket_list_ = "__bucket_list";
    static constexpr auto __first_node_ = "__first_node";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __hasher_ = "hasher";
    static constexpr auto __max_load_factor_ = "float";
    static constexpr auto __key_eq_ = "key_equal";
};
struct __basic_node_handle_Reflection {
    static constexpr auto __ptr_ = "__node_pointer_type";
    static constexpr auto __alloc_ = "optional<allocator_type>";
};
struct __set_node_handle_specifics_Reflection {
};
struct __map_node_handle_specifics_Reflection {
};
struct __insert_return_type_Reflection {
    static constexpr auto position = "_Iterator";
    static constexpr auto inserted = "_Bool";
    static constexpr auto node = "_NodeType";
};
struct __unordered_map_hasher_Reflection {
};
struct __unordered_map_hasher_Reflection {
    static constexpr auto __hash_ = "_Hash";
};
struct __unordered_map_equal_Reflection {
};
struct __unordered_map_equal_Reflection {
    static constexpr auto __pred_ = "_Pred";
};
struct __hash_map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __hash_value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __hash_map_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct __hash_map_const_iterator_Reflection {
    static constexpr auto __i_ = "_HashIterator";
};
struct unordered_map_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multimap_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct to_chars_result_Reflection {
    static constexpr auto ptr = "char *";
    static constexpr auto ec = "errc";
};
struct __traits_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct __integral_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "pointer";
    static constexpr auto __end_ = "pointer";
    static constexpr auto __cap_ = "pointer";
    static constexpr auto __alloc_ = "allocator_type";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Tp, _Alloc> &";
};
struct _ConstructTransaction_Reflection {
    static constexpr auto __v_ = "vector<_Tp, _Alloc> &";
    static constexpr auto __pos_ = "pointer";
    static constexpr auto __new_end_ = "const const_pointer";
};
struct __has_storage_type_Reflection {
};
struct vector_Reflection {
    static constexpr auto __begin_ = "__storage_pointer";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __cap_ = "size_type";
    static constexpr auto __alloc_ = "__storage_allocator";
};
struct __destroy_vector_Reflection {
    static constexpr auto __vec_ = "vector<_Bool, type-parameter-0-0> &";
};
struct hash_Reflection {
};
struct __container_traits_Reflection {
};
struct _BMSkipTable_Reflection {
    static constexpr auto __default_value_ = "const value_type";
    static constexpr auto __table_ = "int";
};
struct _BMSkipTable_Reflection {
    static constexpr auto __table_ = "std::array<value_type, 256>";
};
struct boyer_moore_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
    static constexpr auto __suffix_ = "shared_ptr<difference_type[]>";
};
struct boyer_moore_horspool_searcher_Reflection {
    static constexpr auto __first_ = "_RandomAccessIterator1";
    static constexpr auto __last_ = "_RandomAccessIterator1";
    static constexpr auto __pred_ = "_BinaryPredicate";
    static constexpr auto __pattern_length_ = "difference_type";
    static constexpr auto __skip_table_ = "int";
};
struct default_searcher_Reflection {
    static constexpr auto __first_ = "_ForwardIterator";
    static constexpr auto __last_ = "_ForwardIterator";
    static constexpr auto __pred_ = "_BinaryPredicate";
};
struct __not_fn_op_Reflection {
};
struct __not_fn_t_Reflection {
};
struct queue_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct priority_queue_Reflection {
    static constexpr auto c = "container_type";
    static constexpr auto comp = "value_compare";
};
struct uses_allocator_Reflection {
};
struct stack_Reflection {
    static constexpr auto c = "container_type";
};
struct uses_allocator_Reflection {
};
struct _FilesystemClock_Reflection {
};
struct __forward_list_node_value_type_Reflection {
};
struct __forward_node_traits_Reflection {
};
struct __forward_begin_node_Reflection {
    static constexpr auto __next_ = "pointer";
};
struct __forward_list_node_Reflection {
    static constexpr auto  = "union std::__forward_list_node::(anonymous at C:\Users\LucasvanDam\OneDrive - ComPartners\Documenten\clang tests\llvm-project\libcxx\include\forward_list:328:3)";
};
struct _Reflection {
    static constexpr auto __value_ = "_Tp";
};
struct __forward_list_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__begin_node_pointer";
};
struct __forward_list_base_Reflection {
    static constexpr auto __before_begin_ = "__begin_node";
    static constexpr auto __alloc_ = "__node_allocator";
};
struct forward_list_Reflection {
};
struct __container_traits_Reflection {
};
struct basic_stringbuf_Reflection {
    static constexpr auto __str_ = "string_type";
    static constexpr auto __hm_ = "char_type *";
    static constexpr auto __mode_ = "class ios_base::openmode";
};
struct basic_istringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_ostringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct basic_stringstream_Reflection {
    static constexpr auto __sb_ = "basic_stringbuf<char_type, traits_type, allocator_type>";
};
struct unordered_set_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct unordered_multiset_Reflection {
    static constexpr auto __table_ = "__table";
};
struct __container_traits_Reflection {
};
struct null_mutex_Reflection {
};
struct null_atomic_int_Reflection {
    static constexpr auto value = "int";
};
struct type_identity_Reflection {
};
struct is_contiguous_Reflection {
};
struct monostate_Reflection {
};
struct basic_string_view_Reflection {
    static constexpr auto data_ = "const Char *";
    static constexpr auto size_ = "size_t";
};
struct is_char_Reflection {
};
struct is_char_Reflection {
};
struct compile_string_Reflection {
};
struct is_compile_string_Reflection {
};
struct is_string_Reflection {
};
struct char_t_impl_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct type_constant_Reflection {
};
struct error_handler_Reflection {
};
struct basic_format_parse_context_Reflection {
    static constexpr auto format_str_ = "basic_string_view<Char>";
    static constexpr auto next_arg_id_ = "int";
};
struct compile_parse_context_Reflection {
    static constexpr auto num_args_ = "int";
    static constexpr auto types_ = "const type *";
};
struct buffer_Reflection {
    static constexpr auto ptr_ = "T *";
    static constexpr auto size_ = "size_t";
    static constexpr auto capacity_ = "size_t";
};
struct buffer_traits_Reflection {
};
struct fixed_buffer_traits_Reflection {
    static constexpr auto count_ = "size_t";
    static constexpr auto limit_ = "size_t";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto data_ = "T[buffer_size]";
};
struct iterator_buffer_Reflection {
    static constexpr auto out_ = "T *";
    static constexpr auto data_ = "T[buffer_size]";
};
struct counting_buffer_Reflection {
    static constexpr auto data_ = "T[buffer_size]";
    static constexpr auto count_ = "size_t";
};
struct formatter_Reflection {
};
struct appender_Reflection {
};
struct view_Reflection {
};
struct named_arg_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto value = "const T &";
};
struct named_arg_info_Reflection {
    static constexpr auto name = "const Char *";
    static constexpr auto id = "int";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)]";
    static constexpr auto named_args_ = "named_arg_info<Char>[NUM_NAMED_ARGS]";
};
struct arg_data_Reflection {
    static constexpr auto args_ = "T[NUM_ARGS != 0 ? NUM_ARGS : +1]";
};
struct is_named_arg_Reflection {
};
struct is_statically_named_arg_Reflection {
};
struct is_named_arg_Reflection {
};
struct unformattable_Reflection {
};
struct unformattable_char_Reflection {
};
struct unformattable_pointer_Reflection {
};
struct string_value_Reflection {
    static constexpr auto data = "const Char *";
    static constexpr auto size = "size_t";
};
struct named_arg_value_Reflection {
    static constexpr auto data = "const named_arg_info<Char> *";
    static constexpr auto size = "size_t";
};
struct custom_value_Reflection {
    static constexpr auto value = "void *";
    static constexpr auto format = "void (*)(void *, parse_context &, Context &)";
};
struct value_Reflection {
    static constexpr auto  = "union fmt::detail::value::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1261:3)";
};
struct _Reflection {
    static constexpr auto no_value = "monostate";
    static constexpr auto int_value = "int";
    static constexpr auto uint_value = "unsigned int";
    static constexpr auto long_long_value = "long long";
    static constexpr auto ulong_long_value = "unsigned long long";
    static constexpr auto int128_value = "int128_opt";
    static constexpr auto uint128_value = "uint128_opt";
    static constexpr auto bool_value = "_Bool";
    static constexpr auto char_value = "char_type";
    static constexpr auto float_value = "float";
    static constexpr auto double_value = "double";
    static constexpr auto long_double_value = "long double";
    static constexpr auto pointer = "const void *";
    static constexpr auto string = "string_value<char_type>";
    static constexpr auto custom = "custom_value<Context>";
    static constexpr auto named_args = "named_arg_value<char_type>";
};
struct format_as_result_Reflection {
};
struct has_format_as_Reflection {
};
struct arg_mapper_Reflection {
};
struct formattable_Reflection {
};
struct is_output_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct is_back_insert_iterator_Reflection {
};
struct locale_ref_Reflection {
    static constexpr auto locale_ = "const void *";
};
struct basic_format_arg_Reflection {
    static constexpr auto value_ = "detail::value<Context>";
    static constexpr auto type_ = "detail::type";
};
struct handle_Reflection {
    static constexpr auto custom_ = "detail::custom_value<Context>";
};
struct basic_format_context_Reflection {
    static constexpr auto out_ = "OutputIt";
    static constexpr auto args_ = "basic_format_args<basic_format_context<OutputIt, Char> >";
    static constexpr auto loc_ = "detail::locale_ref";
};
struct format_arg_store_Reflection {
    static constexpr auto data_ = "int";
};
struct basic_format_args_Reflection {
    static constexpr auto desc_ = "unsigned long long";
    static constexpr auto  = "union fmt::basic_format_args::(anonymous at vendor/spdlog/include/spdlog/fmt/bundled/core.h:1902:3)";
};
struct _Reflection {
    static constexpr auto values_ = "const detail::value<Context> *";
    static constexpr auto args_ = "const format_arg *";
};
struct fill_t_Reflection {
    static constexpr auto data_ = "Char[max_size]";
    static constexpr auto size_ = "unsigned char";
};
struct format_specs_Reflection {
    static constexpr auto width = "int";
    static constexpr auto precision = "int";
    static constexpr auto type = "presentation_type";
    static constexpr auto align = "align_t";
    static constexpr auto sign = "sign_t";
    static constexpr auto alt = "_Bool";
    static constexpr auto localized = "_Bool";
    static constexpr auto fill = "detail::fill_t<Char>";
};
struct arg_ref_Reflection {
    static constexpr auto kind = "arg_id_kind";
    static constexpr auto val = "union value";
};
struct value_Reflection {
    static constexpr auto index = "int";
    static constexpr auto name = "basic_string_view<Char>";
};
struct dynamic_format_specs_Reflection {
    static constexpr auto width_ref = "arg_ref<Char>";
    static constexpr auto precision_ref = "arg_ref<Char>";
};
struct dynamic_spec_id_handler_Reflection {
    static constexpr auto ctx = "basic_format_parse_context<Char> &";
    static constexpr auto ref = "arg_ref<Char> &";
};
struct _Reflection {
    static constexpr auto current_state = "state";
};
struct _Reflection {
    static constexpr auto begin = "const Char *&";
    static constexpr auto specs = "dynamic_format_specs<Char> &";
    static constexpr auto arg_type = "type";
};
struct id_adapter_Reflection {
    static constexpr auto handler = "Handler &";
    static constexpr auto arg_id = "int";
};
struct writer_Reflection {
    static constexpr auto handler_ = "Handler &";
};
struct strip_named_arg_Reflection {
};
struct strip_named_arg_Reflection {
};
struct format_string_checker_Reflection {
    static constexpr auto types_ = "type[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
    static constexpr auto context_ = "parse_context_type";
    static constexpr auto parse_funcs_ = "parse_func[num_args > 0 ? static_cast<size_t>(num_args) : 1]";
};
struct vformat_args_Reflection {
};
struct vformat_args_Reflection {
};
struct runtime_format_string_Reflection {
    static constexpr auto str = "basic_string_view<Char>";
};
struct basic_format_string_Reflection {
    static constexpr auto str_ = "basic_string_view<Char>";
};
struct format_to_n_result_Reflection {
    static constexpr auto out = "OutputIt";
    static constexpr auto size = "size_t";
};
struct __uintr_frame_Reflection {
    static constexpr auto rip = "unsigned long long";
    static constexpr auto rflags = "unsigned long long";
    static constexpr auto rsp = "unsigned long long";
};
struct __mm_loadh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadh_pi_v2f32";
};
struct __mm_loadl_pi_struct_Reflection {
    static constexpr auto __u = "__mm_loadl_pi_v2f32";
};
struct __mm_load_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __mm_load1_ps_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_storeh_pi_struct_Reflection {
    static constexpr auto __u = "__mm_storeh_pi_v2f32";
};
struct __mm_store_ss_struct_Reflection {
    static constexpr auto __u = "float";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m128_u";
};
struct __mm_load1_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __loadu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __loadu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __loadu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_load_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_loadl_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_store_sd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m128d_u";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __mm_storeh_pd_struct_Reflection {
    static constexpr auto __u = "double";
};
struct __loadu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __mm_loadl_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __storeu_si128_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_si64_Reflection {
    static constexpr auto __v = "long long";
};
struct __storeu_si32_Reflection {
    static constexpr auto __v = "int";
};
struct __storeu_si16_Reflection {
    static constexpr auto __v = "short";
};
struct __mm_storel_epi64_struct_Reflection {
    static constexpr auto __u = "long long";
};
struct __mm_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __mm256_broadcast_sd_struct_Reflection {
    static constexpr auto __d = "double";
};
struct __mm256_broadcast_ss_struct_Reflection {
    static constexpr auto __f = "float";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __loadu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m256d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m256_u";
};
struct __storeu_si256_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __loadu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_si512_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_pd_Reflection {
    static constexpr auto __v = "__m512d_u";
};
struct __storeu_ps_Reflection {
    static constexpr auto __v = "__m512_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi64_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi32_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m512i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __loadu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi16_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m128i_u";
};
struct __storeu_epi8_Reflection {
    static constexpr auto __v = "__m256i_u";
};
struct __mm_load_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __loadu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __mm_store_sh_struct_Reflection {
    static constexpr auto __u = "_Float16";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m512h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m256h_u";
};
struct __storeu_ph_Reflection {
    static constexpr auto __v = "__m128h_u";
};
struct __loadu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __storeu_i16_Reflection {
    static constexpr auto __v = "unsigned short";
};
struct __loadu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __storeu_i32_Reflection {
    static constexpr auto __v = "unsigned int";
};
struct __loadu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __storeu_i64_Reflection {
    static constexpr auto __v = "unsigned long long";
};
struct __tile1024i_str_Reflection {
    static constexpr auto row = "const unsigned short";
    static constexpr auto col = "const unsigned short";
    static constexpr auto tile = "_tile1024i";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __mm_store_sbh_struct_Reflection {
    static constexpr auto __u = "__bf16";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m256bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m128bh_u";
};
struct __loadu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct __storeu_pbh_Reflection {
    static constexpr auto __v = "__m512bh_u";
};
struct string_literal_Reflection {
};
struct uint128_fallback_Reflection {
    static constexpr auto lo_ = "int";
    static constexpr auto hi_ = "int";
};
struct _Reflection {
    static constexpr auto  = "F";
};
struct count_code_points_Reflection {
    static constexpr auto count = "size_t *";
};
struct _Reflection {
    static constexpr auto  = "const char *";
    static constexpr auto  = "size_t &";
    static constexpr auto  = "size_t &";
};
struct is_integral_Reflection {
};
struct is_integral_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_fast_float_Reflection {
};
struct is_locale_Reflection {
};
struct basic_memory_buffer_Reflection {
    static constexpr auto store_ = "T[SIZE]";
    static constexpr auto alloc_ = "Allocator";
};
struct is_contiguous_Reflection {
};
struct format_error_Reflection {
};
struct loc_value_Reflection {
    static constexpr auto value_ = "int";
};
struct format_facet_Reflection {
    static constexpr auto separator_ = "int";
    static constexpr auto grouping_ = "int";
    static constexpr auto decimal_point_ = "int";
};
struct _Reflection {
};
struct thousands_sep_result_Reflection {
    static constexpr auto grouping = "int";
    static constexpr auto thousands_sep = "Char";
};
struct format_decimal_result_Reflection {
    static constexpr auto begin = "Iterator";
    static constexpr auto end = "Iterator";
};
struct utf8_to_utf16_Reflection {
    static constexpr auto buffer_ = "int";
};
struct to_utf8_Reflection {
    static constexpr auto buffer_ = "Buffer";
};
struct decimal_fp_Reflection {
    static constexpr auto significand = "int";
    static constexpr auto exponent = "int";
};
struct basic_fp_Reflection {
    static constexpr auto f = "F";
    static constexpr auto e = "int";
};
struct _Reflection {
};
struct find_escape_result_Reflection {
    static constexpr auto begin = "const Char *";
    static constexpr auto end = "const Char *";
    static constexpr auto cp = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct write_int_data_Reflection {
    static constexpr auto size = "size_t";
    static constexpr auto padding = "size_t";
};
struct _Reflection {
};
struct digit_grouping_Reflection {
    static constexpr auto grouping_ = "int";
    static constexpr auto thousands_sep_ = "int";
};
struct next_state_Reflection {
    static constexpr auto group = "int";
    static constexpr auto pos = "int";
};
struct write_int_arg_Reflection {
    static constexpr auto abs_value = "UInt";
    static constexpr auto prefix = "unsigned int";
};
struct loc_writer_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto sep = "int";
    static constexpr auto grouping = "int";
    static constexpr auto decimal_point = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct _Reflection {
};
struct counting_iterator_Reflection {
    static constexpr auto count_ = "size_t";
};
struct value_type_Reflection {
};
struct _Reflection {
};
struct float_specs_Reflection {
    static constexpr auto precision = "int";
    static constexpr auto format = "float_format";
    static constexpr auto sign = "sign_t";
    static constexpr auto upper = "_Bool";
    static constexpr auto locale = "_Bool";
    static constexpr auto binary32 = "_Bool";
    static constexpr auto showpoint = "_Bool";
};
struct big_decimal_fp_Reflection {
    static constexpr auto significand = "const char *";
    static constexpr auto significand_size = "int";
    static constexpr auto exponent = "int";
};
struct fallback_digit_grouping_Reflection {
};
struct has_isfinite_Reflection {
};
struct bigint_Reflection {
    static constexpr auto bigits_ = "int";
    static constexpr auto exp_ = "int";
};
struct _Reflection {
};
struct _Reflection {
};
struct default_arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto args = "int";
    static constexpr auto loc = "locale_ref";
};
struct arg_formatter_Reflection {
    static constexpr auto out = "int";
    static constexpr auto specs = "const format_specs<Char> &";
    static constexpr auto locale = "locale_ref";
};
struct width_checker_Reflection {
};
struct precision_checker_Reflection {
};
struct udl_arg_Reflection {
    static constexpr auto str = "const Char *";
};
struct format_int_Reflection {
    static constexpr auto buffer_ = "char[0]";
    static constexpr auto str_ = "char *";
};
struct bytes_Reflection {
    static constexpr auto data_ = "string_view";
};
struct group_digits_view_Reflection {
    static constexpr auto value = "T";
};
struct nested_view_Reflection {
    static constexpr auto fmt = "const int *";
    static constexpr auto value = "const T *";
};
struct nested_formatter_Reflection {
    static constexpr auto width_ = "int";
    static constexpr auto fill_ = "detail::fill_t<char>";
    static constexpr auto align_ = "align_t";
    static constexpr auto formatter_ = "int";
};
struct join_view_Reflection {
    static constexpr auto begin = "It";
    static constexpr auto end = "Sentinel";
    static constexpr auto sep = "basic_string_view<Char>";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct _Reflection {
    static constexpr auto divisor = "int";
    static constexpr auto shift_amount = "int";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct cache_accessor_Reflection {
};
struct compute_mul_result_Reflection {
    static constexpr auto result = "int";
    static constexpr auto is_integer = "_Bool";
};
struct compute_mul_parity_result_Reflection {
    static constexpr auto parity = "_Bool";
    static constexpr auto is_integer = "_Bool";
};
struct _Reflection {
    static constexpr auto  = "class fmt::detail::utf8_to_utf16 *";
};
struct singleton_Reflection {
    static constexpr auto upper = "unsigned char";
    static constexpr auto lower_count = "unsigned char";
};
struct is_convertible_to_basic_format_string_Reflection {
};
struct is_convertible_to_any_format_string_Reflection {
};
struct spdlog_ex_Reflection {
    static constexpr auto msg_ = "int";
};
struct source_loc_Reflection {
    static constexpr auto filename = "const char *";
    static constexpr auto line = "int";
    static constexpr auto funcname = "const char *";
};
struct file_event_handlers_Reflection {
    static constexpr auto before_open = "std::function<void (const int &)>";
    static constexpr auto after_open = "std::function<void (const int &, int *)>";
    static constexpr auto before_close = "std::function<void (const int &, int *)>";
    static constexpr auto after_close = "std::function<void (const int &)>";
};
struct condition_variable_any_Reflection {
    static constexpr auto __cv_ = "condition_variable";
    static constexpr auto __mut_ = "shared_ptr<mutex>";
};
struct __unlock_guard_Reflection {
    static constexpr auto __lock_ = "_Lock &";
};
struct __thread_struct_Reflection {
    static constexpr auto __p_ = "__thread_struct_imp *";
};
struct __thread_specific_ptr_Reflection {
    static constexpr auto __key_ = "__libcpp_tls_key";
};
struct hash_Reflection {
};
struct thread_Reflection {
    static constexpr auto __t_ = "__libcpp_thread_t";
};
struct periodic_worker_Reflection {
    static constexpr auto active_ = "_Bool";
    static constexpr auto worker_thread_ = "std::thread";
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto cv_ = "std::condition_variable";
};
struct registry_Reflection {
    static constexpr auto logger_map_mutex_ = "std::mutex";
    static constexpr auto flusher_mutex_ = "std::mutex";
    static constexpr auto tp_mutex_ = "std::recursive_mutex";
    static constexpr auto log_levels_ = "int";
    static constexpr auto formatter_ = "int";
    static constexpr auto global_log_level_ = "spdlog::level::level_enum";
    static constexpr auto flush_level_ = "level::level_enum";
    static constexpr auto err_handler_ = "err_handler";
    static constexpr auto tp_ = "std::shared_ptr<thread_pool>";
    static constexpr auto periodic_flusher_ = "int";
    static constexpr auto default_logger_ = "std::shared_ptr<logger>";
    static constexpr auto automatic_registration_ = "_Bool";
    static constexpr auto backtrace_n_messages_ = "size_t";
};
struct circular_q_Reflection {
    static constexpr auto max_items_ = "size_t";
    static constexpr auto head_ = "int";
    static constexpr auto tail_ = "int";
    static constexpr auto overrun_counter_ = "size_t";
    static constexpr auto v_ = "int";
};
struct log_msg_Reflection {
    static constexpr auto logger_name = "string_view_t";
    static constexpr auto level = "level::level_enum";
    static constexpr auto time = "log_clock::time_point";
    static constexpr auto thread_id = "size_t";
    static constexpr auto color_range_start = "size_t";
    static constexpr auto color_range_end = "size_t";
    static constexpr auto source = "source_loc";
    static constexpr auto payload = "string_view_t";
};
struct log_msg_buffer_Reflection {
    static constexpr auto buffer = "int";
};
struct backtracer_Reflection {
    static constexpr auto mutex_ = "std::mutex";
    static constexpr auto enabled_ = "std::atomic<_Bool>";
    static constexpr auto messages_ = "circular_q<log_msg_buffer>";
};
struct logger_Reflection {
    static constexpr auto name_ = "int";
    static constexpr auto sinks_ = "int";
    static constexpr auto level_ = "spdlog::level_t";
    static constexpr auto flush_level_ = "spdlog::level_t";
    static constexpr auto custom_err_handler_ = "err_handler";
    static constexpr auto tracer_ = "details::backtracer";
};
struct formatter_Reflection {
};
struct padding_info_Reflection {
    static constexpr auto width_ = "size_t";
    static constexpr auto side_ = "pad_side";
    static constexpr auto truncate_ = "_Bool";
    static constexpr auto enabled_ = "_Bool";
};
struct flag_formatter_Reflection {
    static constexpr auto padinfo_ = "padding_info";
};
struct custom_flag_formatter_Reflection {
};
struct pattern_formatter_Reflection {
    static constexpr auto pattern_ = "int";
    static constexpr auto eol_ = "int";
    static constexpr auto pattern_time_type_ = "pattern_time_type";
    static constexpr auto need_localtime_ = "_Bool";
    static constexpr auto cached_tm_ = "int";
    static constexpr auto last_log_secs_ = "std::chrono::seconds";
    static constexpr auto formatters_ = "int";
    static constexpr auto custom_handlers_ = "int";
};
struct _Reflection {
};
struct FMT_COMPILE_STRING_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_imp_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __is_tree_value_type_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_key_value_types_Reflection {
};
struct __tree_node_base_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_map_pointer_types_Reflection {
};
struct __tree_node_types_Reflection {
};
struct __make_tree_node_types_Reflection {
};
struct __tree_end_node_Reflection {
    static constexpr auto __left_ = "pointer";
};
struct __tree_node_base_Reflection {
    static constexpr auto __right_ = "pointer";
    static constexpr auto __parent_ = "__parent_pointer";
    static constexpr auto __is_black_ = "_Bool";
};
struct __tree_node_Reflection {
    static constexpr auto __value_ = "__node_value_type";
};
struct __tree_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __value_constructed = "_Bool";
};
struct __generic_container_node_destructor_Reflection {
};
struct __tree_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_const_iterator_Reflection {
    static constexpr auto __ptr_ = "__iter_pointer";
};
struct __tree_Reflection {
    static constexpr auto __begin_node_ = "__iter_pointer";
    static constexpr auto __end_node_ = "__end_node_t";
    static constexpr auto __node_alloc_ = "__node_allocator";
    static constexpr auto __size_ = "size_type";
    static constexpr auto __value_comp_ = "value_compare";
};
struct _DetachedTreeCache_Reflection {
    static constexpr auto __t_ = "__tree<_Tp, _Compare, _Allocator> *";
    static constexpr auto __cache_root_ = "__node_pointer";
    static constexpr auto __cache_elem_ = "__node_pointer";
};
struct __map_value_compare_Reflection {
};
struct __map_value_compare_Reflection {
    static constexpr auto __comp_ = "_Compare";
};
struct __map_node_destructor_Reflection {
    static constexpr auto __na_ = "allocator_type &";
    static constexpr auto __first_constructed = "_Bool";
    static constexpr auto __second_constructed = "_Bool";
};
struct __value_type_Reflection {
    static constexpr auto __cc_ = "value_type";
};
struct __extract_key_value_types_Reflection {
};
struct __map_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct __map_const_iterator_Reflection {
    static constexpr auto __i_ = "_TreeIterator";
};
struct map_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct multimap_Reflection {
    static constexpr auto __tree_ = "__base";
};
struct value_compare_Reflection {
    static constexpr auto comp = "key_compare";
};
struct __container_traits_Reflection {
};
struct mdc_Reflection {
};
struct scoped_padder_Reflection {
    static constexpr auto padinfo_ = "const padding_info &";
    static constexpr auto dest_ = "int &";
    static constexpr auto remaining_pad_ = "long";
    static constexpr auto spaces_ = "string_view_t";
};
struct null_scoped_padder_Reflection {
};
struct name_formatter_Reflection {
};
struct level_formatter_Reflection {
};
struct short_level_formatter_Reflection {
};
struct a_formatter_Reflection {
};
struct A_formatter_Reflection {
};
struct b_formatter_Reflection {
};
struct B_formatter_Reflection {
};
struct c_formatter_Reflection {
};
struct C_formatter_Reflection {
};
struct D_formatter_Reflection {
};
struct Y_formatter_Reflection {
};
struct m_formatter_Reflection {
};
struct d_formatter_Reflection {
};
struct H_formatter_Reflection {
};
struct I_formatter_Reflection {
};
struct M_formatter_Reflection {
};
struct S_formatter_Reflection {
};
struct e_formatter_Reflection {
};
struct f_formatter_Reflection {
};
struct F_formatter_Reflection {
};
struct E_formatter_Reflection {
};
struct p_formatter_Reflection {
};
struct r_formatter_Reflection {
};
struct R_formatter_Reflection {
};
struct T_formatter_Reflection {
};
struct z_formatter_Reflection {
    static constexpr auto last_update_ = "log_clock::time_point";
    static constexpr auto offset_minutes_ = "int";
};
struct t_formatter_Reflection {
};
struct pid_formatter_Reflection {
};
struct v_formatter_Reflection {
};
struct ch_formatter_Reflection {
    static constexpr auto ch_ = "char";
};
struct aggregate_formatter_Reflection {
    static constexpr auto str_ = "int";
};
struct color_start_formatter_Reflection {
};
struct color_stop_formatter_Reflection {
};
struct source_location_formatter_Reflection {
};
struct source_filename_formatter_Reflection {
};
struct short_filename_formatter_Reflection {
};
struct source_linenum_formatter_Reflection {
};
struct source_funcname_formatter_Reflection {
};
struct elapsed_formatter_Reflection {
    static constexpr auto last_message_time_ = "log_clock::time_point";
};
struct mdc_formatter_Reflection {
};
struct full_formatter_Reflection {
    static constexpr auto cache_timestamp_ = "std::chrono::seconds";
    static constexpr auto cached_datetime_ = "int";
    static constexpr auto mdc_formatter_ = "mdc_formatter<null_scoped_padder>";
};
struct sink_Reflection {
    static constexpr auto level_ = "level_t";
};
struct console_mutex_Reflection {
};
struct console_nullmutex_Reflection {
};
struct wincolor_sink_Reflection {
    static constexpr auto out_handle_ = "void *";
    static constexpr auto mutex_ = "mutex_t &";
    static constexpr auto should_do_colors_ = "_Bool";
    static constexpr auto formatter_ = "int";
    static constexpr auto colors_ = "std::array<int, level::n_levels>";
};
struct wincolor_stdout_sink_Reflection {
};
struct wincolor_stderr_sink_Reflection {
};
struct synchronous_factory_Reflection {
};
struct file_helper_Reflection {
    static constexpr auto open_tries_ = "const int";
    static constexpr auto open_interval_ = "const unsigned int";
    static constexpr auto fd_ = "int *";
    static constexpr auto filename_ = "int";
    static constexpr auto event_handlers_ = "file_event_handlers";
};
struct base_sink_Reflection {
    static constexpr auto formatter_ = "int";
    static constexpr auto mutex_ = "Mutex";
};
struct basic_file_sink_Reflection {
    static constexpr auto file_helper_ = "details::file_helper";
};
struct __iom_t1_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t2_Reflection {
    static constexpr auto __mask_ = "class ios_base::fmtflags";
};
struct __iom_t3_Reflection {
    static constexpr auto __base_ = "int";
};
struct __iom_t4_Reflection {
    static constexpr auto __fill_ = "_CharT";
};
struct __iom_t5_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t6_Reflection {
    static constexpr auto __n_ = "int";
};
struct __iom_t7_Reflection {
    static constexpr auto __mon_ = "_MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t8_Reflection {
    static constexpr auto __mon_ = "const _MoneyT &";
    static constexpr auto __intl_ = "_Bool";
};
struct __iom_t9_Reflection {
    static constexpr auto __tm_ = "int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __iom_t10_Reflection {
    static constexpr auto __tm_ = "const int *";
    static constexpr auto __fmt_ = "const _CharT *";
};
struct __quoted_output_proxy_Reflection {
    static constexpr auto __first_ = "const _CharT *";
    static constexpr auto __last_ = "const _CharT *";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __quoted_proxy_Reflection {
    static constexpr auto __string_ = "basic_string<_CharT, _Traits, _Allocator> &";
    static constexpr auto __delim_ = "_CharT";
    static constexpr auto __escape_ = "_CharT";
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct __can_convert_char_Reflection {
};
struct _NullSentinel_Reflection {
};
struct __is_pathable_string_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_char_array_Reflection {
};
struct __is_pathable_iter_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct __is_pathable_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathCVT_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct _PathExport_Reflection {
};
struct path_Reflection {
    static constexpr auto __pn_ = "string_type";
};
struct basic_filebuf_Reflection {
    static constexpr auto __extbuf_ = "char *";
    static constexpr auto __extbufnext_ = "const char *";
    static constexpr auto __extbufend_ = "const char *";
    static constexpr auto __extbuf_min_ = "char[8]";
    static constexpr auto __ebs_ = "size_t";
    static constexpr auto __intbuf_ = "char_type *";
    static constexpr auto __ibs_ = "size_t";
    static constexpr auto __file_ = "int *";
    static constexpr auto __cv_ = "const codecvt<char_type, char, state_type> *";
    static constexpr auto __st_ = "state_type";
    static constexpr auto __st_last_ = "state_type";
    static constexpr auto __om_ = "class ios_base::openmode";
    static constexpr auto __cm_ = "class ios_base::openmode";
    static constexpr auto __owns_eb_ = "_Bool";
    static constexpr auto __owns_ib_ = "_Bool";
    static constexpr auto __always_noconv_ = "_Bool";
};
struct basic_ifstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_ofstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct basic_fstream_Reflection {
    static constexpr auto __sb_ = "basic_filebuf<char_type, traits_type>";
};
struct file_status_Reflection {
    static constexpr auto __ft_ = "file_type";
    static constexpr auto __prms_ = "perms";
};
struct space_info_Reflection {
    static constexpr auto capacity = "int";
    static constexpr auto free = "int";
    static constexpr auto available = "int";
};
struct directory_entry_Reflection {
    static constexpr auto __p_ = "_Path";
    static constexpr auto __data_ = "__cached_data";
};
struct __cached_data_Reflection {
    static constexpr auto __size_ = "int";
    static constexpr auto __nlink_ = "int";
    static constexpr auto __write_time_ = "file_time_type";
    static constexpr auto __sym_perms_ = "perms";
    static constexpr auto __non_sym_perms_ = "perms";
    static constexpr auto __type_ = "file_type";
    static constexpr auto __cache_type_ = "_CacheType";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct _Reflection {
    static constexpr auto  = "file_type &";
};
struct __dir_element_proxy_Reflection {
    static constexpr auto __elem_ = "directory_entry";
};
struct directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__dir_stream>";
};
struct iterator_Reflection {
    static constexpr auto __stashed_elem_ = "path";
    static constexpr auto __path_ptr_ = "const path *";
    static constexpr auto __entry_ = "class path::__string_view";
    static constexpr auto __state_ = "_ParserState";
};
struct recursive_directory_iterator_Reflection {
    static constexpr auto __imp_ = "shared_ptr<__shared_imp>";
    static constexpr auto __rec_ = "_Bool";
};
struct formatbuf_Reflection {
    static constexpr auto buffer_ = "buffer<char_type> &";
};
struct file_access_tag_Reflection {
};
struct file_access_Reflection {
};
struct streamed_view_Reflection {
    static constexpr auto value = "const T &";
};
struct basic_ostream_formatter_Reflection {
};
struct Logger_Reflection {
};
struct Event_Reflection {
    static constexpr auto Handled = "_Bool";
};
struct EventDispatcher_Reflection {
    static constexpr auto m_Event = "Event &";
};
struct WindowProperties_Reflection {
    static constexpr auto Title = "int";
    static constexpr auto Width = "unsigned int";
    static constexpr auto Height = "unsigned int";
};
struct Window_Reflection {
};
struct WindowResizeEvent_Reflection {
    static constexpr auto m_Width = "unsigned int";
    static constexpr auto m_Height = "unsigned int";
};
struct WindowCloseEvent_Reflection {
};
struct AppTickEvent_Reflection {
};
struct AppUpdateEvent_Reflection {
};
struct AppRenderEvent_Reflection {
};
struct Layer_Reflection {
    static constexpr auto m_DebugName = "int";
};
struct LayerStack_Reflection {
    static constexpr auto m_Layers = "int";
    static constexpr auto m_LayerInsertIndex = "unsigned int";
};
struct MouseMovedEvent_Reflection {
    static constexpr auto m_MouseX = "float";
    static constexpr auto m_MouseY = "float";
};
struct MouseScrolledEvent_Reflection {
    static constexpr auto m_XOffset = "float";
    static constexpr auto m_YOffset = "float";
};
struct MouseButtonEvent_Reflection {
    static constexpr auto m_Button = "int";
};
struct MouseButtonPressedEvent_Reflection {
};
struct MouseButtonReleasedEvent_Reflection {
};
struct KeyEvent_Reflection {
    static constexpr auto m_KeyCode = "int";
};
struct KeyPressedEvent_Reflection {
    static constexpr auto m_RepeatCount = "int";
};
struct KeyReleasedEvent_Reflection {
};
struct KeyTypedEvent_Reflection {
};
struct ImGuiLayer_Reflection {
};
struct RenderLayer_Reflection {
    static constexpr auto m_SceneHovered = "_Bool";
    static constexpr auto m_SavedX = "double";
    static constexpr auto m_SavedY = "double";
    static constexpr auto m_CursorLocked = "_Bool";
};
struct Component_Reflection {
    static constexpr auto gameObject = "std::weak_ptr<GameObject>";
};
struct GameObject_Reflection {
    static constexpr auto enabled = "_Bool";
    static constexpr auto components = "int";
    static constexpr auto children = "int";
    static constexpr auto parent = "std::weak_ptr<GameObject>";
    static constexpr auto name = "int";
    static constexpr auto transform = "std::shared_ptr<Transform>";
    static constexpr auto scene = "std::weak_ptr<Scene>";
};
struct GameLogicLayer_Reflection {
    static constexpr auto deltaTime = "float";
    static constexpr auto lastTime = "std::chrono::high_resolution_clock::time_point";
};
struct Application_Reflection {
    static constexpr auto m_Running = "_Bool";
    static constexpr auto m_Window = "int";
    static constexpr auto m_ImGuiLayer = "ImGuiLayer *";
    static constexpr auto m_RenderLayer = "RenderLayer *";
    static constexpr auto m_GameLogicLayer = "GameLogicLayer *";
    static constexpr auto m_LayerStack = "LayerStack";
};
